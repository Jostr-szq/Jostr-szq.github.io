<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式篇：（二）策略模式</title>
      <link href="2023/06/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>2023/06/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式定义了一系列可以在运行时设置或切换的可互换的对象。这个模式分为三个部分：<img src="/2023/06/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/Strategy_Diagram.png" class="" title="Strategy_Diagram"></p><ul><li>使用策略的对象。当模式用于iOS应用程序开发时，这通常是视图控制器，但从技术上讲，它可以是任何需要可互换行为的对象。</li><li>策略协议定义了每个策略必须实施的方法。</li><li>策略是符合策略协议的对象。</li></ul><h2 id="为什么要使用它？"><a href="#为什么要使用它？" class="headerlink" title="为什么要使用它？"></a>为什么要使用它？</h2><p>当您有两个或更多可互换的不同行为时，请使用策略模式。</p><p>这种模式类似于委托模式：两种模式都依赖于协议而不是具体对象来增加灵活性。因此，任何实现策略协议的对象都可以在运行时用作策略。</p><p>与委托不同，策略模式使用一系列对象。</p><p>代表通常在运行时固定。例如，UITableView的数据源和委托可以从Interface Builder中设置，这些数据源和委托在运行时很少发生更改。然而，策略旨在在运行时易于互换。</p><h2 id="Playground-实例"><a href="#Playground-实例" class="headerlink" title="Playground 实例"></a>Playground 实例</h2><p>在Starter目录中打开FundamentalDesignPatterns.xcworkspace，然后打开概述页面。</p><p>您将看到该策略列在行为模式下。这是因为策略模式是关于一个对象使用另一个对象做某事。</p><p>点击策略链接打开该页面。</p><p>对于代码示例，考虑一个使用几种“电影评级服务”的应用程序，如烂番茄®、IMDb和Metacritic。您可以使用策略模式通过创建为每个服务定义通用API的协议来简化事情，而不是直接在视图控制器中为每个服务编写代码，并且其中可能有复杂的if-else语句。</p><p>首先，您需要创建一个策略协议。在代码示例之后添加以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MovieRatingStrategy</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> ratingServiceName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">fetchRating</span><span class="params">(<span class="keyword">for</span> movieTitle: String,</span></span></span><br><span class="line"><span class="function"><span class="params">    success: <span class="params">(<span class="number">_</span> rating: String, <span class="number">_</span> review: String)</span></span></span> -&gt; ())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>您将使用ratingServiceName来显示哪个服务提供了评级。例如，这将返回“烂番茄”。</li><li>您将使用fetchRatingForMovieTitle(_:success:)异步获取电影评级。在真正的应用程序中，您也可能出现故障关闭，因为网络调用并不总是成功。</li></ol><p>接下来，为RottenTomatoesClient添加以下实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RottenTomatoesClient</span>: <span class="title">MovieRatingStrategy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">let</span> ratingServiceName = <span class="string">&quot;Rotten Tomatoes&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">fetchRating</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> movieTitle: String,</span></span></span><br><span class="line"><span class="function"><span class="params">    success: <span class="params">(<span class="number">_</span> rating: String, <span class="number">_</span> review: String)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// In a real service, you’d make a network request...</span></span><br><span class="line">    <span class="comment">// Here, we just provide dummy values...</span></span><br><span class="line">    <span class="keyword">let</span> rating = <span class="string">&quot;95%&quot;</span></span><br><span class="line">    <span class="keyword">let</span> review = <span class="string">&quot;It rocked!&quot;</span></span><br><span class="line">    success(rating, review)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，为IMDbClient添加以下实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMDbClient</span>: <span class="title">MovieRatingStrategy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">let</span> ratingServiceName = <span class="string">&quot;IMDb&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">fetchRating</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> movieTitle: String,</span></span></span><br><span class="line"><span class="function"><span class="params">    success: <span class="params">(<span class="number">_</span> rating: String, <span class="number">_</span> review: String)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> rating = <span class="string">&quot;3 / 10&quot;</span></span><br><span class="line">    <span class="keyword">let</span> review = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      It was terrible! The audience was throwing rotten</span></span><br><span class="line"><span class="string">      tomatoes!</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">    success(rating, review)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这两个客户端都符合MovieRatingStrategy，因此消费对象不需要直接了解。相反，他们可以单独依赖协议。</p><p>例如，在文件末尾添加以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRatingViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// MARK: - Properties</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> movieRatingClient: <span class="type">MovieRatingStrategy!</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// MARK: - Outlets</span></span><br><span class="line">  <span class="meta">@IBOutlet</span> <span class="keyword">public</span> <span class="keyword">var</span> movieTitleTextField: <span class="type">UITextField!</span></span><br><span class="line">  <span class="meta">@IBOutlet</span> <span class="keyword">public</span> <span class="keyword">var</span> ratingServiceNameLabel: <span class="type">UILabel!</span></span><br><span class="line">  <span class="meta">@IBOutlet</span> <span class="keyword">public</span> <span class="keyword">var</span> ratingLabel: <span class="type">UILabel!</span></span><br><span class="line">  <span class="meta">@IBOutlet</span> <span class="keyword">public</span> <span class="keyword">var</span> reviewLabel: <span class="type">UILabel!</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// MARK: - View Lifecycle</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    ratingServiceNameLabel.text =</span><br><span class="line">      movieRatingClient.ratingServiceName</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// MARK: - Actions</span></span><br><span class="line">  <span class="meta">@IBAction</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">searchButtonPressed</span><span class="params">(sender: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> movieTitle = movieTitleTextField.text</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    movieRatingClient.fetchRating(<span class="keyword">for</span>: movieTitle) &#123;</span><br><span class="line">      (rating, review) <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>.ratingLabel.text = rating</span><br><span class="line">      <span class="keyword">self</span>.reviewLabel.text = review</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当此视图控制器在应用程序中实例化时（无论如何发生这种情况），您需要设置movieRatingClient。注意视图控制器如何不知道MovieRatingStrategy的具体实现。</p><p>使用哪个MovieRatingStrategy的决定可以推迟到运行时，如果您的应用程序允许，用户甚至可以选择。</p><h2 id="你应该注意什么？"><a href="#你应该注意什么？" class="headerlink" title="你应该注意什么？"></a>你应该注意什么？</h2><p>小心过度使用这种模式。特别是，如果行为永远不会改变，可以将其直接放在消耗视图控制器或对象上下文中。这种模式的诀窍是知道何时拔出行为，当你确定需要它的地方时，懒洋洋地这样做是可以的。</p><h2 id="教程项目"><a href="#教程项目" class="headerlink" title="教程项目"></a>教程项目</h2><p>您将继续上一章的RabbleWabble应用程序。如果您跳过上一章，或者您想要重新开始，请打开Finder并导航到您下载本章资源的位置，然后在Xcode中打开初学者▸ RabbleWabble ▸ RabbleWabble.xcodeproj。</p><p>与其每次都以相同的顺序显示问题，如果它们是随机的，那不是很好吗？然而，一些用户可能也想按顺序研究问题。您将使用策略模式来允许这两个选项！</p><p>右键单击黄色的RabbleWabble组，选择新组并将其命名为策略。</p><p>再次右键单击黄色的RabbleWabble组，然后选择按名称排序。</p><p>您的文件层次结构现在应该看起来像这样：</p><p>右键单击新添加的策略组，然后选择新文件。在iOS选项卡下，选择Swift文件，然后按下一步。输入QuestionStrategy.swift作为名称，然后按创建。</p><p>将QuestionStrategy.swift的内容替换为以下内容:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">QuestionStrategy</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> title: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> correctCount: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> incorrectCount: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">advanceToNextQuest</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">currentQuestion</span><span class="params">()</span></span> -&gt; <span class="type">Question</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">markQuestionCorrect</span><span class="params">(<span class="number">_</span> question: Question)</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">markQuestionIncorrect</span><span class="params">(<span class="number">_</span> question: Question)</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">questionIndexTitle</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在您将要使用的策略模式的核心创建了协议。</p><p>以下是您将如何使用协议的每个部分：（包括）</p><ul><li><p>标题将是选择一组问题的标题，例如“基本短语”。</p></li><li><p>correctCount和 incorrectCount将分别返回当前正确和不正确的问题数量。</p></li><li><p>advanceToNextQuestion()将用于进入下一个问题。如果没有下一个问题，此方法将返回false。否则，它将返回为真。</p></li><li><p>currentQuestion()将简单地返回当前问题。由于prevansToNextQuestion()将阻止用户超越可用问题，currentQuestion()将始终返回一个问题，并且永远不会为零。</p></li><li><p>正如他们的方法名称所暗示的那样，markQuestionCorrect(<em>:)会将问题标记为正确，markQuestionIncorrect(</em>:)会将问题标记为不正确。</p></li><li><p>questionIndexTitle()将返回当前问题的“索引标题”，以指示进度，例如总共十个问题中的第一个问题的“1 / 10”。</p></li></ul><p>在策略组下创建另一个文件，名为SequentialQuestionStrategy.swift。将其内容替换为以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialQuestionStrategy</span>: <span class="title">QuestionStrategy</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//MARK: - Properties</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> correctCount: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> incorrectCount: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> questionGroup: <span class="type">QuestionGroup</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> questionIndex = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//MARK: - Object Lifecycle</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(questionGroup: <span class="type">QuestionGroup</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.questionGroup = questionGroup</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//MARK: - QuestionStrategy</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> title: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> questionGroup.title</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">currentQuestion</span><span class="params">()</span></span> -&gt; <span class="type">Question</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> questionGroup.questions[questionIndex]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">advanceToNextQuest</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> questionIndex + <span class="number">1</span> &lt;</span><br><span class="line">            questionGroup.questions.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    questionIndex += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">markQuestionCorrect</span><span class="params">(<span class="number">_</span> question: Question)</span></span> &#123;</span><br><span class="line">    correctCount += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">markQuestionIncorrect</span><span class="params">(<span class="number">_</span> question: Question)</span></span> &#123;</span><br><span class="line">    incorrectCount += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">questionIndexTitle</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\(questionIndex + 1)&quot;</span> + <span class="string">&quot;\(questionGroup.questions.count)&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SequentialQuestionStrategy 通过其指定的初始值设定项 init（questionGroup：） 获取 QuestionGroup，它的功能基本上与应用程序当前一样;它按照 questionGroup.questions 定义的顺序从一个问题转到下一个问题。</p><p>在策略组下创建另一个名为RandomQuestionStrategy.swift的文件。将其内容替换为以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GameplayKit.GKRandomSource</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomQuestionStrategy</span>: <span class="title">QuestionStrategy</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//MARK: - Properties</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> correctCount: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> incorrectCount: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> questionGroup: <span class="type">QuestionGroup</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> questionIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> questions: [<span class="type">Question</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//MARK: - Object Lifecycle</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(questionGroup: <span class="type">QuestionGroup</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.questionGroup = questionGroup</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> randomSource = <span class="type">GKRandomSource</span>.sharedRandom()</span><br><span class="line">    <span class="keyword">self</span>.questions = randomSource.arrayByShufflingObjects(<span class="keyword">in</span>: questionGroup.questions) <span class="keyword">as</span>! [<span class="type">Question</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//MARK: - QuestionStrategy</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> title: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> questionGroup.title</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">currentQuestion</span><span class="params">()</span></span> -&gt; <span class="type">Question</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> questions[questionIndex]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">advanceToNextQuest</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> questionIndex + <span class="number">1</span> &lt;</span><br><span class="line">            questions.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    questionIndex += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">markQuestionCorrect</span><span class="params">(<span class="number">_</span> question: Question)</span></span> &#123;</span><br><span class="line">    correctCount += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">markQuestionIncorrect</span><span class="params">(<span class="number">_</span> question: Question)</span></span> &#123;</span><br><span class="line">    incorrectCount += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">questionIndexTitle</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\(questionIndex + 1)&quot;</span> + <span class="string">&quot;\(questions.count)&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>让我们回顾一下有趣的部分：</p><ul><li>虽然您可以自己实现随机化逻辑，但GameplayKit.GKRandomSource已经为您做到了，而且效果非常好。尽管有GameplayKit的名称，但这实际上是一个相当小和范围广泛的导入，所以使用它真的没有缺点。</li><li>在这里，您使用GKRandomSource.sharedRandom()，这是GKRandomSource的“默认”或单例。另一种设计模式！苹果框架充满了它们，您将在下一章中了解这种模式。现在，只需接受它为您提供GKRandomSource的实例。</li><li>方法arrayByShufflingObjects完全按照它所说的做：它接受一个数组并随机洗牌元素。这正是你在这里所需要的！唯一的缺点是它返回了NSArray，因为苹果仍然在整个核心框架中完全采用Swift。然而，你可以简单地把这个投到[Question]，你就可以走了！</li></ul><p>接下来，您需要更新QuestionViewController以使用QuestionStrategy，而不是直接使用QuestionGroup。</p><p>打开QuestionViewController.swift，并在委托下方添加以下属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> questionStrategy: <span class="type">QuestionStrategy!</span> &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    navigationItem.title = questionStrategy.title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，将showQuestion()替换为以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">showQuestion</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> question = questionStrategy.currentQuestion()</span><br><span class="line">  </span><br><span class="line">  questionView.answerLabel.text = question.answer</span><br><span class="line">  questionView.promptLabel.text = question.prompt</span><br><span class="line">  questionView.hintLabel.text = question.hint</span><br><span class="line">  </span><br><span class="line">  questionView.answerLabel.isHidden = <span class="literal">true</span></span><br><span class="line">  questionView.hintLabel.isHidden = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  questionIndexItem.title = questionStrategy.questionIndexTitle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，您使用QuestionStrategy获取（1）currentQuestion（）和（2）questionIndexTitle（），而不是从QuestionGroup获取这些。</p><p>最后，将handleCorrect(<em>:)和handleIncorrect(</em>:)替换为以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">handleCancelPressed</span><span class="params">(sender: UIBarButtonItem)</span></span> &#123;</span><br><span class="line">  delegate?.questionViewController(<span class="keyword">self</span>, didCancel: questionStrategy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于您已经更新了所有直接使用问题组的地方，请删除问题组属性。</p><p>此时，您不应该在QuestionViewController上看到任何编译器错误或警告。但是，如果您尝试构建和运行，您仍然会收到编译器错误。</p><p>这是因为您还需要更新SelectQuestionViewController，它创建QuestionViewController实例并实现QuestionViewControllerDelegate。</p><p>打开SelectQuestionGroupViewController.swift，并在prepare（for:sender:）中替换此行：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewController.questionGroup = selectedQuestionGroup</span><br></pre></td></tr></table></figure><p>…与以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewController.questionStrategy = <span class="type">RandomQuestionStrategy</span>(questionGroup: selectedQuestionGroup)</span><br></pre></td></tr></table></figure><p>最后，将实现QuestionViewControllerDelegate的整个扩展替换为以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - QuestionViewControllerDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SelectQuestionGroupViewController</span>: <span class="title">QuestionViewControllerDelegate</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">questionViewController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> viewController: QuestionViewController,</span></span></span><br><span class="line"><span class="function"><span class="params">    didCancel questionGroup: QuestionStrategy)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    navigationController?.popToViewController(<span class="keyword">self</span>,</span><br><span class="line">                                              animated: <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">questionViewController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> viewController: QuestionViewController,</span></span></span><br><span class="line"><span class="function"><span class="params">    didComplete questionGroup: QuestionStrategy)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    navigationController?.popToViewController(<span class="keyword">self</span>,</span><br><span class="line">                                              animated: <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>构建并运行您的项目。选择任何单元格，按几次绿色勾号或红色X按钮，按后退，然后再次按同一单元格并重复该过程。你应该看到，这些问题现在是随机的！</p><p>在Xcode中切换回SelectQuestionGroupViewController.swift，并在prepare(for:sender:)中替换此行：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewController.questionStrategy = <span class="type">RandomQuestionStrategy</span>(questionGroup: selectedQuestionGroup)</span><br></pre></td></tr></table></figure><p>…用这个代替：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewController.questionStrategy = <span class="type">SequentialQuestionStrategy</span>(questionGroup: selectedQuestionGroup)</span><br></pre></td></tr></table></figure><p>构建和运行，并再次尝试解决同一组问题。这一次，他们现在应该处于相同的顺序。</p><p>那有多酷？您现在可以根据需要轻松交换不同的策略！</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>在本章中，您了解了策略模式。以下是它的要点：</p><ul><li><p>策略模式定义了可以在运行时设置或切换的可互换对象家族。</p></li><li><p>这种模式由三部分组成：使用策略的对象、策略协议和策略对象家族。</p></li><li><p>战略模式与委托模式相似：两种模式都使用协议来获得灵活性。然而，与委托模式不同，策略意味着在运行时切换，而委托通常是固定的。</p></li></ul><p>您已经为Rabble Wabble在运行时切换问题策略奠定了基础。然而，您实际上还没有为用户在运行应用程序时创建这样做的方法！您将使用另一种模式来保持这样的用户偏好：单调设计模式。</p><p>继续下一章，了解单顿设计模式，并继续构建Rabble Wabble。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS-事件传递响应链</title>
      <link href="2023/03/22/iOS-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE/"/>
      <url>2023/03/22/iOS-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲解iOS触摸事件的一系列机制，涉及的问题大致包括：</p><ul><li>触摸事件由触屏生成后如何传递到当前应用？</li><li>应用接收触摸事件后如何寻找最佳响应者？实现原理？</li><li>触摸事件如何沿着响应链流动？</li><li>响应链、手势识别器、UIControl之间对于触摸事件的响应有着什么样的瓜葛？</li></ul><blockquote><p>tips: iOS中的事件除了触摸事件，还包括加速计事件、远程控制事件。由于两者不在本文讨论范畴，因此文中所说事件均特指触摸事件。</p></blockquote><a id="more"></a><p><strong>事件的生命周期</strong></p><p>当指尖触碰屏幕的那一刻，一个触摸事件就在系统中生成了。经过IPC进程间通信，事件最终被传递到了合适的应用。在应用内历经峰回路转的奇幻之旅后，最终被释放。大致经过如下图：</p><img src="/2023/03/22/iOS-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE/640-20230214153022840.jpeg" class="" title="图片"><p>触摸事件流动过程 图片来源(<a href="http://qingmo.me/2017/03/04/FlowOfUITouch/">http://qingmo.me/2017/03/04/FlowOfUITouch/</a>)</p><p><strong>系统响应阶段</strong></p><p>1.手指触碰屏幕，屏幕感应到触碰后，将事件交由IOKit处理。</p><p>2.IOKit将触摸事件封装成一个IOHIDEvent对象，并通过mach port传递给SpringBoad进程。</p><p>mach port 进程端口，各进程之间通过它进行通信。</p><p>SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。</p><p>\3. SpringBoard进程因接收到触摸事件，触发了主线程runloop的source1事件源的回调。</p><p>此时SpringBoard会根据当前桌面的状态，判断应该由谁处理此次触摸事件。因为事件发生时，你可能正在桌面上翻页，也可能正在刷微博。若是前者（即前台无APP运行），则触发SpringBoard本身主线程runloop的source0事件源的回调，将事件交由桌面系统去消耗；若是后者（即有app正在前台运行），则将触摸事件通过IPC传递给前台APP进程，接下来的事情便是APP内部对于触摸事件的响应了。</p><p><strong>APP响应阶段</strong></p><p>1.APP进程的mach port接受到SpringBoard进程传递来的触摸事件，主线程的runloop被唤醒，触发了source1回调。</p><p>2.source1回调又触发了一个source0回调，将接收到的IOHIDEvent对象封装成UIEvent对象，此时APP将正式开始对于触摸事件的响应。</p><p>3.source0回调内部将触摸事件添加到UIApplication对象的事件队列中。事件出队后，UIApplication开始一个寻找最佳响应者的过程，这个过程又称hit-testing，细节将在[寻找事件的最佳响应者]一节阐述。另外，此处开始便是与我们平时开发相关的工作了。</p><p>4.寻找到最佳响应者后，接下来的事情便是事件在响应链中的传递及响应了，关于响应链相关的内容详见[事件的响应及在响应链中的传递]一节。事实上，事件除了被响应者消耗，还能被手势识别器或是target-action模式捕捉并消耗掉。其中涉及对触摸事件的响应优先级，详见[事件的三徒弟UIResponder、UIGestureRecognizer、UIControl]一节。</p><p>5.触摸事件历经坎坷后要么被某个响应对象捕获后释放，要么致死也没能找到能够响应的对象，最终释放。至此，这个触摸事件的使命就算终结了。runloop若没有其他事件需要处理，也将重归于眠，等待新的事件到来后唤醒。</p><blockquote><p>现在，你可以回答第一个问题了。触摸事件从触屏产生后，由IOKit将触摸事件传递给SpringBoard进程，再由SpringBoard分发给当前前台APP处理。</p></blockquote><p><strong>触摸、事件、响应者</strong></p><p>说了那么多，到底什么是触摸、什么是事件、什么是响应者？先简单科普一下。</p><p><strong>UITouch</strong></p><p>源起触摸</p><ul><li>一个手指一次触摸屏幕，就对应生成一个UITouch对象。多个手指同时触摸，生成多个UITouch对象。</li><li>多个手指先后触摸，系统会根据触摸的位置判断是否更新同一个UITouch对象。若两个手指一前一后触摸同一个位置（即双击），那么第一次触摸时生成一个UITouch对象，第二次触摸更新这个UITouch对象（UITouch对象的 tap count 属性值从1变成2）；若两个手指一前一后触摸的位置不同，将会生成两个UITouch对象，两者之间没有联系。</li><li>每个UITouch对象记录了触摸的一些信息，包括触摸时间、位置、阶段、所处的视图、窗口等信息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;触摸的各个阶段状态 </span><br><span class="line">&#x2F;&#x2F;例如当手指移动时，会更新phase属性到UITouchPhaseMoved；手指离屏后，更新到UITouchPhaseEnded</span><br><span class="line">typedef NS_ENUM(NSInteger, UITouchPhase) &#123;</span><br><span class="line">    UITouchPhaseBegan,             &#x2F;&#x2F; whenever a finger touches the surface.</span><br><span class="line">    UITouchPhaseMoved,             &#x2F;&#x2F; whenever a finger moves on the surface.</span><br><span class="line">    UITouchPhaseStationary,        &#x2F;&#x2F; whenever a finger is touching the surface but hasn&#39;t moved since the previous event.</span><br><span class="line">    UITouchPhaseEnded,             &#x2F;&#x2F; whenever a finger leaves the surface.</span><br><span class="line">    UITouchPhaseCancelled,         &#x2F;&#x2F; whenever a touch doesn&#39;t end but we need to stop tracking (e.g. putting device to face)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>手指离开屏幕一段时间后，确定该UITouch对象不会再被更新将被释放。</p><p><strong>UIEvent</strong></p><p>事件的真身</p><ul><li>触摸的目的是生成触摸事件供响应者响应，一个触摸事件对应一个UIEvent对象，其中的 type 属性标识了事件的类型（之前说过事件不只是触摸事件）。</li><li>UIEvent对象中包含了触发该事件的触摸对象的集合，因为一个触摸事件可能是由多个手指同时触摸产生的。触摸对象集合通过 allTouches 属性获取。</li></ul><p><strong>UIResponder</strong></p><p>一切为了满足它的野心</p><p>每个响应者都是一个UIResponder对象，即所有派生自UIResponder的对象，本身都具备响应事件的能力。因此以下类的实例都是响应者：</p><ul><li>UIView</li><li>UIViewController</li><li>UIApplication</li><li>AppDelegate</li></ul><p>响应者之所以能响应事件，因为其提供了4个处理触摸事件的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;手指触碰屏幕，触摸开始</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">&#x2F;&#x2F;手指在屏幕上移动</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">&#x2F;&#x2F;手指离开屏幕，触摸结束</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">&#x2F;&#x2F;触摸结束前，某个系统事件中断了触摸，例如电话呼入</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure><p>这几个方法在响应者对象接收到事件的时候调用，用于做出对事件的响应。关于响应者何时接收到事件以及事件如何沿着响应链传递将在下面章节说明。</p><p><strong>寻找事件的最佳响应者（Hit-Testing）</strong></p><p>第一节讲过APP接收到触摸事件后，会被放入当前应用的一个事件队列中（PS为什么是队列而不是栈？很好理解因为触摸事件必然是先发生先执行，切合队列FIFO的原则）。</p><p>每个事件的理想宿命是被能够响应它的对象响应后释放，然而响应者诸多，事件一次只有一个，谁都想把事件抢到自己碗里来，为避免纷争，就得有一个先后顺序，也就是得有一个响应者的优先级。因此这就存在一个寻找事件最佳响应者（又称第一响应者 first responder）的过程，目的是找到一个具备最高优先级响应权的响应对象（the most appropriate responder object），这个过程叫做Hit-Testing，那个命中的最佳响应者称为hit-tested view。</p><p>本节要探讨的问题是：</p><ol><li>应用接收到事件后，如何寻找最佳响应者？底层如何实现？</li><li>寻找最佳响应者过程中事件的拦截。</li></ol><p><strong>事件自下而上的传递</strong></p><p>应用接收到事件后先将其置入事件队列中以等待处理。出队后，application首先将事件传递给当前应用最后显示的窗口（UIWindow）询问其能否响应事件。若窗口能响应事件，则传递给子视图询问是否能响应，子视图若能响应则继续询问子视图。子视图询问的顺序是优先询问后添加的子视图，即子视图数组中靠后的视图。事件传递顺序如下：</p><blockquote><p>UIApplication ——&gt; UIWindow ——&gt; 子视图 ——&gt; … ——&gt; 子视图</p></blockquote><p>事实上把UIWindow也看成是视图即可，这样整个传递过程就是一个递归询问子视图能否响应事件过程，且后添加的子视图优先级高（对于window而言就是后显示的window优先级高）。</p><p><strong>具体流程如下：</strong></p><ol><li>UIApplication首先将事件传递给窗口对象（UIWindow），若存在多个窗口，则优先询问后显示的窗口。</li><li>若窗口不能响应事件，则将事件传递其他窗口；若窗口能响应事件，则从后往前询问窗口的子视图。</li><li>重复步骤2。即视图若不能响应，则将事件传递给上一个同级子视图；若能响应，则从后往前询问当前视图的子视图。</li><li>视图若没有能响应的子视图了，则自身就是最合适的响应者。</li></ol><p><strong>示例：</strong></p><p>![图片](data:image/svg+xml,%3C%3Fxml version=’1.0’ encoding=’UTF-8’%3F%3E%3Csvg width=’1px’ height=’1px’ viewBox=’0 0 1 1’ version=’1.1’ xmlns=’<a href="http://www.w3.org/2000/svg&#39;">http://www.w3.org/2000/svg&#39;</a> xmlns:xlink=’<a href="http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke=’none’ stroke-width=’1’ fill=’none’ fill-rule=’evenodd’ fill-opacity=’0’%3E%3Cg transform=’translate(-249.000000, -126.000000)’ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p><p>视图层级如下（同一层级的视图越在下面，表示越后添加）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">├── B</span><br><span class="line">│   └── D</span><br><span class="line">└── C</span><br><span class="line">    ├── E</span><br><span class="line">    └── F</span><br></pre></td></tr></table></figure><p>现在假设在E视图所处的屏幕位置触发一个触摸，应用接收到这个触摸事件事件后，先将事件传递给UIWindow，然后自下而上开始在子视图中寻找最佳响应者。事件传递的顺序如下所示：</p><img src="/2023/03/22/iOS-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE/640.png" class="" title="图片"><ol><li>UIWindow将事件传递给其子视图A</li><li>A判断自身能响应该事件，继续将事件传递给C（因为视图C比视图B后添加，因此优先传给C）。</li><li>C判断自身能响应事件，继续将事件传递给F（同理F比E后添加）。</li><li>F判断自身不能响应事件，C又将事件传递给E。</li><li>E判断自身能响应事件，同时E已经没有子视图，因此最终E就是最佳响应者。</li></ol><p><strong>Hit-Testing的本质</strong></p><p>上面讲了事件在响应者之间传递的规则，视图通过判断自身能否响应事件来决定是否继续向子视图传递。那么问题来了：视图如何判断能否响应事件？以及视图如何将事件传递给子视图？</p><p>首先要知道的是，以下几种状态的视图无法响应事件：</p><ul><li>不允许交互：userInteractionEnabled = NO</li><li>隐藏：hidden = YES 如果父视图隐藏，那么子视图也会隐藏，隐藏的视图无法接收事件</li><li>透明度：alpha &lt; 0.01 如果设置一个视图的透明度&lt;0.01，会直接影响子视图的透明度。alpha：0.0~0.01为透明。</li></ul><p><strong>hitTest:withEvent:</strong></p><p>每个UIView对象都有一个 hitTest:withEvent: 方法，这个方法是Hit-Testing过程中最核心的存在，其作用是询问事件在当前视图中的响应者，同时又是作为事件传递的桥梁。</p><p>hitTest:withEvent: 方法返回一个UIView对象，作为当前视图层次中的响应者。默认实现是：</p><ul><li>若当前视图无法响应事件，则返回nil</li><li>若当前视图可以响应事件，但无子视图可以响应事件，则返回自身作为当前视图层次中的事件响应者</li><li>若当前视图可以响应事件，同时有子视图可以响应，则返回子视图层次中的事件响应者</li></ul><p>一开始UIApplication将事件通过调用UIWindow对象的 hitTest:withEvent: 传递给UIWindow对象，UIWindow的 hitTest:withEvent: 在执行时若判断本身能响应事件，则调用子视图的 hitTest:withEvent: 将事件传递给子视图并询问子视图上的最佳响应者。最终UIWindow返回一个视图层次中的响应者视图给UIApplication，这个视图就是hit-testing的最佳响应者。</p><p>系统对于视图能否响应事件的判断逻辑除了之前提到的3种限制状态，默认能响应的条件就是触摸点在当前视图的坐标系范围内。因此，hitTest:withEvent: 的默认实现就可以推测了，大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    &#x2F;&#x2F;3种状态无法响应事件</span><br><span class="line">     if (self.userInteractionEnabled &#x3D;&#x3D; NO || self.hidden &#x3D;&#x3D; YES ||  self.alpha &lt;&#x3D; 0.01) return nil; </span><br><span class="line">    &#x2F;&#x2F;触摸点若不在当前视图上则无法响应事件</span><br><span class="line">    if ([self pointInside:point withEvent:event] &#x3D;&#x3D; NO) return nil; </span><br><span class="line">    &#x2F;&#x2F;从后往前遍历子视图数组 </span><br><span class="line">    int count &#x3D; (int)self.subviews.count; </span><br><span class="line">    for (int i &#x3D; count - 1; i &gt;&#x3D; 0; i--) </span><br><span class="line">    &#123; </span><br><span class="line">        &#x2F;&#x2F; 获取子视图</span><br><span class="line">        UIView *childView &#x3D; self.subviews[i]; </span><br><span class="line">        &#x2F;&#x2F; 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标</span><br><span class="line">        CGPoint childP &#x3D; [self convertPoint:point toView:childView]; </span><br><span class="line">        &#x2F;&#x2F;询问子视图层级中的最佳响应视图</span><br><span class="line">        UIView *fitView &#x3D; [childView hitTest:childP withEvent:event]; </span><br><span class="line">        if (fitView) </span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;如果子视图中有更合适的就返回</span><br><span class="line">            return fitView; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F;没有在子视图中找到更合适的响应视图，那么自身就是最合适的</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是 pointInside:withEvent: 这个方法，用于判断触摸点是否在自身坐标范围内。默认实现是若在坐标范围内则返回YES，否则返回NO。</p><p>现在我们在上述示例的视图层次中的每个视图类中添加下面3个方法来验证一下之前的分析（注意 hitTest:withEvent: 和 pointInside:withEvent: 方法都要调用父类的实现，否则不会按照默认的逻辑来执行Hit-Testing）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [super pointInside:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单点触摸视图E，相关日志打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-[AView hitTest:withEvent:]</span><br><span class="line">-[AView pointInside:withEvent:]</span><br><span class="line">-[CView hitTest:withEvent:]</span><br><span class="line">-[CView pointInside:withEvent:]</span><br><span class="line">-[FView hitTest:withEvent:]</span><br><span class="line">-[FView pointInside:withEvent:]</span><br><span class="line">-[EView hitTest:withEvent:]</span><br><span class="line">-[EView pointInside:withEvent:]</span><br><span class="line">-[EView touchesBegan:withEvent:]</span><br></pre></td></tr></table></figure><p>可以看到最终是视图E先对事件进行了响应，同时事件传递过程也和之前的分析一致。事实上单击后从 [AView hitTest:withEvent:] 到 [EView pointInside:withEvent:] 的过程会执行两遍，两次传的是同一个touch，区别在于touch的状态不同，第一次是begin阶段，第二次是end阶段。也就是说，<strong>应用对于事件的传递起源于触摸状态的变化。</strong></p><p><strong>Hit-Testing过程中的事件拦截（自定义事件流向）</strong></p><p>实际开发中可能会遇到一些特殊的交互需求，需要定制视图对于事件的响应。例如下面Tabbar的这种情况，中间的原型按钮是底部Tabbar上的控件，而Tabbar是添加在控制器根视图中的。默认情况下我们点击图中红色方框中按钮的区域，会发现按钮并不会得到响应。</p><p>![图片](data:image/svg+xml,%3C%3Fxml version=’1.0’ encoding=’UTF-8’%3F%3E%3Csvg width=’1px’ height=’1px’ viewBox=’0 0 1 1’ version=’1.1’ xmlns=’<a href="http://www.w3.org/2000/svg&#39;">http://www.w3.org/2000/svg&#39;</a> xmlns:xlink=’<a href="http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke=’none’ stroke-width=’1’ fill=’none’ fill-rule=’evenodd’ fill-opacity=’0’%3E%3Cg transform=’translate(-249.000000, -126.000000)’ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p><p>hit-testing过程中事件拦截场景</p><p>分析一下原因其实很容易就能明白问题所在。忽略不相关的控件，视图层次如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RootView</span><br><span class="line">└── TableView</span><br><span class="line">└── TabBar</span><br><span class="line">    └── CircleButton</span><br></pre></td></tr></table></figure><p>点击红色方框区域后，生成的触摸事件首先传到UIWindow，然后传到控制器的根视图即RootView。RootView经判断可以响应触摸事件，而后将事件传给了子控件TabBar。问题就出在这里，因为触摸点不在TabBar的坐标范围内，因此TabBar无法响应该触摸事件，hitTest:withEvent: 直接返回了nil。而后RootView就会询问TableView是否能够响应，事实上是可以的，因此事件最终被TableView消耗。整个过程，事件根本没有传递到圆形按钮。</p><p>有问题就会有解决策略。经过分析，发现原因是hit-Testing的过程中，事件在传递到TabBar的时候没能继续往CircleButton传，因为点击区域坐标不在Tabbar的坐标范围内，因此Tabbar被识别成了无法响应事件。既然如此，我们可以修改事件hit-Testing的过程，当点击红色方框区域时让事件流向原型按钮。</p><p>事件传递到TabBar时，TabBar的 hitTest:withEvent: 被调用，但是 pointInside:withEvent: 会返回NO，如此一来 hitTest:withEvent: 返回了nil。既然如此，可以重写TabBard的 pointInside:withEvent: ，判断当前触摸坐标是否在子视图CircleButton的坐标范围内，若在，则返回YES，反之返回NO。这样一来点击红色区域，事件最终会传递到CircleButton，CircleButton能够响应事件，最终事件就由CircleButton响应了。同时点击红色方框以外的非TabBar区域的情况下，因为TabBar无法响应事件，会按照预期由TableView响应。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;TabBar</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;将触摸点坐标转换到在CircleButton上的坐标</span><br><span class="line">    CGPoint pointTemp &#x3D; [self convertPoint:point toView:_CircleButton];</span><br><span class="line">    &#x2F;&#x2F;若触摸点在CricleButton上则返回YES</span><br><span class="line">    if ([_CircleButton pointInside:pointTemp withEvent:event]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;否则返回默认的操作</span><br><span class="line">    return [super pointInside:point withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，点击红色方框区域的按钮就有效了。</p><blockquote><p>现在第二个问题也可以回答了。另外项目中如遇到不按常理出牌的事件响应需求，相信你也应该可以应对了。</p></blockquote><p><strong>事件的响应及在响应链中的传递</strong></p><p>经历Hit-Testing后，UIApplication已经知道事件的最佳响应者是谁了，接下来要做的事情就是：</p><ol><li>将事件传递给最佳响应者响应</li><li>事件沿着响应链传递</li></ol><p><strong>事件响应的前奏</strong></p><p>因为最佳响应者具有最高的事件响应优先级，因此UIApplication会先将事件传递给它供其响应。首先，UIApplication将事件通过 sendEvent: 传递给事件所属的window，window同样通过 sendEvent: 再将事件传递给hit-tested view，即最佳响应者。过程如下：</p><blockquote><p>UIApplication ——&gt; UIWindow ——&gt; hit-tested view</p></blockquote><p>以寻找事件的最佳响应者一节中点击视图E为例，在EView的 touchesBegan:withEvent: 上断点查看调用栈就能看清这一过程：</p><img src="/2023/03/22/iOS-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE/640-20230214153022673.jpeg" class="" title="图片"><p>那么问题又来了。这个过程中，假如应用中存在多个window对象，UIApplication是怎么知道要把事件传给哪个window的？window又是怎么知道哪个视图才是最佳响应者的呢？</p><p>其实简单思考一下，这两个过程都是传递事件的过程，涉及的方法都是 sendEvent: ，而该方法的参数（UIEvent对象）是唯一贯穿整个经过的线索，那么就可以大胆猜测必然是该触摸事件对象上绑定了这些信息。事实上之前在介绍UITouch的时候就说过touch对象保存了触摸所属的window及view，而event对象又绑定了touch对象，如此一来，是不是就说得通了。要是不信的话，那就自定义一个Window类，重写 sendEvent： 方法，捕捉该方法调用时参数event的状态，答案就显而易见了。</p><img src="/2023/03/22/iOS-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE/640-20230214153022764.jpeg" class="" title="图片"><p>至于这两个属性是什么时候绑定到touch对象上的，必然是在hit-testing的过程中呗，仔细想想hit-testing干的不就是这个事儿吗~</p><p><strong>事件的响应</strong></p><p>前面介绍UIResponder的时候说过，每个响应者必定都是UIResponder对象，通过4个响应触摸事件的方法来响应事件。每个UIResponder对象默认都已经实现了这4个方法，但是默认不对事件做任何处理，单纯只是将事件沿着响应链传递。若要截获事件进行自定义的响应操作，就要重写相关的方法。例如，通过重写 touchesMoved: withEvent: 方法实现简单的视图拖动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure><p>每个响应触摸事件的方法都会接收两个参数，分别对应触摸对象集合和事件对象。通过监听触摸对象中保存的触摸点位置的变动，可以时时修改视图的位置。视图（UIView）作为响应者对象，本身已经实现了 touchesMoved: withEvent: 方法，因此要创建一个自定义视图（继承自UIView），重写该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;MovedView</span><br><span class="line">&#x2F;&#x2F;重写touchesMoved方法(触摸滑动过程中持续调用)</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取触摸对象</span><br><span class="line">    UITouch *touch &#x3D; [touches anyObject];</span><br><span class="line">    &#x2F;&#x2F;获取前一个触摸点位置</span><br><span class="line">    CGPoint prePoint &#x3D; [touch previousLocationInView:self];</span><br><span class="line">    &#x2F;&#x2F;获取当前触摸点位置</span><br><span class="line">    CGPoint curPoint &#x3D; [touch locationInView:self];</span><br><span class="line">    &#x2F;&#x2F;计算偏移量</span><br><span class="line">    CGFloat offsetX &#x3D; curPoint.x - prePoint.x;</span><br><span class="line">    CGFloat offsetY &#x3D; curPoint.y - prePoint.y;</span><br><span class="line">    &#x2F;&#x2F;相对之前的位置偏移视图</span><br><span class="line">    self.transform &#x3D; CGAffineTransformTranslate(self.transform, offsetX, offsetY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个响应者都有权决定是否执行对事件的响应，只要重写相关的触摸事件方法即可。</p><p><strong>事件的传递（响应链）</strong></p><p>前面一直在提最佳响应者，之所以称之为“最佳”，是因为其具备响应事件的最高优先权（响应链顶端的男人）。最佳响应者首先接收到事件，然后便拥有了对事件的绝对控制权：即它可以选择独吞这个事件，也可以将这个事件往下传递给其他响应者，这个由响应者构成的视图链就称之为响应链。</p><blockquote><p>需要注意的是，上一节中也说到了事件的传递，与此处所说的事件的传递有本质区别。上一节所说的事件传递的目的是为了寻找事件的最佳响应者，是自下而上的传递；而这里的事件传递目的是响应者做出对事件的响应，这个过程是自上而下的。前者为“寻找”，后者为“响应”。</p></blockquote><p><strong>响应者对于事件的操作方式：</strong></p><p>响应者对于事件的拦截以及传递都是通过 touchesBegan:withEvent: 方法控制的，该方法的默认实现是将事件沿着默认的响应链往下传递。</p><p>响应者对于接收到的事件有3种操作：</p><ul><li>不拦截，默认操作</li></ul><p>事件会自动沿着默认的响应链往下传递</p><ul><li>拦截，不再往下分发事件</li></ul><p>重写 touchesBegan:withEvent: 进行事件处理，不调用父类的 touchesBegan:withEvent:</p><ul><li>拦截，继续往下分发事件</li></ul><p>重写 touchesBegan:withEvent: 进行事件处理，同时调用父类的 touchesBegan:withEvent: 将事件往下传递</p><p><strong>响应链中的事件传递规则：</strong></p><p>每一个响应者对象（UIResponder对象）都有一个 nextResponder 方法，用于获取响应链中当前对象的下一个响应者。因此，一旦事件的最佳响应者确定了，这个事件所处的响应链就确定了。</p><p>对于响应者对象，默认的 nextResponder 实现如下：</p><ul><li>UIView</li></ul><p>若视图是控制器的根视图，则其nextResponder为控制器对象；否则，其nextResponder为父视图。</p><ul><li>UIViewController</li></ul><p>若控制器的视图是window的根视图，则其nextResponder为窗口对象；若控制器是从别的控制器present出来的，则其nextResponder为presenting view controller。</p><ul><li>UIWindow</li></ul><p>nextResponder为UIApplication对象。</p><ul><li>UIApplication</li></ul><p>若当前应用的app delegate是一个UIResponder对象，且不是UIView、UIViewController或app本身，则UIApplication的nextResponder为app delegate。</p><p>![图片](data:image/svg+xml,%3C%3Fxml version=’1.0’ encoding=’UTF-8’%3F%3E%3Csvg width=’1px’ height=’1px’ viewBox=’0 0 1 1’ version=’1.1’ xmlns=’<a href="http://www.w3.org/2000/svg&#39;">http://www.w3.org/2000/svg&#39;</a> xmlns:xlink=’<a href="http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke=’none’ stroke-width=’1’ fill=’none’ fill-rule=’evenodd’ fill-opacity=’0’%3E%3Cg transform=’translate(-249.000000, -126.000000)’ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p><p>上图是官网对于响应链的示例展示，若触摸发生在UITextField上，则事件的传递顺序是：</p><ul><li>UITextField ——&gt; UIView ——&gt; UIView ——&gt; UIViewController ——&gt; UIWindow ——&gt; UIApplication ——&gt; UIApplicationDelegation</li></ul><p>图中虚线箭头是指若该UIView是作为UIViewController根视图存在的，则其nextResponder为UIViewController对象；若是直接add在UIWindow上的，则其nextResponder为UIWindow对象。</p><p>可以用以下方式打印一个响应链中的每一个响应对象，在最佳响应者的 touchBegin:withEvent: 方法中调用即可（别忘了调用父类的方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)printResponderChain</span><br><span class="line">&#123;</span><br><span class="line">    UIResponder *responder &#x3D; self;</span><br><span class="line">    printf(&quot;%s&quot;,[NSStringFromClass([responder class]) UTF8String]);</span><br><span class="line">    while (responder.nextResponder) &#123;</span><br><span class="line">        responder &#x3D; responder.nextResponder;</span><br><span class="line">        printf(&quot; --&gt; %s&quot;,[NSStringFromClass([responder class]) UTF8String]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上一节原型按钮的案例为例，重写CircleButton的 touchBegin:withEvent:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    [self printResponderChain];</span><br><span class="line">    [super touchesBegan:touches withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击原型按钮的任意区域，打印出的完整响应链如下：</p><p>CircleButton –&gt; CustomeTabBar –&gt; UIView –&gt; UIViewController –&gt; UIViewControllerWrapperView –&gt; UINavigationTransitionView –&gt; UILayoutContainerView –&gt; UINavigationController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate</p><p>另外如果有需要，完全可以重写响应者的 nextResponder 方法来自定义响应链。</p><blockquote><p>现在，第三个问题也解决了。</p></blockquote><p><strong>事件的三徒弟UIResponder、UIGestureRecognizer、UIControl</strong></p><p>iOS中，除了UIResponder能够响应事件，手势识别器、UIControl同样具备对事件的处理能力。当这几者同时存在于某一场景下的时候，事件又会有怎样的归宿呢？</p><p><strong>抛砖引玉</strong></p><p>场景界面如图：</p><img src="/2023/03/22/iOS-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE/640-20230214153022675.jpeg" class="" title="图片"><p>手势冲突场景</p><p>代码不能再简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F;底部是一个绑定了单击手势的backView</span><br><span class="line">    UITapGestureRecognizer *tap &#x3D; [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(actionTapView)];</span><br><span class="line">    [_backView addGestureRecognizer:tap];</span><br><span class="line">    &#x2F;&#x2F;上面是一个常规的tableView</span><br><span class="line">    _tableMain.tableFooterView &#x3D; [UIView new];</span><br><span class="line">    &#x2F;&#x2F;还有一个和tableView同级的button</span><br><span class="line">    [_button addTarget:self action:@selector(buttonTap) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)actionTapView&#123;</span><br><span class="line">    NSLog(@&quot;backview taped&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)buttonTap &#123;</span><br><span class="line">    NSLog(@&quot;button clicked!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    NSLog(@&quot;cell selected!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我像往常一样怀揣着吃奶的自信点击了cell。what？？点不动？？点歪了吗？？再点，还是没反应！！我试着短按了一小会儿cell，依旧没反应！！我不死心，长按了一会儿，didSelectRowAtIndexPath终于调了，还算给点面子 - -。然后我又点了下面的button，没有任何问题。but what ？？</p><p>为了搞清楚状况，我自定义了相关的控件类，均重写了4个响应触摸事件的方法以打印日志（每个重写的触摸事件方法都调用了父类的方法以保证事件默认传递逻辑）。</p><p>观察各种情况下的日志现象：</p><p>现象一 快速点击cell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backview taped</span><br></pre></td></tr></table></figure><p>现象二 短按cell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[GLTableView touchesBegan:withEvent:]</span><br><span class="line">backview taped</span><br><span class="line">-[GLTableView touchesCancelled:withEvent:]</span><br></pre></td></tr></table></figure><p>现象三 长按cell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[GLTableView touchesBegan:withEvent:]</span><br><span class="line">-[GLTableView touchesEnded:withEvent:]</span><br><span class="line">cell selected!</span><br></pre></td></tr></table></figure><p>现象四 点击button</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[GLButton touchesBegan:withEvent:]</span><br><span class="line">-[GLButton touchesEnded:withEvent:]</span><br><span class="line">button clicked!</span><br></pre></td></tr></table></figure><blockquote><p>如果上面的现象依旧能让你舒心地抿上一口咖啡，那么恭喜你，本节的内容已经不适合你了。如果觉得一脸懵逼，那就继续往下看吧~</p></blockquote><p><strong>二师兄—手势识别器</strong></p><p>关于手势识别器即 UIGestureRecognizer 本身的使用不是本文要所讨论的内容，按下不表。此处要探讨的是：<strong>手势识别器与UIResponder的联系</strong>。</p><p>事实上，手势分为离散型手势（discrete gestures）和持续型手势（continuous gesture）。系统提供的离散型手势包括点按手势（UITapGestureRecognizer）和轻扫手势（UISwipeGestureRecognizer），其余均为持续型手势。</p><p>两者主要区别在于状态变化过程：</p><ul><li>离散型：</li></ul><p>识别成功：Possible —&gt; Recognized</p><p>识别失败：Possible —&gt; Failed</p><ul><li>持续型：</li></ul><p>完整识别：Possible —&gt; Began —&gt; [Changed] —&gt; Ended</p><p>不完整识别：Possible —&gt; Began —&gt; [Changed] —&gt; Cancel</p><p><strong>离散型手势</strong></p><p>先抛开上面的场景，看一个简单的demo。</p><p>![图片](data:image/svg+xml,%3C%3Fxml version=’1.0’ encoding=’UTF-8’%3F%3E%3Csvg width=’1px’ height=’1px’ viewBox=’0 0 1 1’ version=’1.1’ xmlns=’<a href="http://www.w3.org/2000/svg&#39;">http://www.w3.org/2000/svg&#39;</a> xmlns:xlink=’<a href="http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke=’none’ stroke-width=’1’ fill=’none’ fill-rule=’evenodd’ fill-opacity=’0’%3E%3Cg transform=’translate(-249.000000, -126.000000)’ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p><p>控制器的视图上add了一个View记为YellowView，并绑定了一个单击手势识别器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; LXFViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    UITapGestureRecognizer *tap &#x3D; [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(actionTap)];</span><br><span class="line">    [self.view addGestureRecognizer:tap];</span><br><span class="line">&#125;</span><br><span class="line">- (void)actionTap&#123;</span><br><span class="line">    NSLog(@&quot;View Taped&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单击YellowView，日志打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[YellowView touchesBegan:withEvent:]</span><br><span class="line">View Taped</span><br><span class="line">-[YellowView touchesCancelled:withEvent:]</span><br></pre></td></tr></table></figure><p>从日志上看出YellowView最后Cancel了对触摸事件的响应，而正常应当是触摸结束后，YellowView的 touchesEnded:withEvent: 的方法被调用才对。另外，期间还执行了手势识别器绑定的action 。我从官方文档找到了这样的解释：</p><blockquote><p>A window delivers touch events to a gesture recognizer before it delivers them to the hit-tested view attached to the gesture recognizer. Generally, if a gesture recognizer analyzes the stream of touches in a multi-touch sequence and doesn’t recognize its gesture, the view receives the full complement of touches. If a gesture recognizer recognizes its gesture, the remaining touches for the view are cancelled.The usual sequence of actions in gesture recognition follows a path determined by default values of the cancelsTouchesInView, delaysTouchesBegan, delaysTouchesEnded properties.</p></blockquote><p>大致理解是，Window在将事件传递给hit-tested view之前，会先将事件传递给相关的手势识别器并由手势识别器优先识别。若手势识别器成功识别了事件，就会取消hit-tested view对事件的响应；若手势识别器没能识别事件，hit-tested view才完全接手事件的响应权。</p><p>一句话概括：<strong>手势识别器比UIResponder具有更高的事件响应优先级</strong>！！</p><p>按照这个解释，Window在将事件传递给hit-tested view即YellowView之前，先传递给了控制器根视图上的手势识别器。手势识别器成功识别了该事件，通知Application取消YellowView对事件的响应。</p><p>然而看日志，却是YellowView的 touchesBegan:withEvent: 先调用了，既然手势识别器先响应，不应该上面的action先执行吗，这又怎么解释？事实上这个认知是错误的。手势识别器的action的调用时机（即此处的 actionTap）并不是手势识别器接收到事件的时机，而是手势识别器成功识别事件后的时机，即手势识别器的状态变为UIGestureRecognizerStateRecognized。因此从该日志中并不能看出事件是优先传递给手势识别器的，<strong>那该怎么证明Window先将事件传递给了手势识别器？</strong></p><p>要解决这个问题，只要知道手势识别器是如何接收事件的，然后在接收事件的方法中打印日志对比调用时间先后即可。说起来你可能不信，手势识别器对于事件的响应也是通过这4个熟悉的方法来实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure><p>需要注意的是，虽然手势识别器通过这几个方法来响应事件，但它并不是UIResponder的子类，相关的方法声明在 UIGestureRecognizerSubclass.h 中。</p><p>这样一来，我们便可以自定义一个单击手势识别器的类，重写这几个方法来监听手势识别器接收事件的时机。创建一个UITapGestureRecognizer的子类，重写响应事件的方法，每个方法中调用父类的实现，并替换demo中的手势识别器。另外需要在.m文件中引入 import &lt;UIKit/UIGestureRecognizerSubclass.h&gt; ，因为相关方法声明在该头文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; LXFTapGestureRecognizer (继承自UITapGestureRecognizer)</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    [super touchesBegan:touches withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    [super touchesMoved:touches withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    [super touchesEnded:touches withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    [super touchesCancelled:touches withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，再次点击YellowView，日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-[LXFTapGestureRecognizer touchesBegan:withEvent:]</span><br><span class="line">-[YellowView touchesBegan:withEvent:]</span><br><span class="line">-[LXFTapGestureRecognizer touchesEnded:withEvent:]</span><br><span class="line">View Taped</span><br><span class="line">-[YellowView touchesCancelled:withEvent:]</span><br></pre></td></tr></table></figure><p>很明显，确实是手势识别器先接收到了事件。之后手势识别器成功识别了手势，执行了action，再由Application取消了YellowView对事件的响应。</p><p><strong>Window怎么知道要把事件传递给哪些手势识别器？</strong></p><p>之前探讨过Application怎么知道要把event传递给哪个Window，以及Window怎么知道要把event传递给哪个hit-tested view的问题，答案是这些信息都保存在event所绑定的touch对象上。手势识别器也是一样的，event绑定的touch对象上维护了一个手势识别器数组，里面的手势识别器毫无疑问是在hit-testing的过程中收集的。打个断点看一下touch上绑定的手势识别器数组：</p><img src="/2023/03/22/iOS-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE/640-20230214153022670.jpeg" class="" title="图片"><p>Window先将事件传递给这些手势识别器，再传给hit-tested view。一旦有手势识别器成功识别了手势，Application就会取消hit-tested view对事件的响应。</p><p><strong>持续型手势</strong></p><p>将上面Demo中视图绑定的单击手势识别器用滑动手势识别器（UIPanGestureRecognizer）替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    UIPanGestureRecognizer *pan &#x3D; [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(actionPan)];</span><br><span class="line">    [self.view addGestureRecognizer:pan];</span><br><span class="line">&#125;</span><br><span class="line">- (void)actionPan&#123;</span><br><span class="line">    NSLog(@&quot;View panned&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在YellowView上执行一次滑动：</p><p>![图片](data:image/svg+xml,%3C%3Fxml version=’1.0’ encoding=’UTF-8’%3F%3E%3Csvg width=’1px’ height=’1px’ viewBox=’0 0 1 1’ version=’1.1’ xmlns=’<a href="http://www.w3.org/2000/svg&#39;">http://www.w3.org/2000/svg&#39;</a> xmlns:xlink=’<a href="http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke=’none’ stroke-width=’1’ fill=’none’ fill-rule=’evenodd’ fill-opacity=’0’%3E%3Cg transform=’translate(-249.000000, -126.000000)’ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p><p>日志打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-[YellowView touchesBegan:withEvent:]</span><br><span class="line">-[YellowView touchesMoved:withEvent:]</span><br><span class="line">-[YellowView touchesMoved:withEvent:]</span><br><span class="line">-[YellowView touchesMoved:withEvent:]</span><br><span class="line">View panned</span><br><span class="line">-[YellowView touchesCancelled:withEvent:]</span><br><span class="line">View panned</span><br><span class="line">View panned</span><br><span class="line">View panned</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在一开始滑动的过程中，手势识别器处在识别手势阶段，滑动产生的连续事件既会传递给手势识别器又会传递给YellowView，因此YellowView的 touchesMoved:withEvent: 在开始一段时间内会持续调用；当手势识别器成功识别了该滑动手势时，手势识别器的action开始调用，同时通知Application取消YellowView对事件的响应。之后仅由滑动手势识别器接收事件并响应，YellowView不再接收事件。</p><p>另外，在滑动的过程中，若手势识别器未能识别手势，则事件在触摸滑动过程中会一直传递给hit-tested view，直到触摸结束。读者可自行验证。</p><p><strong>手势识别器的3个属性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic) BOOL cancelsTouchesInView;</span><br><span class="line">@property(nonatomic) BOOL delaysTouchesBegan;</span><br><span class="line">@property(nonatomic) BOOL delaysTouchesEnded;</span><br></pre></td></tr></table></figure><p>先总结一下手势识别器与UIResponder对于事件响应的联系：</p><p>当触摸发生或者触摸的状态发生变化时，Window都会传递事件寻求响应。</p><ul><li>Window先将绑定了触摸对象的事件传递给触摸对象上绑定的手势识别器，再发送给触摸对象对应的hit-tested view。</li><li>手势识别器识别手势期间，若触摸对象的触摸状态发生变化，事件都是先发送给手势识别器再发送给hit-test view。</li><li>手势识别器若成功识别了手势，则通知Application取消hit-tested view对于事件的响应，并停止向hit-tested view发送事件；</li><li>若手势识别器未能识别手势，而此时触摸并未结束，则停止向手势识别器发送事件，仅向hit-test view发送事件。</li><li>若手势识别器未能识别手势，且此时触摸已经结束，则向hit-tested view发送end状态的touch事件以停止对事件的响应。</li></ul><p><strong>cancelsTouchesInView</strong></p><p>默认为YES。表示当手势识别器成功识别了手势之后，会通知Application取消响应链对事件的响应，并不再传递事件给hit-test view。若设置成NO，表示手势识别成功后不取消响应链对事件的响应，事件依旧会传递给hit-test view。</p><p>demo中设置: pan.cancelsTouchesInView = NO</p><p>滑动时日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-[YellowView touchesBegan:withEvent:]</span><br><span class="line">-[YellowView touchesMoved:withEvent:]</span><br><span class="line">-[YellowView touchesMoved:withEvent:]</span><br><span class="line">-[YellowView touchesMoved:withEvent:]</span><br><span class="line">View panned</span><br><span class="line">-[YellowView touchesMoved:withEvent:]</span><br><span class="line">View panned</span><br><span class="line">View panned</span><br><span class="line">-[YellowView touchesMoved:withEvent:]</span><br><span class="line">View panned</span><br><span class="line">-[YellowView touchesMoved:withEvent:]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>即便滑动手势识别器识别了手势，Application也会依旧发送事件给YellowView。</p><p><strong>delaysTouchesBegan</strong></p><p>默认为NO。默认情况下手势识别器在识别手势期间，当触摸状态发生改变时，Application都会将事件传递给手势识别器和hit-tested view；若设置成YES，则表示手势识别器在识别手势期间，截断事件，即不会将事件发送给hit-tested view。</p><p>设置 pan.delaysTouchesBegan = YES</p><p>日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">View panned</span><br><span class="line">View panned</span><br><span class="line">View panned</span><br><span class="line">View panned</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因为滑动手势识别器在识别期间，事件不会传递给YellowView，因此期间YellowView的 touchesBegan:withEvent: 和 touchesMoved:withEvent: 都不会被调用；而后滑动手势识别器成功识别了手势，也就独吞了事件，不会再传递给YellowView。因此只打印了手势识别器成功识别手势后的action调用。</p><p><strong>delaysTouchesEnded</strong></p><p>默认为YES。当手势识别失败时，若此时触摸已经结束，会延迟一小段时间（0.15s）再调用响应者的 touchesEnded:withEvent:；若设置成NO，则在手势识别失败时会立即通知Application发送状态为end的touch事件给hit-tested view以调用 touchesEnded:withEvent: 结束事件响应。</p><blockquote><p>总结：手势识别器比响应链具有更高的事件响应优先级。</p></blockquote><p><strong>大师兄—UIControl</strong></p><p>UIControl是系统提供的能够以target-action模式处理触摸事件的控件，iOS中UIButton、UISegmentedControl、UISwitch等控件都是UIControl的子类。当UIControl跟踪到触摸事件时，会向其上添加的target发送事件以执行action。值得注意的是，UIConotrol是UIView的子类，因此本身也具备UIResponder应有的身份。</p><p>关于UIControl，此处介绍两点：</p><ol><li>target-action执行时机及过程</li><li>触摸事件优先级</li></ol><p><strong>target-action</strong></p><ul><li>target：处理交互事件的对象</li><li>action：处理交互事件的方式</li></ul><p>UIControl作为能够响应事件的控件，必然也需要待事件交互符合条件时才去响应，因此也会跟踪事件发生的过程。不同于UIResponder以及UIGestureRecognizer通过 touches 系列方法跟踪，UIControl有其独特的跟踪方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)endTrackingWithTouch:(nullable UITouch *)touch withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)cancelTrackingWithEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure><p>乍一看，这4个方法和UIResponder的那4个方法几乎吻合，只不过UIControl只能接收单点触控，因此接收的参数是单个UITouch对象。这几个方法的职能也和UIResponder一致，用来跟踪触摸的开始、滑动、结束、取消。不过，UIControl本身也是UIResponder，因此同样有 touches 系列的4个方法。事实上，UIControl的 Tracking 系列方法是在 touch 系列方法内部调用的。比如 beginTrackingWithTouch 是在 touchesBegan 方法内部调用的， 因此它虽然也是UIResponder，但 touches 系列方法的默认实现和UIResponder本类还是有区别的。</p><p>当UIControl跟踪事件的过程中，识别出事件交互符合响应条件，就会触发target-action进行响应。UIControl控件通过 addTarget:action:forControlEvents: 添加事件处理的target和action，当事件发生时，UIControl通知target执行对应的action。说是“通知”其实很笼统，事实上这里有个action传递的过程。当UIControl监听到需要处理的交互事件时，会调用 sendAction:to:forEvent: 将target、action以及event对象发送给全局应用，Application对象再通过 sendAction:to:from:forEvent: 向target发送action。</p><img src="/2023/03/22/iOS-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE/640-20230214153022736.jpeg" class="" title="图片"><p>因此，可以通过重写UIControl的 sendAction:to:forEvent: 或 sendAction:to:from:forEvent: 自定义事件执行的target及action。</p><p>另外，若不指定target，即 addTarget:action:forControlEvents: 时target传空，那么当事件发生时，Application会在响应链上从上往下寻找能响应action的对象。官方说明如下：</p><blockquote><p>If you specify nil for the target object, the control searches the responder chain for an object that defines the specified action method.</p></blockquote><p><strong>触摸事件优先级</strong></p><p>当原本关系已经错综复杂的UIGestureRecognizer和UIResponder之间又冒出一个UIControl，又会摩擦出什么样的火花呢？</p><blockquote><p>In iOS 6.0 and later, default control actions prevent overlapping gesture recognizer behavior. For example, the default action for a button is a single tap. If you have a single tap gesture recognizer attached to a button’s parent view, and the user taps the button, then the button’s action method receives the touch event instead of the gesture recognizer.This applies only to gesture recognition that overlaps the default action for a control, which includes:</p><p>A single finger single tap on a UIButton, UISwitch, UIStepper, UISegmentedControl, and UIPageControl.</p><p>A single finger swipe on the knob of a UISlider, in a direction parallel to the slider.</p><p>A single finger pan gesture on the knob of a UISwitch, in a direction parallel to the switch.</p></blockquote><p>简单理解：UIControl会阻止父视图上的手势识别器行为，也就是UIControl处理事件的优先级比UIGestureRecognizer高，但前提是相比于父视图上的手势识别器。</p><p>![图片](data:image/svg+xml,%3C%3Fxml version=’1.0’ encoding=’UTF-8’%3F%3E%3Csvg width=’1px’ height=’1px’ viewBox=’0 0 1 1’ version=’1.1’ xmlns=’<a href="http://www.w3.org/2000/svg&#39;">http://www.w3.org/2000/svg&#39;</a> xmlns:xlink=’<a href="http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke=’none’ stroke-width=’1’ fill=’none’ fill-rule=’evenodd’ fill-opacity=’0’%3E%3Cg transform=’translate(-249.000000, -126.000000)’ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p><p>UIControl测试场景</p><ul><li>预置场景：在BlueView上添加一个button，同时给button添加一个target-action事件。</li></ul><p>示例一：在BlueView上添加点击手势识别器</p><p>示例二：在button上添加手势识别器</p><ul><li>操作方式：单击button</li><li>测试结果：示例一中，button的target-action响应了单击事件；示例二中，BlueView上的手势识别器响应了事件。过程日志打印如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;示例一</span><br><span class="line">-[CLTapGestureRecognizer touchesBegan:withEvent:]</span><br><span class="line">-[CLButton touchesBegan:withEvent:]</span><br><span class="line">-[CLButton beginTrackingWithTouch:withEvent:]</span><br><span class="line">-[CLTapGestureRecognizer touchesEnded:withEvent:] after called state &#x3D; 5</span><br><span class="line">-[CLButton touchesEnded:withEvent:]</span><br><span class="line">-[CLButton endTrackingWithTouch:withEvent:]</span><br><span class="line">按钮点击</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;示例二</span><br><span class="line">-[CLTapGestureRecognizer touchesBegan:withEvent:]</span><br><span class="line">-[CLButton touchesBegan:withEvent:]</span><br><span class="line">-[CLButton beginTrackingWithTouch:withEvent:]</span><br><span class="line">-[CLTapGestureRecognizer touchesEnded:withEvent:] after called state &#x3D; 3</span><br><span class="line">手势触发</span><br><span class="line">-[CLButton touchesCancelled:withEvent:]</span><br><span class="line">-[CLButton cancelTrackingWithEvent:]</span><br></pre></td></tr></table></figure><p>原因分析：点击button后，事件先传递给手势识别器，再传递给作为hit-tested view存在的button（UIControl本身也是UIResponder，这一过程和普通事件响应者无异）。示例一中，由于button阻止了父视图BlueView中的手势识别器的识别，导致手势识别器识别失败（状态为failed 枚举值为5），button完全接手了事件的响应权，事件最终由button响应；示例二中，button未阻止其本身绑定的手势识别器的识别，因此手势识别器先识别手势并识别成功（状态为ended 枚举值为3），而后通知Application取消响应链对事件的响应，因为 touchesCancelled 被调用，同时 cancelTrackingWithEvent 跟着调用，因此button的target-action得不到执行。</p><p>其他：经测试，若示例一中的手势识别器设置 cancelsTouchesInView 为NO，手势识别器和button都能响应事件。也就是说这种情况下，button不会阻止父视图中手势识别器的识别。</p><p>结论：UIControl比其父视图上的手势识别器具有更高的事件响应优先级。</p><blockquote><p>TODO:</p><p>上述过程中，手势识别器在执行touchesEnded时是根据什么将状态置为ended还是failed的？即根据什么判断应当识别成功还是识别失败？</p></blockquote><p><strong>纠正</strong></p><p>以上所述UIControl的响应优先级比手势识别器高的说法不准确，准确地说只适用于系统提供的有默认action操作的UIControl，例如UIbutton、UISwitch等的单击，而对于自定义的UIControl，经验证，响应优先级比手势识别器低。读者可自行验证，感谢 @闫仕伟 同学的纠正。</p><p><strong>拨云见日</strong></p><p>现在，把胶卷回放到本章节开头的场景。给你一杯咖啡的时间看看能不能解释得通那几个现象了，不说了泡咖啡去了…</p><p>我肥来了！</p><p>先看<strong>现象二</strong>，短按 cell无法响应，日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[GLTableView touchesBegan:withEvent:]</span><br><span class="line">backview taped</span><br><span class="line">-[GLTableView touchesCancelled:withEvent:]</span><br></pre></td></tr></table></figure><p>这个日志和上面离散型手势Demo中打印的日志完全一致。短按后，BackView上的手势识别器先接收到事件，之后事件传递给hit-tested view，作为响应者链中一员的GLTableView的 touchesBegan:withEvent: 被调用；而后手势识别器成功识别了点击事件，action执行，同时通知Application取消响应链中的事件响应，GLTableView的 touchesCancelled:withEvent: 被调用。</p><p>因为事件被取消了，因此Cell无法响应点击。</p><p>再看<strong>现象三</strong>，长按cell能够响应，日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[GLTableView touchesBegan:withEvent:]</span><br><span class="line">-[GLTableView touchesEnded:withEvent:]</span><br><span class="line">cell selected!</span><br></pre></td></tr></table></figure><p>长按的过程中，一开始事件同样被传递给手势识别器和hit-tested view，作为响应链中一员的GLTableView的 touchesBegan:withEvent: 被调用；此后在长按的过程中，手势识别器一直在识别手势，直到一定时间后手势识别失败，才将事件的响应权完全交给响应链。当触摸结束的时候，GLTableView的 touchesEnded:withEvent: 被调用，同时Cell响应了点击。</p><p>OK，现在回到<strong>现象一</strong>。按照之前的分析，快速点击cell，讲道理不管是表现还是日志都应该和<strong>现象二</strong>一致才对。然而日志仅仅打印了手势识别器的action执行结果。分析一下原因：GLTableView的 touchesBegan 没有调用，说明事件没有传递给hit-tested view。那只有一种可能，就是事件被某个手势识别器拦截了。目前已知的手势识别器拦截事件的方法，就是设置 delaysTouchesBegan 为YES，在手势识别器未识别完成的情况下不会将事件传递给hit-tested view。然后事实上并没有进行这样的设置，那么问题可能出在别的手势识别器上。</p><p>Window的 sendEvent: 打个断点查看event上的touch对象维护的手势识别器数组：</p><p>![图片](data:image/svg+xml,%3C%3Fxml version=’1.0’ encoding=’UTF-8’%3F%3E%3Csvg width=’1px’ height=’1px’ viewBox=’0 0 1 1’ version=’1.1’ xmlns=’<a href="http://www.w3.org/2000/svg&#39;">http://www.w3.org/2000/svg&#39;</a> xmlns:xlink=’<a href="http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke=’none’ stroke-width=’1’ fill=’none’ fill-rule=’evenodd’ fill-opacity=’0’%3E%3Cg transform=’translate(-249.000000, -126.000000)’ fill=’%23FFFFFF’%3E%3Crect x=’249’ y=’126’ width=’1’ height=’1’%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p><p>获可疑对象：UIScrollViewDelayedTouchesBeganGestureRecognizer ，光看名字就觉得这货脱不了干系。从类名上猜测，这个手势识别器大概会延迟事件向响应链的传递。github上找到了该私有类的头文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface UIScrollViewDelayedTouchesBeganGestureRecognizer : UIGestureRecognizer &#123;</span><br><span class="line">    UIView&lt;UIScrollViewDelayedTouchesBeganGestureRecognizerClient&gt; * _client;</span><br><span class="line">    struct CGPoint &#123; </span><br><span class="line">        float x; </span><br><span class="line">        float y; </span><br><span class="line">    &#125;  _startSceneReferenceLocation;</span><br><span class="line">    UIDelayedAction * _touchDelay;</span><br><span class="line">&#125;</span><br><span class="line">- (void).cxx_destruct;</span><br><span class="line">- (id)_clientView;</span><br><span class="line">- (void)_resetGestureRecognizer;</span><br><span class="line">- (void)clearTimer;</span><br><span class="line">- (void)dealloc;</span><br><span class="line">- (void)sendDelayedTouches;</span><br><span class="line">- (void)sendTouchesShouldBeginForDelayedTouches:(id)arg1;</span><br><span class="line">- (void)sendTouchesShouldBeginForTouches:(id)arg1 withEvent:(id)arg2;</span><br><span class="line">- (void)touchesBegan:(id)arg1 withEvent:(id)arg2;</span><br><span class="line">- (void)touchesCancelled:(id)arg1 withEvent:(id)arg2;</span><br><span class="line">- (void)touchesEnded:(id)arg1 withEvent:(id)arg2;</span><br><span class="line">- (void)touchesMoved:(id)arg1 withEvent:(id)arg2;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>有一个_touchDelay变量，大概是用来控制延迟事件发送的。另外，方法列表里有个 sendTouchesShouldBeginForDelayedTouches: 方法，听名字似乎是在一段时间延迟后向响应链传递事件用的。为一探究竟，我创建了一个类hook了这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;TouchEventHook.m</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    Class aClass &#x3D; objc_getClass(&quot;UIScrollViewDelayedTouchesBeganGestureRecognizer&quot;);</span><br><span class="line">    SEL sel &#x3D; @selector(hook_sendTouchesShouldBeginForDelayedTouches:);</span><br><span class="line">    Method method &#x3D; class_getClassMethod([self class], sel);</span><br><span class="line">    class_addMethod(aClass, sel, class_getMethodImplementation([self class], sel), method_getTypeEncoding(method));</span><br><span class="line">    exchangeMethod(aClass, @selector(sendTouchesShouldBeginForDelayedTouches:), sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)hook_sendTouchesShouldBeginForDelayedTouches:(id)arg1&#123;</span><br><span class="line">    [self hook_sendTouchesShouldBeginForDelayedTouches:arg1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exchangeMethod(Class aClass, SEL oldSEL, SEL newSEL) &#123;</span><br><span class="line">    Method oldMethod &#x3D; class_getInstanceMethod(aClass, oldSEL);</span><br><span class="line">    Method newMethod &#x3D; class_getInstanceMethod(aClass, newSEL);</span><br><span class="line">    method_exchangeImplementations(oldMethod, newMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点看一下点击cell后 hook_sendTouchesShouldBeginForDelayedTouches: 调用时的信息：</p><img src="/2023/03/22/iOS-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE/640.jpeg" class="" title="图片"><p>可以看到这个手势识别器的 _touchDelay 变量中，保存了一个计时器，以及一个长得很像延迟时间间隔的变量m_delay。现在，可以推测该手势识别器截断了事件并延迟0.15s才发送给hit-tested view。为验证猜测，我分别在Window的 sendEvent: ，hook_sendTouchesShouldBeginForDelayedTouches: 以及TableView的 touchesBegan: 中打印时间戳，若猜测成立，则应当前两者的调用时间相差0.15s左右，后两者的调用时间很接近。短按Cell后打印结果如下（不能快速点击，否则还没过延迟时间触摸就结束了，无法验证猜测）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-[GLWindow sendEvent:]调用时间戳 :</span><br><span class="line">525252194779.07ms</span><br><span class="line">-[TouchEventHook hook_sendTouchesShouldBeginForDelayedTouches:]调用时间戳 :</span><br><span class="line">525252194930.91ms</span><br><span class="line">-[TouchEventHook hook_sendTouchesShouldBeginForDelayedTouches:]调用时间戳 :</span><br><span class="line">525252194931.24ms</span><br><span class="line">-[GLTableView touchesBegan:withEvent:]调用时间戳 :</span><br><span class="line">525252194931.76ms</span><br></pre></td></tr></table></figure><p>因为有两个 UIScrollViewDelayedTouchesBeganGestureRecognizer，所以 hook_sendTouchesShouldBeginForDelayedTouches 调了两次，两次的时间很接近。可以看到，结果完全符合猜测。</p><p>这样就都解释得通了。<strong>现象一</strong>由于点击后，UIScrollViewDelayedTouchesBeganGestureRecognizer 拦截了事件并延迟了0.15s发送。又因为点击时间比0.15s短，在发送事件前触摸就结束了，因此事件没有传递到hit-tested view，导致TableView的 touchBegin 没有调用。而<strong>现象二</strong>，由于短按的时间超过了0.15s，手势识别器拦截了事件并经过0.15s后，触摸还未结束，于是将事件传递给了hit-tested view，使得TableView接收到了事件。因此现象二的日志虽然和离散型手势Demo中的日志一致，但实际上前者的hit-tested view是在触摸后延迟了约0.15s左右才接收到触摸事件的。</p><p>至于<strong>现象四</strong> ，你现在应该已经觉得理所当然了才对。</p><p><strong>总结</strong></p><ul><li>触摸发生时，系统内核生成触摸事件，先由IOKit处理封装成IOHIDEvent对象，通过IPC传递给系统进程SpringBoard，而后再传递给前台APP处理。</li><li>事件传递到APP内部时被封装成开发者可见的UIEvent对象，先经过hit-testing寻找第一响应者，而后由Window对象将事件传递给hit-tested view，并开始在响应链上的传递。</li><li>UIRespnder、UIGestureRecognizer、UIControl，笼统地讲，事件响应优先级依次递增。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> iOS面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS组件化方案(2)</title>
      <link href="2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part2/"/>
      <url>2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part2/</url>
      
        <content type="html"><![CDATA[<h3 id="组件化通讯方案"><a href="#组件化通讯方案" class="headerlink" title="组件化通讯方案"></a>组件化通讯方案</h3><p>目前主流的主要有以下三种方式：</p><ul><li>1、<code>URL</code>路由</li><li>2、<code>target-action</code></li><li>3、<code>protocol</code>匹配</li></ul><a id="more"></a><h3 id="URL路由"><a href="#URL路由" class="headerlink" title="URL路由"></a>URL路由</h3><p>目前iOS上大部分路由工具都是基于URL匹配的，或者是根据命名约定，用runtime方法进行动态调用</p><p>这些动态化的方案的优点是实现简单，缺点是需要维护字符串表，或者依赖于命名约定，无法在编译时暴露出所有问题，需要在运行时才能发现错误。</p><p>URL路由方式主要是以蘑菇街为代表的的<a href="https://links.jianshu.com/go?to=https://github.com/meili/MGJRouter">MGJRouter</a></p><p>其实现思路是：</p><ul><li>App启动时实例化各组件模块，然后这些组件向<code>ModuleManager</code>注册<code>Url</code>，有些时候不需要实例化，使用class注册</li><li>当组件A需要调用组件B时，向<code>ModuleManager</code>传递URL，参数跟随URL以GET方式传递，类似openURL。然后由ModuleManager负责调度组件B，最后完成任务。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、注册某个URL</span><br><span class="line">MGJRouter.registerURLPattern(&quot;app:&#x2F;&#x2F;home&quot;) &#123; (info) in</span><br><span class="line">    print(&quot;info: \(info)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、调用路由</span><br><span class="line">MGJRouter.openURL(&quot;app:&#x2F;&#x2F;home&quot;)</span><br></pre></td></tr></table></figure><h4 id="URL-路由的优点"><a href="#URL-路由的优点" class="headerlink" title="URL 路由的优点"></a>URL 路由的优点</h4><ul><li>极高的动态性，适合经常开展运营活动的app，例如电商</li><li>方便地统一管理多平台的路由规则</li><li>易于适配URL Scheme</li></ul><h4 id="URl-路由的缺点"><a href="#URl-路由的缺点" class="headerlink" title="URl 路由的缺点"></a>URl 路由的缺点</h4><ul><li>传参方式有限，并且无法利用编译器进行参数类型检查，因此所有的参数都是通过字符串转换而来</li><li>只适用于界面模块，不适用于通用模块</li><li>参数的格式不明确，是个灵活的 dictionary，也需要有个地方可以查参数格式。</li><li>不支持storyboard</li><li>依赖于字符串硬编码，难以管理，蘑菇街做了个后台专门管理。</li><li>无法保证所使用的的模块一定存在</li><li>解耦能力有限，url 的”注册”、”实现”、”使用”必须用相同的字符规则，一旦任何一方做出修改都会导致其他方的代码失效，并且重构难度大</li></ul><p>除了<code>CTMediator</code>，还有以下这些三方框架</p><ul><li><a href="https://links.jianshu.com/go?to=https://github.com/clayallsopp/routable-ios">routable-ios</a></li><li><a href="https://links.jianshu.com/go?to=https://github.com/joeldev/JLRoutes">JLRoutes</a></li><li><a href="https://links.jianshu.com/go?to=https://github.com/lightory/HHRouter">HHRouter</a></li></ul><h3 id="target-action"><a href="#target-action" class="headerlink" title="target-action"></a>target-action</h3><p>这个方案是基于OC的runtime、category特性动态获取模块，例如通过<code>NSClassFromString</code>获取类并创建实例，通过<code>performSelector + NSInvocation</code>动态调用方法</p><p>其主要的代表框架是<a href="https://links.jianshu.com/go?to=https://github.com/casatwy/CTMediator">casatwy的CTMediator</a></p><p>其实现思路是：</p><ul><li>1、利用分类为路由添加新接口，在接口中通过字符串获取对应的类</li><li>2、通过runtime创建实例，动态调用实例的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;******* 1、分类定义新接口</span><br><span class="line">extension CTMediator&#123;</span><br><span class="line">    @objc func A_showHome()-&gt;UIViewController?&#123;</span><br><span class="line">        let params &#x3D; [</span><br><span class="line">            kCTMediatorParamsKeySwiftTargetModuleName: &quot;CJLBase_Example&quot;</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        if let vc &#x3D; self.performTarget(&quot;A&quot;, action: &quot;Extension_HomeViewController&quot;, params: params, shouldCacheTarget: false) as? UIViewController&#123;</span><br><span class="line">            return vc</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******* 2、模块提供者提供target-action的调用方式（对外需要加上public关键字）</span><br><span class="line">class Target_A: NSObject &#123;</span><br><span class="line">    </span><br><span class="line">    @objc func Action_Extension_HomeViewController(_ params: [String: Any])-&gt;UIViewController&#123;</span><br><span class="line">         </span><br><span class="line">        let home &#x3D; HomeViewController()</span><br><span class="line">        return home</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******* 3、使用</span><br><span class="line">if let vc &#x3D; CTMediator.sharedInstance().A_showHome() &#123;</span><br><span class="line">            self.navigationController?.pushViewController(vc, animated: true)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>其模块间的引用关系如下图所示</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part2/d74f03f0de964014923b74a6d4b9c5d3.png" class="" title="image.png"><p><strong>优点</strong></p><p>**<br>**</p><ul><li>利用 <code>分类</code> 可以明确声明接口，进行编译检查</li><li>实现方式<code>轻量</code></li></ul><p>**<br>**</p><p><strong>缺点</strong></p><p>**<br>**</p><ul><li>需要在<code>mediator</code> 和 <code>target</code>中重新添加每一个接口，模块化时代码较为繁琐</li><li>在 <code>category</code> 中仍然引入了<code>字符串硬编码</code>，内部使用字典传参，一定程度上也存在和 URL 路由相同的问题</li><li>无法保证使用的模块一定存在，target在修改后，使用者只能在运行时才能发现错误</li><li>可能会创建过多的 target 类</li></ul><p>**<br>**</p><p><strong>CTMediator源码分析</strong></p><p>**<br>**</p><ul><li>通过分类中调用的<code>performTarget</code>来到<code>CTMediator</code>中的具体实现，即<code>performTarget:action:params:shouldCacheTarget:</code>，主要是通过传入的name，找到对应的<code>target</code> 和 <code>action</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</span><br><span class="line">&#123;</span><br><span class="line">    if (targetName &#x3D;&#x3D; nil || actionName &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在swift中使用时，需要传入对应项目的target名称，否则会找不到视图控制器</span><br><span class="line">    NSString *swiftModuleName &#x3D; params[kCTMediatorParamsKeySwiftTargetModuleName];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; generate target 生成target</span><br><span class="line">    NSString *targetClassString &#x3D; nil;</span><br><span class="line">    if (swiftModuleName.length &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;swift中target文件名拼接</span><br><span class="line">        targetClassString &#x3D; [NSString stringWithFormat:@&quot;%@.Target_%@&quot;, swiftModuleName, targetName];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;OC中target文件名拼接</span><br><span class="line">        targetClassString &#x3D; [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;缓存中查找target</span><br><span class="line">    NSObject *target &#x3D; [self safeFetchCachedTarget:targetClassString];</span><br><span class="line">    &#x2F;&#x2F;缓存中没有target</span><br><span class="line">    if (target &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        &#x2F;&#x2F;通过字符串获取对应的类</span><br><span class="line">        Class targetClass &#x3D; NSClassFromString(targetClassString);</span><br><span class="line">        &#x2F;&#x2F;创建实例</span><br><span class="line">        target &#x3D; [[targetClass alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; generate action 生成action方法名称</span><br><span class="line">    NSString *actionString &#x3D; [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];</span><br><span class="line">    &#x2F;&#x2F;通过方法名字符串获取对应的sel</span><br><span class="line">    SEL action &#x3D; NSSelectorFromString(actionString);</span><br><span class="line">    </span><br><span class="line">    if (target &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的</span><br><span class="line">        [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;是否需要缓存</span><br><span class="line">    if (shouldCacheTarget) &#123;</span><br><span class="line">        [self safeSetCachedTarget:target key:targetClassString];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;是否响应sel</span><br><span class="line">    if ([target respondsToSelector:action]) &#123;</span><br><span class="line">        &#x2F;&#x2F;动态调用方法</span><br><span class="line">        return [self safePerformAction:action target:target params:params];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理</span><br><span class="line">        SEL action &#x3D; NSSelectorFromString(@&quot;notFound:&quot;);</span><br><span class="line">        if ([target respondsToSelector:action]) &#123;</span><br><span class="line">            return [self safePerformAction:action target:target params:params];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。</span><br><span class="line">            [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [self.cachedTarget removeObjectForKey:targetClassString];</span><br><span class="line">            &#125;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>safePerformAction:target:params:</code>实现，主要是通过<code>invocation</code>进行<code>参数传递+消息转发</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (id)safePerformAction:(SEL)action target:(NSObject *)target params:(NSDictionary *)params</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取方法签名</span><br><span class="line">    NSMethodSignature* methodSig &#x3D; [target methodSignatureForSelector:action];</span><br><span class="line">    if(methodSig &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取方法签名中的返回类型，然后根据返回值完成参数传递</span><br><span class="line">    const char* retType &#x3D; [methodSig methodReturnType];</span><br><span class="line">    &#x2F;&#x2F;void类型</span><br><span class="line">    if (strcmp(retType, @encode(void)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...省略其他类型的判断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="protocol-class"><a href="#protocol-class" class="headerlink" title="protocol class"></a>protocol class</h3><p>protocol匹配的<code>实现思路</code>是：</p><ul><li>1、将<code>protocol</code>和对应的<code>类</code>进行<code>字典匹配</code></li><li>2、通过用<code>protocol</code>获取<code>class</code>，在<code>动态创建实例</code></li></ul><p>protocol比较典型的三方框架就是<a href="https://links.jianshu.com/go?to=https://github.com/alibaba/BeeHive">阿里的BeeHive</a>。<code>BeeHive</code>借鉴了Spring Service、Apache DSO的架构理念，<code>采用AOP+扩展App生命周期API</code>形式，将<code>业务功能</code>、<code>基础功能</code>模块以模块方式以解决大型应用中的复杂问题，并让<code>模块之间以Service形式调用</code>，将复杂问题切分，以AOP方式模块化服务。</p><p>**<br>**</p><h4 id="BeeHive-核心思想"><a href="#BeeHive-核心思想" class="headerlink" title="BeeHive 核心思想"></a>BeeHive 核心思想</h4><ul><li>1、各个模块间调用从直接调用对应模块，变成调用<code>Service</code>的形式，避免了直接依赖。</li><li>2、App生命周期的分发，将耦合在<code>AppDelegate</code>中逻辑拆分，每个模块以微应用的形式独立存在。</li></ul><p>示例如下（本想用swift写的，但是有点问题，暂时用OC写）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;******** 1、注册</span><br><span class="line">[[BeeHive shareInstance] registerService:@protocol(HomeServiceProtocol) service:[BHViewController class]];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******** 2、使用</span><br><span class="line">#import &quot;BHService.h&quot;</span><br><span class="line"></span><br><span class="line">id&lt; HomeServiceProtocol &gt; homeVc &#x3D; [[BeeHive shareInstance] createService:@protocol(HomeServiceProtocol)];</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><p>**<br>**</p><ul><li>1、利用接口调用，实现了参数传递时的类型安全</li><li>2、直接使用模块的protocol接口，无需再重复封装</li></ul><p><strong>缺点</strong></p><p>**<br>**</p><ul><li>1、用框架来创建所有对象，创建方式不同，即不支持外部传入参数</li><li>2、用<code>OC runtime</code>创建对象，不支持swift</li><li>3、只做了<code>protocol</code> 和 <code>class</code> 的匹配，不支持更复杂的创建方式 和依赖注入</li><li>4、无法保证所使用的protocol 一定存在对应的模块，也无法直接判断某个protocol是否能用于获取模块</li></ul><p>除了<code>BeeHive</code>，还有<a href="https://links.jianshu.com/go?to=https://github.com/Swinject/Swinject">Swinject</a></p><h3 id="BeeHive-模块注册"><a href="#BeeHive-模块注册" class="headerlink" title="BeeHive 模块注册"></a>BeeHive 模块注册</h3><p>在<code>BeeHive</code>主要是通过<code>BHModuleManager</code>来管理各个模块的。<code>BHModuleManager</code>中只会管理已经被注册过的模块。</p><p>BeeHive提供了三种不同的调用形式，<code>静态plist</code>，<code>动态注册</code>，<code>annotation</code>。Module、Service之间没有关联，每个业务模块可以单独实现Module或者Service的功能。</p><h4 id="1、-Annotation方式注册"><a href="#1、-Annotation方式注册" class="headerlink" title="1、 Annotation方式注册"></a>1、 Annotation方式注册</h4><p>这种方式主要是通过<code>BeeHiveMod</code>宏进行<code>Annotation</code>标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;***** 使用</span><br><span class="line">BeeHiveMod(ShopModule)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;***** BeeHiveMod的宏定义</span><br><span class="line">#define BeeHiveMod(name) \</span><br><span class="line">class BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) &#x3D; &quot;&quot;#name&quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;***** BeeHiveDATA的宏定义 </span><br><span class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot; &quot;)))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;*****  全部转换出来后为下面的格式</span><br><span class="line">char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot; &quot;))) &#x3D; &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><p>这里针对<code>__attribute</code>需要说明以下几点</p><ul><li>第一个参数<code>used</code>：用来修饰函数，被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器下会去掉没有被引用的段。</li><li>通过使用<code>__attribute__((section(&quot;name&quot;)))</code>来指明哪个段。数据则用<code>__attribute__((used))</code>来标记，防止链接器会优化删除未被使用的段，然后将模块注入到<code>__DATA</code>中</li></ul><p>此时Module已经被存储到Mach-O文件的特殊段中，那么如何取呢？</p><ul><li>进入<code>BHReadConfiguration</code>方法，主要是通过<code>Mach-O</code>找到存储的数据段，取出放入数组中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *configs &#x3D; [NSMutableArray array];</span><br><span class="line">    unsigned long size &#x3D; 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">    &#x2F;&#x2F; 找到之前存储的数据段(Module找BeehiveMods段 和 Service找BeehiveServices段)的一片内存</span><br><span class="line">    uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">    const struct mach_header_64 *mhp64 &#x3D; (const struct mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    unsigned long counter &#x3D; size&#x2F;sizeof(void*);</span><br><span class="line">    &#x2F;&#x2F; 把特殊段里面的数据都转换成字符串存入数组中</span><br><span class="line">    for(int idx &#x3D; 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        char *string &#x3D; (char*)memory[idx];</span><br><span class="line">        NSString *str &#x3D; [NSString stringWithUTF8String:string];</span><br><span class="line">        if(!str)continue;</span><br><span class="line">        </span><br><span class="line">        BHLog(@&quot;config &#x3D; %@&quot;, str);</span><br><span class="line">        if(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return configs; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、读取本地Pilst文件"><a href="#2、读取本地Pilst文件" class="headerlink" title="2、读取本地Pilst文件"></a>2、读取本地Pilst文件</h4><ul><li>首先，需要设置好路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BHContext shareInstance].moduleConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BeeHive&quot;;&#x2F;&#x2F;可选，默认为BeeHive.bundle&#x2F;BeeHive.plist</span><br></pre></td></tr></table></figure><p>创建plist文件，<code>Plist</code>文件的格式也是数组中包含多个字典。字典里面有两个Key，一个是<code>@&quot;moduleLevel&quot;</code>，另一个是<code>@&quot;moduleClass&quot;</code>。注意<code>根</code>的数组的名字叫<code>@“moduleClasses”</code>。</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part2/00203bd5fb6f4b58ae880570cd684117.png" class="" title="image.png"><ul><li>进入<code>loadLocalModules</code>方法，主要是从<code>Plist</code>里面取出数组，然后把数组加入到<code>BHModuleInfos</code>数组里面。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化context时，加载Modules和Services</span><br><span class="line">-(void)setContext:(BHContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    _context &#x3D; context;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [self loadStaticServices];</span><br><span class="line">        [self loadStaticModules];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">&#x2F;&#x2F;加载modules</span><br><span class="line">- (void)loadStaticModules</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 读取本地plist文件里面的Module，并注册到BHModuleManager的BHModuleInfos数组中</span><br><span class="line">    [[BHModuleManager sharedManager] loadLocalModules];</span><br><span class="line">    &#x2F;&#x2F;注册所有modules，在内部根据优先级进行排序</span><br><span class="line">    [[BHModuleManager sharedManager] registedAllModules];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)loadLocalModules</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;plist文件路径</span><br><span class="line">    NSString *plistPath &#x3D; [[NSBundle mainBundle] pathForResource:[BHContext shareInstance].moduleConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    &#x2F;&#x2F;判断文件是否存在</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;读取整个文件[@&quot;moduleClasses&quot; : 数组]</span><br><span class="line">    NSDictionary *moduleList &#x3D; [[NSDictionary alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    &#x2F;&#x2F;通过moduleClasses key读取 数组 [[@&quot;moduleClass&quot;:&quot;aaa&quot;, @&quot;moduleLevel&quot;: @&quot;bbb&quot;], [...]]</span><br><span class="line">    NSArray&lt;NSDictionary *&gt; *modulesArray &#x3D; [moduleList objectForKey:kModuleArrayKey];</span><br><span class="line">    NSMutableDictionary&lt;NSString *, NSNumber *&gt; *moduleInfoByClass &#x3D; @&#123;&#125;.mutableCopy;</span><br><span class="line">    &#x2F;&#x2F;遍历数组</span><br><span class="line">    [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        [moduleInfoByClass setObject:@1 forKey:[obj objectForKey:kModuleInfoNameKey]];</span><br><span class="line">    &#125;];</span><br><span class="line">    [modulesArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if (!moduleInfoByClass[[obj objectForKey:kModuleInfoNameKey]]) &#123;</span><br><span class="line">            &#x2F;&#x2F;存储到 BHModuleInfos 中</span><br><span class="line">            [self.BHModuleInfos addObject:obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、load方法注册"><a href="#3、load方法注册" class="headerlink" title="3、load方法注册"></a>3、load方法注册</h4><p>该方法<code>注册Module</code>就是在<code>Load</code>方法里面注册Module的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    [BeeHive registerDynamicModule:[self class]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>registerDynamicModule</code>实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] registerDynamicModule:moduleClass];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [self registerDynamicModule:moduleClass shouldTriggerInitEvent:NO];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">       shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent</span><br><span class="line">&#123;</span><br><span class="line">    [self addModuleFromObject:moduleClass shouldTriggerInitEvent:shouldTriggerInitEvent];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其底层还是同第一种方式一样，最终会走到<code>addModuleFromObject:shouldTriggerInitEvent:</code>方法中</p><ul><li>load方法，还可以使用<code>BH_EXPORT_MODULE</code>宏代替</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define BH_EXPORT_MODULE(isAsync) \</span><br><span class="line">+ (void)load &#123; [BeeHive registerDynamicModule:[self class]]; &#125; \</span><br><span class="line">-(BOOL)async &#123; return [[NSString stringWithUTF8String:#isAsync] boolValue];&#125;</span><br></pre></td></tr></table></figure><p><code>BH_EXPORT_MODULE</code>宏里面可以传入一个参数，代表<code>是否异步加载Module模块</code>，如果是<code>YES</code>就是<code>异步加载</code>，如果是<code>NO</code>就是<code>同步加载</code>。</p><h3 id="2、BeeHive-模块事件"><a href="#2、BeeHive-模块事件" class="headerlink" title="2、BeeHive 模块事件"></a>2、BeeHive 模块事件</h3><p>BeeHive会给每个模块提供生命周期事件，用于与BeeHive宿主环境进行必要信息交互，感知模块生命周期的变化。</p><p>BeeHive各个模块会收到一些事件。在<code>BHModuleManager</code>中，所有的事件被定义成了<code>BHModuleEventType</code>枚举。如下所示，其中有2个事件很特殊，一个是<code>BHMInitEvent</code>，一个是<code>BHMTearDownEvent</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, BHModuleEventType)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;设置Module模块</span><br><span class="line">    BHMSetupEvent &#x3D; 0,</span><br><span class="line">    &#x2F;&#x2F;用于初始化Module模块，例如环境判断，根据不同环境进行不同初始化</span><br><span class="line">    BHMInitEvent,</span><br><span class="line">    &#x2F;&#x2F;用于拆除Module模块</span><br><span class="line">    BHMTearDownEvent,</span><br><span class="line">    BHMSplashEvent,</span><br><span class="line">    BHMQuickActionEvent,</span><br><span class="line">    BHMWillResignActiveEvent,</span><br><span class="line">    BHMDidEnterBackgroundEvent,</span><br><span class="line">    BHMWillEnterForegroundEvent,</span><br><span class="line">    BHMDidBecomeActiveEvent,</span><br><span class="line">    BHMWillTerminateEvent,</span><br><span class="line">    BHMUnmountEvent,</span><br><span class="line">    BHMOpenURLEvent,</span><br><span class="line">    BHMDidReceiveMemoryWarningEvent,</span><br><span class="line">    BHMDidFailToRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidReceiveRemoteNotificationEvent,</span><br><span class="line">    BHMDidReceiveLocalNotificationEvent,</span><br><span class="line">    BHMWillPresentNotificationEvent,</span><br><span class="line">    BHMDidReceiveNotificationResponseEvent,</span><br><span class="line">    BHMWillContinueUserActivityEvent,</span><br><span class="line">    BHMContinueUserActivityEvent,</span><br><span class="line">    BHMDidFailToContinueUserActivityEvent,</span><br><span class="line">    BHMDidUpdateUserActivityEvent,</span><br><span class="line">    BHMHandleWatchKitExtensionRequestEvent,</span><br><span class="line">    BHMDidCustomEvent &#x3D; 1000</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要分为三种</p><ul><li>1、<code>系统事件</code>：主要是指<code>Application生命周期事件</code>!<img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part2/457cc2e7bd1345e58e5ee7aa63e94df5.png" class="" title="image.png"></li></ul><p>一般的做法是<code>AppDelegate</code>改为<code>继承自BHAppDelegate</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface TestAppDelegate : BHAppDelegate &lt;UIApplicationDelegate&gt;</span><br></pre></td></tr></table></figure><p>2、<code>应用事件</code>：官方给出的流程图，其中<code>modSetup</code>、<code>modInit</code>等，可以用于编码实现各插件模块的设置与初始化。</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part2/4dff469e37654d99b9c051fd7aafbad4.png" class="" title="image.png"><ul><li>3、<code>自定义事件</code></li></ul><p>以上所有的事件都可以通过调用<code>BHModuleManager</code>的<code>triggerEvent:</code>来处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">&#123;</span><br><span class="line">    [self triggerEvent:eventType withCustomParam:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">     withCustomParam:(NSDictionary *)customParam &#123;</span><br><span class="line">    [self handleModuleEvent:eventType forTarget:nil withCustomParam:customParam];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">#pragma mark - module protocol</span><br><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">          withCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    switch (eventType) &#123;</span><br><span class="line">            &#x2F;&#x2F;初始化事件</span><br><span class="line">        case BHMInitEvent:</span><br><span class="line">            &#x2F;&#x2F;special</span><br><span class="line">            [self handleModulesInitEventForTarget:nil withCustomParam :customParam];</span><br><span class="line">            break;</span><br><span class="line">            &#x2F;&#x2F;析构事件</span><br><span class="line">        case BHMTearDownEvent:</span><br><span class="line">            &#x2F;&#x2F;special</span><br><span class="line">            [self handleModulesTearDownEventForTarget:nil withCustomParam:customParam];</span><br><span class="line">            break;</span><br><span class="line">            &#x2F;&#x2F;其他3类事件</span><br><span class="line">        default: &#123;</span><br><span class="line">            NSString *selectorStr &#x3D; [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">            [self handleModuleEvent:eventType forTarget:nil withSeletorStr:selectorStr andCustomParam:customParam];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以发现，除去<code>BHMInitEvent</code>初始化事件和<code>BHMTearDownEvent</code>拆除Module事件这两个特殊事件以外，所有的事件都是调用的<code>handleModuleEvent:forTarget:withSeletorStr:andCustomParam:</code>方法，其内部实现主要是遍历 <code>moduleInstances</code> 实例数组，调用<code>performSelector:withObject:</code>方法实现对应方法调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">           withSeletorStr:(NSString *)selectorStr</span><br><span class="line">           andCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    BHContext *context &#x3D; [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam &#x3D; customParam;</span><br><span class="line">    context.customEvent &#x3D; eventType;</span><br><span class="line">    if (!selectorStr.length) &#123;</span><br><span class="line">        selectorStr &#x3D; [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    SEL seletor &#x3D; NSSelectorFromString(selectorStr);</span><br><span class="line">    if (!seletor) &#123;</span><br><span class="line">        selectorStr &#x3D; [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">        seletor &#x3D; NSSelectorFromString(selectorStr);</span><br><span class="line">    &#125;</span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances &#x3D; @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances &#x3D; [self.BHModulesByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;遍历 moduleInstances 实例数组，调用performSelector:withObject:方法实现对应方法调用</span><br><span class="line">    [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if ([moduleInstance respondsToSelector:seletor]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">            &#x2F;&#x2F;进行方法调用</span><br><span class="line">            [moduleInstance performSelector:seletor withObject:context];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">            </span><br><span class="line">            [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- %@&quot;, [moduleInstance class], NSStringFromSelector(seletor)]];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:这里所有的<code>Module</code>必须是遵循<code>BHModuleProtocol</code>的，否则无法接收到这些事件的消息。</p><h3 id="3、BeeHive模块调用"><a href="#3、BeeHive模块调用" class="headerlink" title="3、BeeHive模块调用"></a>3、BeeHive模块调用</h3><p>在BeeHive中是通过<code>BHServiceManager</code>来管理各个<code>Protocol</code>的。<code>BHServiceManager</code>中只会管理已经<code>被注册过的Protocol</code>。</p><p>注册<code>Protocol</code>的方式总共有三种，和注册<code>Module</code>是一样一一对应的</p><p>**<br>**</p><p><strong>1、Annotation方式注册</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;****** 1、通过BeeHiveService宏进行Annotation标记</span><br><span class="line">BeeHiveService(HomeServiceProtocol,BHViewController)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;****** 2、宏定义</span><br><span class="line">#define BeeHiveService(servicename,impl) \</span><br><span class="line">class BeeHive; char * k##servicename##_service BeeHiveDATA(BeehiveServices) &#x3D; &quot;&#123; \&quot;&quot;#servicename&quot;\&quot; : \&quot;&quot;#impl&quot;\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;****** 3、转换后的格式，也是将其存储到特殊的段</span><br><span class="line">char * kHomeServiceProtocol_service __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot; &quot;))) &#x3D; &quot;&#123; \&quot;&quot;&quot;HomeServiceProtocol&quot;&quot;\&quot; : \&quot;&quot;&quot;BHViewController&quot;&quot;\&quot;&#125;&quot;;</span><br></pre></td></tr></table></figure><p><strong>2、读取本地plist文件</strong></p><p>**<br>**</p><ul><li>首先同Module一样，需要先设置好路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BHContext shareInstance].serviceConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BHService&quot;;</span><br></pre></td></tr></table></figure><p>设置plist文件</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part2/4df6cb91860d497cbd80e60c033dae9c.png" class="" title="image.png"><ul><li>同样也是在<code>setContext</code>时注册<code>services</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;加载services</span><br><span class="line">-(void)loadStaticServices</span><br><span class="line">&#123;</span><br><span class="line">    [BHServiceManager sharedManager].enableException &#x3D; self.enableException;</span><br><span class="line">    </span><br><span class="line">    [[BHServiceManager sharedManager] registerLocalServices];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerLocalServices</span><br><span class="line">&#123;</span><br><span class="line">    NSString *serviceConfigName &#x3D; [BHContext shareInstance].serviceConfigName;</span><br><span class="line">    &#x2F;&#x2F;获取plist文件路径</span><br><span class="line">    NSString *plistPath &#x3D; [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    if (!plistPath) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSArray *serviceList &#x3D; [[NSArray alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    [self.lock lock];</span><br><span class="line">    &#x2F;&#x2F;遍历并存储到allServicesDict中</span><br><span class="line">    for (NSDictionary *dict in serviceList) &#123;</span><br><span class="line">        NSString *protocolKey &#x3D; [dict objectForKey:@&quot;service&quot;];</span><br><span class="line">        NSString *protocolImplClass &#x3D; [dict objectForKey:@&quot;impl&quot;];</span><br><span class="line">        if (protocolKey.length &gt; 0 &amp;&amp; protocolImplClass.length &gt; 0) &#123;</span><br><span class="line">            [self.allServicesDict addEntriesFromDictionary:@&#123;protocolKey:protocolImplClass&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、load方法注册</strong></p><p>**<br>**</p><p>在Load方法里面注册<code>Protocol</code>协议，主要是调用<code>BeeHive</code>里面的<code>registerService:service:</code>完成<code>protocol</code>的注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">   [[BeeHive shareInstance] registerService:@protocol(UserTrackServiceProtocol) service:[BHUserTrackViewController class]];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerService:(Protocol *)proto service:(Class) serviceClass</span><br><span class="line">&#123;</span><br><span class="line">    [[BHServiceManager sharedManager] registerService:proto implClass:serviceClass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，三种方式就创建完成了</p><p><strong>Protocol的获取</strong></p><p>**<br>**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Protocol&#96;与&#96;Module&#96;的区别在于，&#96;Protocol&#96;比&#96;Module&#96;多了一个方法，可以&#96;返回Protocol实例对象</span><br><span class="line">- (id)createService:(Protocol *)proto;</span><br><span class="line">&#123;</span><br><span class="line">    return [[BHServiceManager sharedManager] createService:proto];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service</span><br><span class="line">&#123;</span><br><span class="line">    return [self createService:service withServiceName:nil];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName &#123;</span><br><span class="line">    return [self createService:service withServiceName:serviceName shouldCache:YES];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName shouldCache:(BOOL)shouldCache &#123;</span><br><span class="line">    if (!serviceName.length) &#123;</span><br><span class="line">        serviceName &#x3D; NSStringFromProtocol(service);</span><br><span class="line">    &#125;</span><br><span class="line">    id implInstance &#x3D; nil;</span><br><span class="line">    &#x2F;&#x2F;判断protocol是否已经注册过</span><br><span class="line">    if (![self checkValidService:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol does not been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *serviceStr &#x3D; serviceName;</span><br><span class="line">    &#x2F;&#x2F;如果有缓存，则直接从缓存中获取</span><br><span class="line">    if (shouldCache) &#123;</span><br><span class="line">        id protocolImpl &#x3D; [[BHContext shareInstance] getServiceInstanceFromServiceName:serviceStr];</span><br><span class="line">        if (protocolImpl) &#123;</span><br><span class="line">            return protocolImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取类后，然后响应下层的方法</span><br><span class="line">    Class implClass &#x3D; [self serviceImplClass:service];</span><br><span class="line">    if ([[implClass class] respondsToSelector:@selector(singleton)]) &#123;</span><br><span class="line">        if ([[implClass class] singleton]) &#123;</span><br><span class="line">            if ([[implClass class] respondsToSelector:@selector(shareInstance)])</span><br><span class="line">                &#x2F;&#x2F;创建单例对象</span><br><span class="line">                implInstance &#x3D; [[implClass class] shareInstance];</span><br><span class="line">            else</span><br><span class="line">                &#x2F;&#x2F;创建实例对象</span><br><span class="line">                implInstance &#x3D; [[implClass alloc] init];</span><br><span class="line">            if (shouldCache) &#123;</span><br><span class="line">                &#x2F;&#x2F;缓存</span><br><span class="line">                [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [[implClass alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createService</code>会先检查Protocol协议是否是注册过的。然后接着取出字典里面对应的Class，如果实现了<code>shareInstance</code>方法，那么就创建一个<code>单例对象</code>，如果没有，那么就创建一个<code>实例对象</code>。如果还实现了singleton，就能进一步的把<code>implInstance</code>和<code>serviceStr</code>对应的加到<code>BHContext</code>的<code>servicesByName</code>字典里面<code>缓存</code>起来。这样就可以随着上下文传递了</p><ul><li>进入<code>serviceImplClass</code>实现，从这里可以看出 protocol和类是通过<code>字典</code>绑定的，<code>protocol</code>作为<code>key</code>，<code>serviceImp</code>（类的名字）作为<code>value</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (Class)serviceImplClass:(Protocol *)service</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;通过字典将 协议 和 类 绑定，其中协议作为key，serviceImp（类的名字）作为value</span><br><span class="line">    NSString *serviceImpl &#x3D; [[self servicesDict] objectForKey:NSStringFromProtocol(service)];</span><br><span class="line">    if (serviceImpl.length &gt; 0) &#123;</span><br><span class="line">        return NSClassFromString(serviceImpl);</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Module-amp-Protocol"><a href="#Module-amp-Protocol" class="headerlink" title="Module &amp; Protocol"></a>Module &amp; Protocol</h3><p>这里简单总结下：</p><ul><li>对于<code>Module</code>：数组存储</li><li>对于<code>Protocol</code>：通过字典将<code>protocol</code>与类进行绑定，<code>key</code>为<code>protocol</code>，<code>value</code>为 <code>serviceImp</code>即类名</li></ul><h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><ul><li><code>BHConfig</code>类：是一个单例，其内部有一个<code>NSMutableDictionary</code>类型的<code>config</code>属性，该属性维护了一些动态的环境变量，作为<code>BHContext</code>的补充存在</li><li><code>BHContext</code>类：是一个单例，其内部有两个<code>NSMutableDictionary</code>的属性，分别是<code>modulesByName</code> 和 <code>servicesByName</code>。这个类主要用来保存上下文信息的。例如在<code>application:didFinishLaunchingWithOptions:</code>的时候，就可以初始化大量的上下文信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;保存信息</span><br><span class="line">[BHContext shareInstance].application &#x3D; application;</span><br><span class="line">[BHContext shareInstance].launchOptions &#x3D; launchOptions;</span><br><span class="line">[BHContext shareInstance].moduleConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BeeHive&quot;;&#x2F;&#x2F;可选，默认为BeeHive.bundle&#x2F;BeeHive.plist</span><br><span class="line">[BHContext shareInstance].serviceConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BHService&quot;;</span><br></pre></td></tr></table></figure><ul><li><code>BHTimeProfiler</code>类：用来进行计算时间性能方面的Profiler</li><li><code>BHWatchDog</code>类：用来开一个线程，监听主线程是否堵塞</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> iOS架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 架构 </tag>
            
            <tag> 组件化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS组件化方案(1)</title>
      <link href="2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/"/>
      <url>2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/</url>
      
        <content type="html"><![CDATA[<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>组件化其实就是<code>将模块单独抽离、分层</code>，并指定模块间的<code>通讯</code>方式，从而实现<code>解耦</code>的一种方式，主要运用与团队开发</p><h4 id="为什么需要组件化？"><a href="#为什么需要组件化？" class="headerlink" title="为什么需要组件化？"></a>为什么需要组件化？</h4><p>主要有以下四个原因</p><ul><li>1、模块间解耦</li><li>2、模块重用</li><li>3、提高团队协作开发效率</li><li>4、单元测试</li></ul><a id="more"></a><p>当项目因为各种需求，越来越来时，如果此时的各个模块之间是互相调用，即<code>你中有我，我中有你</code>这种情况时，会造成<code>高耦合</code>的情况。一旦我们需要对某一块代码进行<code>修改</code>时，就会<code>牵一发而动全身</code>，导致项目难以维护</p><p>其问题主要体现在以下几个方面：</p><ul><li>1、修改某个功能时，同时需要修改其他模块的代码，因为在其他模块中有该模块的引用。可以理解为<code>高耦合导致代码修改困难</code></li><li>2、模块对外接口不明确，甚至暴露了本不该暴露的私有接口，修改时费时费力。可以理解为<code>接口不固定导致的接口混乱</code></li><li>3、高耦合代码产生的后果就是会影响团队其他成员的开发，产生<code>代码冲突</code></li><li>4、当模块需要重用到其他项目时，<code>难以单独抽离</code></li><li>5、模块间耦合的忌口导致接口和依赖关系混乱，<code>无法进行单元测试</code></li></ul><p>所以为了解决以上问题，我们需要采用更规范的方式来<code>降低模块</code>间的<code>耦合度</code>，这就是<code>组件化</code>，也可以理解为<code>模块化</code></p><p>但是，这里还需要说明一点，因为组件化也是需要一定成本的，需要花费时间设计接口、分离代码等，所以并不是所有的项目都需要组件化。如果你的项目有以下这些特征就<code>不需要组件化</code>：</p><ul><li>1、项目较小，模块间交互简单，耦合少</li><li>2、项目没有被多个外部模块引用，只是一个单独的小模块</li><li>3、模块不需要重用，代码也很少被修改</li><li>4、团队规模很小</li><li>5、不需要编写单元测试</li></ul><p>如果你的有以下特性，说明你就必须要<code>考虑进行组件化</code>了：</p><ul><li>1、模块逻辑复杂，多个模块之间频繁互相引用</li><li>2、项目规模逐渐变大，修改代码变的越来越困难（这里可以理解为：修改一处代码，需要同时修改其他多个地方）</li><li>3、团队人数变多，提交的代码经常和其他成员冲突</li><li>4、项目编译耗时较大</li><li>5、模块的单元测试经常由于其他模块的修改而失败</li></ul><h3 id="组件化方案"><a href="#组件化方案" class="headerlink" title="组件化方案"></a>组件化方案</h3><h4 id="组件化方案的8条指标"><a href="#组件化方案的8条指标" class="headerlink" title="组件化方案的8条指标"></a>组件化方案的8条指标</h4><p>一个项目经过组件化后如何来评判，主要有以下几个<code>标准</code>：</p><ul><li>1、模块之间没有耦合，模块内部的修改不会应该其他模块</li><li>2、模块可以单独编译</li><li>3、模块间数据传递明确</li><li>4、模块可以随时被另一个提供了相同功能的模块替换</li><li>5、模块对外接口清晰且易维护</li><li>6、当模块接口改变时，此模块的外部代码能够被高效重构</li><li>7、尽量用最少的修改和代码，让现有的项目实现模块化</li><li>8、支持OC和Swift，以及混编</li></ul><p>前4条主要用于<code>衡量一个模块是否真正解耦</code>，后4条主要用于衡量在项目中<code>实践中的易用程度</code></p><h4 id="组件化原则"><a href="#组件化原则" class="headerlink" title="组件化原则"></a>组件化原则</h4><p>一个项目主要分为3层：<code>业务层</code>、<code>通用层</code>以及<code>基础层</code>，在进行组件化时，有以下几点说明</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/d45435499bcd48d69596779b778e2b39.png" class="" title="image.png"><ul><li>只能上层对依赖，不能下层对上层的依赖，因为下层是对上层的抽象</li><li>项目公共代码资源下沉</li><li>横向的依赖尽量少有，最好下层至通用模块，或者基础模块</li></ul><p>**<br>**</p><h4 id="组件化方案-1"><a href="#组件化方案-1" class="headerlink" title="组件化方案"></a>组件化方案</h4><p>常用的组件化方案主要有两种：</p><ul><li><code>本地组件化</code>：主要是通过在<code>工程中创建library</code>，利用<code>cocoapods</code>的<code>workspec</code>进行本地管理，不需要将项目上传git，而是直接在本项目中以framework的方法进行调用</li><li><code>cocoapods组件化</code>：主要是利用cocoapods来进行模块的远程管理，需要将项目上传git（需要注意：这里的组件化模块分为<code>公有库</code>和<code>私有库</code>，对公司而言，一般是私有库）</li></ul><h3 id="本地组件化"><a href="#本地组件化" class="headerlink" title="本地组件化"></a>本地组件化</h3><h4 id="1、创建主工程"><a href="#1、创建主工程" class="headerlink" title="1、创建主工程"></a>1、创建主工程</h4><ul><li>首先创建一个工程</li></ul><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/d411eb30e54b48faa116bde3c19dd158.png" class="" title="image.png"><ul><li>集成cocopods，进行本地管理：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd 项目目录</span><br><span class="line">$ pod init</span><br><span class="line">$ pod init</span><br></pre></td></tr></table></figure><ul><li>编辑podfile，并执行<code>pod install</code></li></ul><h4 id="2、创建组件"><a href="#2、创建组件" class="headerlink" title="2、创建组件"></a>2、创建组件</h4><p>假设有以下几个模块：</p><ul><li><code>主工程</code>：承载主要的表层业务代码</li><li><code>Core</code>：独立存在，应用加密、接口请求等敏感代码</li><li><code>Base</code>：基类封装，拓展，基本的数据处理</li><li><code>Service</code>：服务层，封装业务工具类，例如网络层服务、持久化服务等</li><li><code>Pods</code>：三方依赖</li></ul><p>其中，各个模块间的关系如下所示</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/abbca02925474c55ac37f24181eb711b.png" class="" title="image.png"><p>下面，我们来进行模块的创建，以<code>Core</code>模块为例：</p><ul><li>选择<code>new -&gt; project -&gt; iOS -&gt; Framework</code>，新建一个模块<img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/6e8b46b343d14fc4966346a3eb3734b1.png" class="" title="image.png">选择正确的`Group` 和 `WorkSpace`（这里需要注意一点：创建的`library`最好放在`主工程根目录`下，否则后续`podfile`执行`pod install`时会报错）</li></ul><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/57123daa0cf14b7d9c4878ed22645786.png" class="" title="image.png"><p>将创建的<code>library</code>的<code>Build Settings -&gt; Mach-O Type</code>修改为静态库 <code>Static Library</code></p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/cd442535e97c43e880a4a8e743df2f92.png" class="" title="image.png"><h4 id="3、主工程调用library"><a href="#3、主工程调用library" class="headerlink" title="3、主工程调用library"></a>3、主工程调用library</h4><ul><li>在CJLCore中新建一个文件，并添加如下代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类需要声明为public</span><br><span class="line">public class CJLCoreSetting: NSObject &#123;</span><br><span class="line">    &#x2F;&#x2F;属性需要声明为public</span><br><span class="line">    public static let SCRET_KEY &#x3D; &quot;SCRET_KEY&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Build Phases -&gt; Headers -&gt; Public</code>中将新建的文件添加为public，这样主工程才能访问该文件</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/dc187aeebe7e457bbd5440e924d005b4.png" class="" title="image.png"><p>在主工程中，选择<code>target -&gt; Linked Frameworks Library</code>中添加<code>CJLCore</code>，只需要build主工程，library能够自动联编</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/36ce602f6cd04273831cd6ddafae8874.png" class="" title="image.png"><h4 id="4、使用"><a href="#4、使用" class="headerlink" title="4、使用"></a>4、使用</h4><p>首先<code>import CJLCore</code>，然后使用</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/ddb88b2f9adb401abe5f6e259cf8bf0d.png" class="" title="image.png"><p>这里需要注意的是，子library之间的互相调用，与主工程调用library类似，主需要添加依赖、暴露header即可</p><h4 id="5、使用cocoapods管理三方依赖"><a href="#5、使用cocoapods管理三方依赖" class="headerlink" title="5、使用cocoapods管理三方依赖"></a>5、使用cocoapods管理三方依赖</h4><p>假设我们需要在<code>CJLCore</code>中封装网络层代码，需要用到三方库<code>Alamofire</code>，在podfile中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;9.0&#39;</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">#配置workspace路径</span><br><span class="line">workspace &#39;Modularization.xcworkspace&#39;</span><br><span class="line"></span><br><span class="line">################# 三方依赖</span><br><span class="line"># 公有</span><br><span class="line">def workspace_pods</span><br><span class="line">  pod &#39;SwiftyJSON&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># 主工程</span><br><span class="line">def project_only_pods</span><br><span class="line">  pod &#39;SnapKit&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#网络</span><br><span class="line">def network_layer_pods</span><br><span class="line">  pod &#39;Alamofire&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">################# 模块</span><br><span class="line">target &#39;CJLCore&#39; do</span><br><span class="line">  #配置libray路径</span><br><span class="line">  project &#39;CJLCore&#x2F;CJLCore.xcodeproj&#39;</span><br><span class="line">  </span><br><span class="line">  workspace_pods</span><br><span class="line">  network_layer_pods</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">################# 主工程</span><br><span class="line">target &#39;Modularization&#39; do</span><br><span class="line">  </span><br><span class="line">  workspace_pods</span><br><span class="line">  project_only_pods</span><br><span class="line">  network_layer_pods</span><br><span class="line"></span><br><span class="line">  target &#39;ModularizationTests&#39; do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  target &#39;ModularizationUITests&#39; do</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>到此，一个本地组件化的模块就配置完成了</p><h3 id="cocoapods组件化"><a href="#cocoapods组件化" class="headerlink" title="cocoapods组件化"></a>cocoapods组件化</h3><p>除了本地组件化，还可以使用<code>cocoapods</code>，其原理如下图所示</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/a9afd9886f6b49919a262e3f893e6fc8.png" class="" title="image.png">这里还是以本地组件化中的结构为例<h4 id="1、创建私有仓库"><a href="#1、创建私有仓库" class="headerlink" title="1、创建私有仓库"></a>1、创建私有仓库</h4><ul><li>在github上创建一个MySpecs仓库<br>具体步骤：登录github–&gt;点击右上角“+”–&gt;选择 new repository–&gt;输入Repository name为MySpecs，选择仓库类型为 private，点击Create repository。</li><li>将私有仓库添加至本地<code>~/.cocoapods/repos</code>目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add mySpecs https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;MySpecs.git</span><br></pre></td></tr></table></figure><h4 id="2、创建pods-工程，即组件化工程"><a href="#2、创建pods-工程，即组件化工程" class="headerlink" title="2、创建pods 工程，即组件化工程"></a>2、创建pods 工程，即组件化工程</h4><ul><li>使用终端创建<code>CJLServices</code>模块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create CJLServices</span><br></pre></td></tr></table></figure><p>根据提示依次输入：ios、swift、yes、none、no、CJL</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/5565cf790f424ae58611554ee82710a0.png" class="" title="image.png"><p>进入模块的目录，将文件拷贝至<code>CJLServices -&gt; Classes</code>中</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/444cac4f432a471d87197d9ff4be77a5.png" class="" title="image.png"><p>执行<code>pod install</code>,会将Classes更新至pods中</p><img src="/2022/03/22/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-Part1/c66728c4363547cf87afd5817637a90b.png" class="" title="image.png"><p>执行结果</p><h4 id="3、配置pods工程"><a href="#3、配置pods工程" class="headerlink" title="3、配置pods工程"></a>3、配置pods工程</h4><p>修改模块的配置文件，即<code>CJLServices.podspec</code></p><ul><li>如果需要依赖三方库，需要配置<code>s.dependency</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.dependency &#39;AFNetworking&#39;</span><br></pre></td></tr></table></figure><ul><li>如果模块间需要相互引用，同样需要配置<code>s.dependency</code>，以<code>CJLBase</code>为例，需要引用<code>CJLService</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;********1、修改 podspec 文件</span><br><span class="line">s.dependency &#39;CJLServices&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;********2、修改 podfile 文件</span><br><span class="line">pod &#39;CJLServices&#39;, :path &#x3D;&gt; &#39;..&#x2F;..&#x2F;CJLServices&#39;</span><br></pre></td></tr></table></figure><ul><li>如果需要加载资源，例如图片、json、bundle文件等</li></ul><ul><li><ul><li>1、在模块的<code>Assets</code>文件夹 中添加资源文件</li><li>2、在<code>specs</code>里配置资源路径（必须配置！！否则无法读取资源）</li><li>3、访问时需要指定资源文件路径</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;*****1、修改 podspec 文件</span><br><span class="line">s.resource_bundles &#x3D; &#123;</span><br><span class="line">     &#39;CJLBase&#39; &#x3D;&gt; [&#39;CJLBase&#x2F;Assets&#x2F;*&#39;]</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#x2F;&#x2F;*****2、使用</span><br><span class="line">let bundlePath: String &#x3D; Bundle.init(for: dynamicClass.self).resourcePath! + &quot;&#x2F;CJLBase.bundle&quot;</span><br><span class="line">let bundle &#x3D; Bundle(path: bundlePath)</span><br><span class="line">if let path &#x3D; bundle?.path(forResource: &quot;mouse&quot;, ofType: &quot;jpg&quot;)&#123;</span><br><span class="line">    self.imgView.image &#x3D; UIImage(contentsOfFile: path)</span><br><span class="line">&#125;           </span><br></pre></td></tr></table></figure><p>同理，模块中的xib，json文件的获取方式也是一样的</p><h4 id="4、提交至git"><a href="#4、提交至git" class="headerlink" title="4、提交至git"></a>4、提交至git</h4><p>这里提交至git的模块是pods工程才可以，以<code>CJLBase</code>为例</p><ul><li>需要在github上创建一个私有repository，命名为<code>CJLBase</code></li><li>执行以下终端命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$git init</span><br><span class="line">$git add .</span><br><span class="line">$ git commit -am &quot;第一次提交&quot; </span><br><span class="line">&#x2F;&#x2F;即第一个步骤中创建的仓库地址</span><br><span class="line">$ git remote add origin https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;CJLBase.git</span><br><span class="line"> </span><br><span class="line">$ git push origin master </span><br><span class="line">&#x2F;&#x2F;一定要有标签，不然会有下面的警告</span><br><span class="line">&#x2F;&#x2F;podspec文件中获取Git版本控制的项目需要tag号，</span><br><span class="line">$ git tag -m &quot;first release&quot; &quot;0.1.0&quot; </span><br><span class="line">$ git push --tags </span><br></pre></td></tr></table></figure><h4 id="5、验证podspec文件"><a href="#5、验证podspec文件" class="headerlink" title="5、验证podspec文件"></a>5、验证podspec文件</h4><p>执行终端命令 <code>pod spec lint</code></p><blockquote><p>注意：<code>pod spec</code>相对于<code>pod lib</code>会更为精确，</p><ul><li><code>pod lib</code>相当于只验证一个本地仓库，</li><li><code>pod spec</code>会同时验证本地仓库和远程仓库。</li></ul></blockquote><p>**<br>**</p><h4 id="6、提交到私有仓库"><a href="#6、提交到私有仓库" class="headerlink" title="6、提交到私有仓库"></a>6、提交到私有仓库</h4><p>执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pod repo push [本地Spec Repo名称][podspec文件路径]</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;******举例</span><br><span class="line">$ pod repo push MySpecs CJLBase.podspec</span><br></pre></td></tr></table></figure><p>提交成功后，可在本地仓库中看到提交路径<code>MySpecs -&gt; CJLBase</code></p><h4 id="7、使用"><a href="#7、使用" class="headerlink" title="7、使用"></a>7、使用</h4><ul><li>新建一个工程，在项目的podfile里添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#私有spec仓库的地址，而不是某个pod仓库的地址</span><br><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;MySpecs&#39;</span><br><span class="line">pod &#39;CJLBase&#39;</span><br></pre></td></tr></table></figure><ul><li>执行<code>pod install</code>即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> iOS架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 架构 </tag>
            
            <tag> 组件化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block深入解析-底层原理</title>
      <link href="2022/01/08/Block%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Part1/"/>
      <url>2022/01/08/Block%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Block本质"><a href="#1-Block本质" class="headerlink" title="1. Block本质"></a>1. <code>Block</code>本质</h1><h2 id="1-1-定义一个Block"><a href="#1-1-定义一个Block" class="headerlink" title="1.1 定义一个Block"></a>1.1 定义一个Block</h2><ul><li>定义一个block.c文件，写入以下代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">        printf(&quot;hello&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>通过xcrun -sdk iphonesimulator clang -arch x86_64 -rewrite-objc block.c命令，将block.c编译成block.cpp，其中block在底层被编译成以下的方式:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造函数</span><br><span class="line">    void(*block)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">  &#x2F;&#x2F; block执行</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出，block等于<code>__main_block_impl_0</code>，是一个函数，<code>__main_block_impl_0</code>也是一个结构体，同时可以说明block是一个<code>__main_block_impl_0</code>结构体类型的对象, 如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>其中的<code>__block_impl</code>结构体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>block 本质上也是一个OC对象，内部有一个<code>isa</code>指针。block是封装了函数调用以及函数调用环境的OC对象。</p></li><li><p><code>block</code>通过<code>clang</code>编译后的源码间的关系如下，以<code>__block</code>修饰的变量为例:</p></li></ul><img src="/2022/01/08/Block%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Part1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZvcmV2ZXJfd2o=,size_16,color_FFFFFF,t_70.png" class="" title="在这里插入图片描述"><h2 id="1-2-block为什么需要调用？"><a href="#1-2-block为什么需要调用？" class="headerlink" title="1.2 block为什么需要调用？"></a>1.2 block为什么需要调用？</h2><ul><li>在底层<code>block</code>的类型<code>__main_block_impl_0</code>结构体，通过同名构造函数创建，第一个传入的<code>block</code>的内部实现代码块，即<code>__main_block_func_0</code>,用<code>fp</code>表示，然后赋值给<code>imp</code>的<code>FuncPtr</code>属性，在<code>main</code>中进行调用，这也是<code>block</code>为什么需要调用的原因。</li><li>如果不调用，<code>block</code>内部实现的代码块将无法执行，即：<ol><li>函数声明： 即<code>block</code>内部实现声明成了一个函数<code>__main_blcok_func_0</code>;</li><li>执行具体函数的实现：通过调用<code>block</code>的<code>FuncPtr</code>指针，调用<code>block</code>执行。</li></ol></li></ul><h2 id="1-3-block是如何获取外界变量的？"><a href="#1-3-block是如何获取外界变量的？" class="headerlink" title="1.3 block是如何获取外界变量的？"></a>1.3 block是如何获取外界变量的？</h2><ul><li><p>定义一个变量，并在block中调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int a &#x3D; 6;</span><br><span class="line">    void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">        printf(&quot;hello: %d&quot;, a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>底层编译输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int a; &#x2F;&#x2F; 编译时就自动生产了相应的变量(结构体的成员变量)</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags&#x3D;0) : a(_a) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock; &#x2F;&#x2F; block的isa，默认是stackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int a &#x3D; __cself-&gt;a; &#x2F;&#x2F; bound by copy 值拷贝，此时的a与传入的__cself的a不为同一个，值相同，指针指向的内存地址不同</span><br><span class="line"></span><br><span class="line">        printf(&quot;hello: %d&quot;, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a &#x3D; 6;</span><br><span class="line">    void(*block)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line">  &#x2F;&#x2F; block调用</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>__main_block_func_0</code>中的a是值拷贝，如果此时在blcok内部实现a++操作，会造成编译器的代码歧义，即此时的a是只读的。<br>即：block捕获外部变量时，在内部会自动生成同一个属性来保存。</p></li></ul><h2 id="1-4-block的原理"><a href="#1-4-block的原理" class="headerlink" title="1.4 __block的原理"></a>1.4 <code>__block</code>的原理</h2><ul><li><p>对a加一个<code>__block</code>修饰，然后再<code>block</code>中进行a++操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    __block int a &#x3D; 6;</span><br><span class="line">    void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">        a++;</span><br><span class="line">        printf(&quot;hello: %d&quot;, a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样编译成c++代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_a_0 &#123; &#x2F;&#x2F; __block修饰的外界变量的结构体</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123; &#x2F;&#x2F; __block的结构体类型</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags&#x3D;0) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; &#x2F;&#x2F; block内部实现</span><br><span class="line">  &#x2F;&#x2F; 指针拷贝，此时的对象a与__cself对象的a指向同一片地址空间</span><br><span class="line">  __Block_byref_a_0 *a &#x3D; __cself-&gt;a; &#x2F;&#x2F; bound by ref</span><br><span class="line">                &#x2F;&#x2F; 等同于 外界的a++</span><br><span class="line">        (a-&gt;__forwarding-&gt;a)++;</span><br><span class="line">        printf(&quot;hello: %d&quot;, (a-&gt;__forwarding-&gt;a));</span><br><span class="line">    &#125;</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;a, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  &#x2F;&#x2F; __Block_byref_a_0 是结构体，a 等于 结构体的赋值， 即将外界变量 a 封装成结构体对象</span><br><span class="line">  &#x2F;&#x2F; &amp;a 是外界变量 a 的地址</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_a_0 a &#x3D; &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 6&#125;;</span><br><span class="line">  &#x2F;&#x2F; __main_block_impl_0 中的第三个参数&amp;a, 是封装的对象a的地址</span><br><span class="line">    void(*block)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分析结果：</p><ol><li><code>__main_block_impl_0</code>中，将对象a的地址&amp;a给构造函数；</li><li>在<code>__main_block_func_0</code>内部对a的处理时指针拷贝，此时创建的对象a与传入对象的a指向同一内存空间。</li></ol></li><li><p>总结：</p><ol><li>用<code>__block</code>修饰的外界变量会生成<code>__Block_byref_a_0</code>的结构体；</li><li>结构体用来保存原始变量的指针和值；</li><li>将变量生成的结构体对象的指针地址传递给<code>block</code>，然后再<code>block</code>内部就可以对外界变量进行操作。</li></ol></li><li><p>Tips：深拷贝与浅拷贝</p><ol><li>值拷贝 - 深拷贝，只是拷贝数值，且拷贝的值不可更改，指向不同的内存空间；</li><li>指针拷贝 - 浅拷贝，生成的对象指向同一片内存空间，案例中经过<code>__block</code>修饰的变量a就是指针拷贝;</li></ol></li></ul><h1 id="2-Block底层源码分析"><a href="#2-Block底层源码分析" class="headerlink" title="2. Block底层源码分析"></a>2. <code>Block</code>底层源码分析</h1><h2 id="2-1-block源码位置"><a href="#2-1-block源码位置" class="headerlink" title="2.1 block源码位置"></a>2.1 block源码位置</h2><ul><li><p>在<code>block</code>处打上断点，分析运行时的<code>block</code>，如下所示：</p><img src="/2022/01/08/Block%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Part1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZvcmV2ZXJfd2o=,size_16,color_FFFFFF,t_70-20230128145758720.jpeg" class="" title="在这里插入图片描述"></li><li><p>执行结果如下：</p><img src="/2022/01/08/Block%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Part1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZvcmV2ZXJfd2o=,size_16,color_FFFFFF,t_70-20230128145828967.jpeg" class="" title="在这里插入图片描述"></li><li><p>加<code>objc_retainBlock</code>符号断点，继续向下执行，会执行到<code>_Block_copy</code>，如下：</p><img src="/2022/01/08/Block%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Part1/20210317150948590.jpeg" class="" title="在这里插入图片描述"></li><li><p>继续加<code>_Block_copy</code>符号断点，向下执行，会发现在<code>libsystem_blocks.dylib</code>源码中:</p><img src="/2022/01/08/Block%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Part1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZvcmV2ZXJfd2o=,size_16,color_FFFFFF,t_70-20230128150025679.jpeg" class="" title="在这里插入图片描述"></li><li><p>可以到苹果开源网站下载最新的libclosure-74源码，分析<code>_Block_copy</code>的源码实现，可以发现<code>block</code>在底层的真正类型是<code>Block_layout</code>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> iOS进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Block </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop的应用</title>
      <link href="2021/12/02/RunLoop-Part2/"/>
      <url>2021/12/02/RunLoop-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、RunLoop与线程"><a href="#一、RunLoop与线程" class="headerlink" title="一、RunLoop与线程"></a>一、RunLoop与线程</h1><h2 id="1-RunLoop与线程的关系"><a href="#1-RunLoop与线程的关系" class="headerlink" title="1. RunLoop与线程的关系"></a>1. RunLoop与线程的关系</h2><p>苹果官方文档中，<code>RunLoop</code>的相关介绍写在线程编程指南中，可见<code>RunLoop</code>和线程的关系不一般。<a href="https://link.juejin.cn/?target=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html%23//apple_ref/doc/uid/10000057i-CH16-SW23">Threading Programming Guide（苹果官方文档）</a></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 访问 loopsDic 时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;&#x2F; 获取一个 pthread 对应的 RunLoop。</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        &#x2F;&#x2F; 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span><br><span class="line">        loopsDic &#x3D; CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop &#x3D; _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 直接从 Dictionary 里获取。</span><br><span class="line">    CFRunLoopRef loop &#x3D; CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 取不到时，创建一个</span><br><span class="line">        loop &#x3D; _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以得出：</p><ul><li><code>RunLoop</code>对象和线程是一一对应的关系</li><li><code>RunLoop</code>保存在一个全局的<code>Dictionary</code>里，线程作为<code>key</code>，<code>RunLoop</code>作为<code>Value</code>;</li><li>如果没有<code>RunLoop</code>，线程执行完任务就会退出；如果没有<code>RunLoop</code>，主线程执行完<code>Main()</code>函数就会退出，程序就不能处于运行状态；</li><li><code>RunLoop</code>创建时机：线程刚创建并没有<code>RunLoop</code>对象，如果你不主动获取，那它一直都不会有。<code>RunLoop</code>会在第一次获取它时创建；</li><li><code>RunLoop</code>销毁机制：<code>RunLoop</code>会在线程结束时销毁；</li><li>主线程的<code>RunLoop</code>已经自动获取（创建），子线程默认没有开启<code>RunLoop</code>；</li><li>主线程的<code>RunLoop</code>对象是在<code>UIApplicationMain</code>中通过<code>[NSRunLoop currentRunLoop]</code>获取，一旦发现它不存在，就会创建<code>RunLoop</code>对象。</li></ul><h2 id="2-开启子线程的RunLoop的过程"><a href="#2-开启子线程的RunLoop的过程" class="headerlink" title="2. 开启子线程的RunLoop的过程"></a>2. 开启子线程的RunLoop的过程</h2><h3 id="获取RunLoop对象"><a href="#获取RunLoop对象" class="headerlink" title="获取RunLoop对象"></a>获取RunLoop对象</h3><p>可以通过以下代码来获取<code>RunLoop</code>对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Foundation</span><br><span class="line">[NSRunLoop mainRunLoop];     &#x2F;&#x2F; 获取主线程的 RunLoop 对象</span><br><span class="line">[NSRunLoop currentRunLoop];  &#x2F;&#x2F; 获取当前线程的 RunLoop 对象</span><br><span class="line">&#x2F;&#x2F; Core Foundation</span><br><span class="line">CFRunLoopGetMain();     &#x2F;&#x2F; 获取主线程的 RunLoop 对象</span><br><span class="line">CFRunLoopGetCurrent();  &#x2F;&#x2F; 获取当前线程的 RunLoop 对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启动子线程的RunLoop"><a href="#启动子线程的RunLoop" class="headerlink" title="启动子线程的RunLoop"></a>启动子线程的RunLoop</h3><p>可以通过以下代码来启动子线程的<code>RunLoop</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Foundation</span><br><span class="line">[[NSRunLoop currentRunLoop] run];</span><br><span class="line">[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">&#x2F;&#x2F; Core Foundation</span><br><span class="line">CFRunLoopRun();</span><br><span class="line">&#x2F;&#x2F; 第3个参数：设置为 true，代表执行完 Source&#x2F;Port 后就会退出当前 loop</span><br><span class="line">CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, false);  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-如何实现一个常驻线程"><a href="#3-如何实现一个常驻线程" class="headerlink" title="3. 如何实现一个常驻线程"></a>3. 如何实现一个常驻线程</h2><ul><li>好处：经常用到子线程的时候，不用一直创建销毁，提高性能；</li><li>条件：该任务需是串行，而非并发；</li><li>步骤：<ol><li>获取/创建当前线程的RunLoop；</li><li>向该<code>RunLoop</code>中添加一个<code>Source/port</code>等来维持<code>RunLoop</code>的事件循环（如果Mode里没有任何<code>Source0/Source1/Timer/Observer，RunLoop</code>会立马退出）；</li><li>启动该RunLoop</li></ol></li></ul><p>以下是示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ViewController.m</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;HTThread.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) HTThread *thread;</span><br><span class="line">@property (nonatomic, assign, getter&#x3D;isStoped) BOOL stopped;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">    </span><br><span class="line">    self.stopped &#x3D; NO;</span><br><span class="line">    self.thread &#x3D; [[HTThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;begin-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; ① 获取&#x2F;创建当前线程的 RunLoop </span><br><span class="line">        &#x2F;&#x2F; ② 向该 RunLoop 中添加一个 Source&#x2F;Port 等来维持 RunLoop 的事件循环</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    </span><br><span class="line">        while (weakSelf &amp;&amp; !weakSelf.isStoped) &#123;</span><br><span class="line">            &#x2F;&#x2F; ③ 启动该 RunLoop</span><br><span class="line">            &#x2F;* </span><br><span class="line">              [[NSRunLoop currentRunLoop] run]</span><br><span class="line">              如果调用 RunLoop 的 run 方法，则会开启一个永不销毁的线程</span><br><span class="line">              因为 run 方法会通过反复调用 runMode:beforeDate: 方法，以运行在 NSDefaultRunLoopMode 模式下</span><br><span class="line">              换句话说，该方法有效地开启了一个无限的循环，处理来自 RunLoop 的输入源 Sources 和 Timers 的数据</span><br><span class="line">            *&#x2F; </span><br><span class="line">            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;end-----%@&quot;, [NSThread currentThread]);    </span><br><span class="line">    &#125;];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    if (!self.thread) return;</span><br><span class="line">    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子线程需要执行的任务</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s-----%@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 停止子线程的 RunLoop</span><br><span class="line">- (void)stopThread</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 设置标记为 YES</span><br><span class="line">    self.stopped &#x3D; YES;   </span><br><span class="line">    &#x2F;&#x2F; 停止 RunLoop</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());    </span><br><span class="line">    NSLog(@&quot;%s-----%@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">    &#x2F;&#x2F; 清空线程</span><br><span class="line">    self.thread &#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    </span><br><span class="line">    if (!self.thread) return;</span><br><span class="line">    &#x2F;&#x2F; 在子线程调用（waitUntilDone设置为YES，代表子线程的代码执行完毕后，当前方法才会继续往下执行）</span><br><span class="line">    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HTThread.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">@interface HTThread : NSThread</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HTThread.m</span><br><span class="line">#import &quot;HTThread.h&quot;</span><br><span class="line">@implementation HTThread</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>点击 view，接着退出当前 ViewController。输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin-----&lt;HTThread: 0x600002b71240&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;</span><br><span class="line">-[ViewController test]-----&lt;HTThread: 0x600002b71240&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;</span><br><span class="line">-[ViewController dealloc]</span><br><span class="line">-[ViewController stopThread]-----&lt;HTThread: 0x600002b71240&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;</span><br><span class="line">end-----&lt;HTThread: 0x600002b71240&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;</span><br><span class="line">-[HTThread dealloc]</span><br></pre></td></tr></table></figure><h1 id="二、RunLoop与NSTimer"><a href="#二、RunLoop与NSTimer" class="headerlink" title="二、RunLoop与NSTimer"></a>二、RunLoop与NSTimer</h1><ul><li>根据RunLoop的原理，我们知道，<code>NSTimer</code>是由<code>RunLoop</code>来管理的，<code>NSTimer</code>其实就是<code>CFRunLoopTimerRef</code>，他们之间是<code>toll-free bridged</code>的，可以相互转换；</li><li>如果我们在子线程上使用<code>NSTimer</code>，就必须开启子线程的<code>RunLoop</code>，否则定时器无法生效</li></ul><h2 id="1-解决TableView滑动时NSTimer失效的问题"><a href="#1-解决TableView滑动时NSTimer失效的问题" class="headerlink" title="1. 解决TableView滑动时NSTimer失效的问题"></a>1. 解决TableView滑动时NSTimer失效的问题</h2><ul><li>问题：<code>RunLoop</code>同一时间只能运行在一种模式下，当我们滑动<code>tableview/scrollview</code>的时候<code>RunLoop</code>会切换到<code>UITrackingRunLoopMode</code>界面追踪模式下。如果我们的<code>NSTimer</code>是添加到<code>RunLoop</code>的<code>KCFRunLoopDefaultMode/NSDefaultRunLoopMode</code>默认模式下的话，此时<code>NStimer</code>是会失效的。</li><li>解决：我们可以将<code>NSTimer</code>添加到<code>RunLoop</code>的<code>KCFRunLoopCommonModes/NSRunLoopCommonModes</code>通用模式下，来保证无论是在默认模式下还是界面追踪模式下<code>NSTimer</code>都可以执行的。</li></ul><h3 id="NSTimer的创建方式"><a href="#NSTimer的创建方式" class="headerlink" title="NSTimer的创建方式"></a>NSTimer的创建方式</h3><p>如果我们是通过以下方法创建的<code>NSTimer</code>，是自动添加到<code>RunLoop</code>的默认模式下的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;123&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>我们可以通过以下方法创建<code>NSTimer</code>，来自定义添加到<code>RunLoop</code>的某种模式下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer &#x3D; [NSTimer timerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    NSLog(@&quot;123&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果是通过<code>timerxxx</code>开头方法创建的<code>NSTimer</code>是不会自动添加到<code>RunLoop</code>中的，所以一定要记得手动添加，否则<code>NSTimer</code>不生效。</p><h2 id="2-NSTimer和CADisplayLink"><a href="#2-NSTimer和CADisplayLink" class="headerlink" title="2. NSTimer和CADisplayLink"></a>2. NSTimer和CADisplayLink</h2><ul><li>不准时：<code>NSTimer</code>和<code>CADisplayLink</code>底层都是基于<code>Runloop</code>的<code>CFRunLoopTimerRef</code>实现的，也就是说它们依赖于<code>Runloop</code>。如果<code>Runloop</code>的任务过于繁重，会导致它们不准时。</li><li>循环引用</li></ul><p>比如<code>NSTimer</code>每1.0秒就会执行一次任务，<code>Runloop</code>每进行一次循环，就会看一下<code>NSTimer</code>的时间是否达到1.0秒，是的话就执行任务。但是由于<code>Runloop</code>每一次循环的任务不一样，所花费的时间就不固定。假设第一次循环所花时间为 0.2s，第二次 0.3s，第三次 0.3s，则再过 0.2s 就会执行<code>NSTimer</code>的任务，这时候可能<code>Runloop</code>的任务过于繁重，第四次花了0.5s，那加起来时间就是 1.3s，导致<code>NSTimer</code>不准时。</p><p>解决方法：使用 GCD 的定时器。GCD 的定时器是直接跟系统内核挂钩的，而且它不依赖于<code>RunLoop</code>，所以它非常的准时。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;myqueue&quot;, DISPATCH_QUEUE_SERIAL);        &#x2F;&#x2F;创建定时器 </span><br><span class="line">dispatch_source_t timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);    &#x2F;&#x2F;设置时间</span><br><span class="line">（start:几s后开始执行； interval:时间间隔）    uint64_t start &#x3D; 2.0;    &#x2F;&#x2F;2s后开始执行    </span><br><span class="line">uint64_t interval &#x3D; 1.0; &#x2F;&#x2F;每隔1s执行    </span><br><span class="line">dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0);    &#x2F;&#x2F;设置回调    </span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;       NSLog(@&quot;%@&quot;,[NSThread currentThread]);    &#125;);   </span><br><span class="line">&#x2F;&#x2F;启动定时器    </span><br><span class="line">dispatch_resume(timer);    </span><br><span class="line">NSLog(@&quot;%@&quot;,[NSThread currentThread]);        </span><br><span class="line">self.timer &#x3D; timer;</span><br><span class="line">&#x2F;* 2020-02-01 21:34:23.036474+0800 多线程[7309:1327653] &lt;NSThread: 0x600001a5cfc0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 2020-02-01 21:34:25.036832+0800 多线程[7309:1327705] &lt;NSThread: 0x600001acb600&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125; 2020-02-01 21:34:26.036977+0800 多线程[7309:1327705] &lt;NSThread: 0x600001acb600&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125; 2020-02-01 21:34:27.036609+0800 多线程[7309:1327707] &lt;NSThread: 0x600001a1e5c0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; *&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> iOS进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> RunLoop </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop的原理</title>
      <link href="2021/11/22/RunLoop-Part1/"/>
      <url>2021/11/22/RunLoop-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、RunLoop概念"><a href="#一、RunLoop概念" class="headerlink" title="一、RunLoop概念"></a>一、RunLoop概念</h1><p>RunLoop，顾名思义其实就是一个循环，而通过这个循环能帮助我们理解以及解决什么问题就是我们值得思考的事情了。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><ul><li>没有消息需要处理时，休眠线程以避免资源占用。从用户态切换到内核态，等待消息；</li><li>有消息需要处理时，立刻唤醒线程，回到用户态处理消息；</li><li>通过调用mach_msg()函数来转移当前线程的控制权给内核态/用户态</li></ul><a id="more"></a><h3 id="RunLoop作用"><a href="#RunLoop作用" class="headerlink" title="RunLoop作用"></a>RunLoop作用</h3><ul><li><p>保持程序的持续运行：</p><p>如果没有RunLoop，main()函数一执行完，程序就会立刻退出。而我们的iOS程序能保持持续运行的原因就是在main()函数中调用了UIApplicationMain函数，这个函数内部会启动主线程的RunLoop;</p></li><li><p>处理App中的各种事件（比如触摸事件、定时器事件等）；</p></li><li><p>节省CPU资源，提高程序性能; </p></li></ul><h1 id="二、RunLoop结构"><a href="#二、RunLoop结构" class="headerlink" title="二、RunLoop结构"></a>二、RunLoop结构</h1><p>在iOS系统中，提供了两个对象：NSRunLoop 和 CFRunLoopRef。<br>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯C函数的API，所以这些API都是线程安全的。<br>NSRunLoop 是基于 CFRunLoopRef 的封装，它提供了面向对象的API，但是这些API不是线程安全的。<br>CFRunLoopRef 的代码是开源的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/">http://opensource.apple.com/tarballs/CF/</a> 下载到整个 CoreFoundation 的源码来查看。</p><p>下面介绍几种获取RunLoop对象的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Foundation</span><br><span class="line">[NSRunLoop mainRunLoop];     &#x2F;&#x2F; 获取主线程的 RunLoop 对象</span><br><span class="line">[NSRunLoop currentRunLoop];  &#x2F;&#x2F; 获取当前线程的 RunLoop 对象</span><br><span class="line">&#x2F;&#x2F; Core Foundation</span><br><span class="line">CFRunLoopGetMain();     &#x2F;&#x2F; 获取主线程的 RunLoop 对象</span><br><span class="line">CFRunLoopGetCurrent();  &#x2F;&#x2F; 获取当前线程的 RunLoop 对象</span><br></pre></td></tr></table></figure><h2 id="RunLoop的构成"><a href="#RunLoop的构成" class="headerlink" title="RunLoop的构成"></a>RunLoop的构成</h2><p>RunLoop的结构体定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; CFRunLoop.h</span><br><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line">&#x2F;&#x2F; CFRunLoop.c</span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">      ...</span><br><span class="line">    pthread_t _pthread; &#x2F;&#x2F; RunLoop与线程是一一对应的关系</span><br><span class="line">    CFMutableSetRef _commonModes; &#x2F;&#x2F; 存储着NSString对象的集合（Mode的名称）</span><br><span class="line">    CFMutableSetRef _commonModeItems; &#x2F;&#x2F; 存储着被标记为通用模式的的 Source0、Source1、Timer、Observer</span><br><span class="line">    CFRunLoopModeRef _currentMode; &#x2F;&#x2F; RunLoop当前的运行模式</span><br><span class="line">    CFMutableSetRef _modes; &#x2F;&#x2F; 存储着RunLoop所有的Mode（CFRunLoopModeRef）模式</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>RunLoop结构图示：</p><img src="RunLoop-Part1/RunLoop1.png" alt="RunLoop1" style="zoom:50%;" align="left" /><p>RunLoop结构对应关系：</p><img src="RunLoop-Part1/RunLoop2.jpeg" alt="RunLoop2" style="zoom: 67%;" align="left" /><h2 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h2><ul><li>CFRunLoopModeRef 代表RunLoop的运行模式；</li><li>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer；</li><li>RunLoop启动时只能选择其中一个Mode，作为CurrentMode;</li><li>如果需要切换Mode，只能退出当前Mode，再重新选择一个Mode进入，切换模式不会导致程序退出；</li><li>不同Mode中的Source0/Source1/Timer/Observer能分割开来，互不影响；</li><li>如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoopMode *CFRunLoopModeRef;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">      ...</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="RunLoop常见的模式"><a href="#RunLoop常见的模式" class="headerlink" title="RunLoop常见的模式"></a>RunLoop常见的模式</h3><table><thead><tr><th>ModeName</th><th>描述</th></tr></thead><tbody><tr><td>NSDefaultRunLoopMode / KCFRunLoopDefaultMode</td><td>默认模式</td></tr><tr><td>UITrackingRunLoopMode</td><td>界面追踪模式，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响；</td></tr><tr><td>NSRunLoopCommonModes / KCFRunLoopCommonModes</td><td>通用模式（默认包含 KCFRunLoopDefaultMode 和 UITrackingRunLoopMode）  该模式不是实际存在的一种模式，它只是一个特殊的标记，是同步<code>Source0</code>/<code>Source1</code>/<code>Timer</code>/<code>Observer</code>到多个 Mode 中的技术方案。被标记为通用模式的<code>Source0</code>/<code>Source1</code>/<code>Timer</code>/<code>Observer</code>都会存放到 _commonModeItems 集合中，会同步这些<code>Source0</code>/<code>Source1</code>/<code>Timer</code>/<code>Observer</code>到多个 Mode 中。</td></tr></tbody></table><h3 id="CFRunLoopModeRef这样设计有什么好处？"><a href="#CFRunLoopModeRef这样设计有什么好处？" class="headerlink" title="CFRunLoopModeRef这样设计有什么好处？"></a>CFRunLoopModeRef这样设计有什么好处？</h3><p>一个 RunLoopMode 又可以持有多个 RunLoopModeItem（Source/Timer/Observer），这样设计的目的主要是为了分隔开不同的 item，让它们能够在各自的“模式”下互不干扰地进行工作。Mode 做到了屏蔽的效果，当<code>RunLoop</code>运行在 Mode1 下面的时候，是处理不了 Mode2 的事件的；</p><h3 id="RunLoop为什么会有多个Mode？"><a href="#RunLoop为什么会有多个Mode？" class="headerlink" title="RunLoop为什么会有多个Mode？"></a>RunLoop为什么会有多个Mode？</h3><p>比如<code>NSDefaultRunLoopMode</code>默认模式和<code>UITrackingRunLoopMode</code>滚动模式，滚动屏幕的时候就会切换到滚动模式，就不用去处理默认模式下的事件了，保证了 UITableView 等的滚动顺畅。</p><h3 id="应用场景举例："><a href="#应用场景举例：" class="headerlink" title="应用场景举例："></a>应用场景举例：</h3><p>主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p><p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p><h2 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h2><p>在RunLoop中有两个很重要的概念，一个是上面提交的模式，还有一个就是事件源。事件源分为输入源（<code>Input Sources</code>）和定时器源（<code>Timer Sources</code>）两种；<br>输入源（<code>Input Sources</code>）又分为<code>Source0</code>和<code>Source1</code>两种，一下__CFRunLoopSource中的共用体<code>union</code>中的<code>version0</code>和<code>version1</code>就分别对应<code>Source0</code>和<code>Source1</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopSource &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    uint32_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFIndex _order;            &#x2F;* immutable *&#x2F;</span><br><span class="line">    CFMutableBagRef _runLoops;</span><br><span class="line">    union &#123;</span><br><span class="line">          CFRunLoopSourceContext version0;    &#x2F;* immutable, except invalidation *&#x2F;</span><br><span class="line">        CFRunLoopSourceContext1 version1;    &#x2F;* immutable, except invalidation *&#x2F;</span><br><span class="line">    &#125; _context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Source0和Source1的区别"><a href="#Source0和Source1的区别" class="headerlink" title="Source0和Source1的区别:"></a>Source0和Source1的区别:</h3><table><thead><tr><th>Input Sources</th><th>区别</th></tr></thead><tbody><tr><td>Source0</td><td>需要手动唤醒线程：添加<code>Source0</code>到<code>RunLoop</code>并不会主动唤醒线程，需要手动唤醒） ① 触摸事件处理 ② <code>performSelector:onThread:</code></td></tr><tr><td>Source1</td><td>具备唤醒线程的能力 ① 基于 Port 的线程间通信 ② 系统事件捕捉：系统事件捕捉是由<code>Source1</code>来处理，然后再交给<code>Source0</code>处理</td></tr></tbody></table><p>把事件进行分类，大家会分成几类？分类的方式有很多，但一定会有下面这种：</p><p>系统层事件、应用层事件、特殊事件。（这只是为了大家理解source1和source0举得一个不严谨的例子，大家不要在意细节）</p><p>如果上面对事件分类的方式你理解，那就好办了，特殊事件我们不管，那么，source1基本就是系统事件，source0基本就是应用层事件。</p><p>• Source1 :基于mach_Port的,来自系统内核或者其他进程或线程的事件，可以主动唤醒休眠中的RunLoop（iOS里进程间通信开发过程中我们一般不主动使用）。mach_port大家就理解成进程间相互发送消息的一种机制就好, 比如屏幕点击, 网络数据的传输都会触发sourse1。<br>• Source0 ：非基于Port的 处理事件，什么叫非基于Port的呢？就是说你这个消息不是其他进程或者内核直接发送给你的。一般是APP内部的事件, 比如hitTest:withEvent的处理, performSelectors的事件.</p><p>简单举个例子：一个APP在前台静止着，此时，用户用手指点击了一下APP界面，那么过程就是下面这样的：</p><p>我们触摸屏幕,先摸到硬件(屏幕)，屏幕表面的事件会被IOKit先包装成Event,通过mach_Port传给正在活跃的APP , Event先告诉source1（mach_port）,source1唤醒RunLoop, 然后将事件Event分发给source0,然后由source0来处理。<br>如果没有事件,也没有timer,则runloop就会睡眠, 如果有,则runloop就会被唤醒,然后跑一圈。</p><h2 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h2><p>是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p><ul><li>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</li><li>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; CFRunLoop.h</span><br><span class="line">typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef;</span><br><span class="line">&#x2F;&#x2F; CFRunLoop.c</span><br><span class="line">struct __CFRunLoopTimer &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    uint16_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;           &#x2F;&#x2F; 添加该 timer 的 RunLoop</span><br><span class="line">    CFMutableSetRef _rlModes;        &#x2F;&#x2F; 所有包含该 timer 的 modeName</span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    CFTimeInterval _interval;        &#x2F;* immutable 理想时间间隔 *&#x2F;    </span><br><span class="line">    CFTimeInterval _tolerance;       &#x2F;* mutable 时间偏差 *&#x2F;  </span><br><span class="line">    uint64_t _fireTSR;                 &#x2F;* TSR units *&#x2F;</span><br><span class="line">    CFIndex _order;                  &#x2F;* immutable *&#x2F;</span><br><span class="line">    CFRunLoopTimerCallBack _callout; &#x2F;* immutable 回调入口 *&#x2F;</span><br><span class="line">    CFRunLoopTimerContext _context;  &#x2F;* immutable, except invalidation *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。<br>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><h2 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h2><p><code>CFRunLoopObserverRef</code>是观察者，每个Observer都包含一个回调（函数指针），当RunLoop的状态发生变化时，观察者就能通过回调接受到这个变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopObserver &#123;</span><br><span class="line">      ...</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFOptionFlags _activities; &#x2F;&#x2F; 生命周期    &#x2F;* immutable *&#x2F;</span><br><span class="line">    CFIndex _order; &#x2F;&#x2F; 优先级                            &#x2F;* immutable *&#x2F;</span><br><span class="line">    CFRunLoopObserverCallBack _callout;        &#x2F;* immutable *&#x2F;</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 CFOptionFlags 定义了 RunLoop 的生命周期活动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Run Loop Observer Activities *&#x2F;</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         &#x3D; (1UL &lt;&lt; 0), &#x2F;&#x2F; 即将进入 RunLoop</span><br><span class="line">    kCFRunLoopBeforeTimers  &#x3D; (1UL &lt;&lt; 1), &#x2F;&#x2F; 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2), &#x2F;&#x2F; 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5), &#x2F;&#x2F; 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  &#x3D; (1UL &lt;&lt; 6), &#x2F;&#x2F; 刚从休眠被唤醒</span><br><span class="line">    kCFRunLoopExit          &#x3D; (1UL &lt;&lt; 7), &#x2F;&#x2F; 即将退出 RunLoop</span><br><span class="line">    kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU &#x2F;&#x2F; 任意上述活动</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>CFRunLoopObserverRef</code>中的<code>_activities</code>用来保存<code>RunLoop</code>的活动状态。当<code>RunLoop</code>的状态发生改变时，通过回调<code>_callout</code>通知所有监听这个状态的<code>Observer</code>。</p><h1 id="三、RunLoop-内部逻辑"><a href="#三、RunLoop-内部逻辑" class="headerlink" title="三、RunLoop 内部逻辑"></a>三、RunLoop 内部逻辑</h1><p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">文档</a>里的说明，RunLoop 内部的逻辑大致如下:</p><img src="RunLoop-Part1/RunLoop3.png" alt="RunLoop3" style="zoom: 50%;" align="left" /><h2 id="CFRunLoopRun-函数实现：事件循环的实现机制"><a href="#CFRunLoopRun-函数实现：事件循环的实现机制" class="headerlink" title="__CFRunLoopRun 函数实现：事件循环的实现机制"></a>__CFRunLoopRun 函数实现：事件循环的实现机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;&#x2F; 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;&#x2F; RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode &#x3D; __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 如果mode里没有source&#x2F;timer&#x2F;observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; NO;</span><br><span class="line">        int retVal &#x3D; 0;</span><br><span class="line">        do &#123;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg &#x3D; __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            &#x2F;&#x2F;&#x2F; • 一个基于 port 的Source 的事件。</span><br><span class="line">            &#x2F;&#x2F;&#x2F; • 一个 Timer 到时间了</span><br><span class="line">            &#x2F;&#x2F;&#x2F; • RunLoop 自身的超时时间到了</span><br><span class="line">            &#x2F;&#x2F;&#x2F; • 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); &#x2F;&#x2F; thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 &#x3D; __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 超出传入参数标记的超时时间了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 被外部调用者强制停止了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; source&#x2F;timer&#x2F;observer一个都没有了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal &#x3D;&#x3D; 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。<br>从该函数实现中可以得知<code>RunLoop</code>主要就做一下几件事情：</p><ul><li>__CFRunLoopDoObservers：通知<code>Observers</code>接下来要做什么</li><li>__CFRunLoopDoBlocks：处理<code>Blocks</code></li><li>__CFRunLoopDoSources0：处理<code>Sources0</code></li><li>__CFRunLoopDoSources1：处理<code>Sources1</code></li><li>__CFRunLoopDoTimers：处理<code>Timers</code></li><li>处理 GCD 相关：<code>dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;);</code></li><li>__CFRunLoopSetSleeping / _CFRunLoopUnsetSleeping：休眠等待/结束休眠</li><li>__CFRunLoopServiceMachPort -&gt; mach-msg()：转移当前线程的控制权</li></ul><h2 id="CFRunLoopServiceMachPort-函数实现：RunLoop-休眠的实现原理"><a href="#CFRunLoopServiceMachPort-函数实现：RunLoop-休眠的实现原理" class="headerlink" title="__CFRunLoopServiceMachPort 函数实现：RunLoop 休眠的实现原理"></a>__CFRunLoopServiceMachPort 函数实现：RunLoop 休眠的实现原理</h2><p>在<code>__CFRunLoopRun</code>函数中，会调用<code>__CFRunLoopServiceMachPort</code>函数，该函数中调用了<code>mach_msg()</code>函数来转移当前线程的控制权给内核态/用户态。</p><ul><li>没有消息需要处理时，休眠线程以避免资源占用。调用<code>mach_msg()</code>从用户态切换到内核态，等待消息；</li><li>有消息需要处理时，立即唤醒线程，调用<code>mach_msg()</code>回到用户态处理消息。</li></ul><p>这就是<code>RunLoop</code>休眠的实现原理，也是<code>RunLoop</code>与简单的<code>do...while</code>循环的区别：</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> iOS进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> RunLoop </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runtime - 进阶篇</title>
      <link href="2021/11/02/Runtime-Part2/"/>
      <url>2021/11/02/Runtime-Part2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-动态方法交换：Method-Swizzling"><a href="#1-动态方法交换：Method-Swizzling" class="headerlink" title="1. 动态方法交换：Method Swizzling"></a>1. 动态方法交换：Method Swizzling</h1><p>实现动态方法交换(Method Swizzling )是Runtime中最具盛名的应用场景，其原理是：通过Runtime获取到方法实现的地址，进而动态交换两个方法的功能。使用到关键方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取类方法的Mthod</span></span><br><span class="line"><span class="type">Method</span> _Nullable class_getClassMethod(<span class="type">Class</span> _Nullable cls, <span class="type">SEL</span> _Nonnull name)</span><br><span class="line"><span class="comment">//获取实例对象方法的Mthod</span></span><br><span class="line"><span class="type">Method</span> _Nullable class_getInstanceMethod(<span class="type">Class</span> _Nullable cls, <span class="type">SEL</span> _Nonnull name)</span><br><span class="line"><span class="comment">//交换两个方法的实现</span></span><br><span class="line">void method_exchangeImplementations(<span class="type">Method</span> _Nonnull m1, <span class="type">Method</span> _Nonnull m2)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-1-动态方法交换示例"><a href="#1-1-动态方法交换示例" class="headerlink" title="1.1 动态方法交换示例"></a>1.1 动态方法交换示例</h2><p>现在演示一个代码示例：在视图控制中，定义两个实例方法printA与printB，然后执行交换</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)printA&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印A......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printB&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印B......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换方法的实现，并测试打印</span></span><br><span class="line"><span class="type">Method</span> methodA = class_getInstanceMethod([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">printA</span>));</span></span><br><span class="line"><span class="class"><span class="title">Method</span> <span class="title">methodB</span> = <span class="title">class_getInstanceMethod</span>([<span class="title">self</span> <span class="title">class</span>], @<span class="title">selector</span>(<span class="title">printB</span>));</span></span><br><span class="line"><span class="class"><span class="title">method_exchangeImplementations</span>(<span class="title">methodA</span>, <span class="title">methodB</span>);</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">[<span class="title">self</span> <span class="title">printA</span>];  //打印<span class="title">B</span>......</span></span><br><span class="line"><span class="class">[<span class="title">self</span> <span class="title">printB</span>];  //打印<span class="title">A</span>......</span></span><br></pre></td></tr></table></figure><h2 id="1-2-拦截并替换系统方法"><a href="#1-2-拦截并替换系统方法" class="headerlink" title="1.2 拦截并替换系统方法"></a>1.2 拦截并替换系统方法</h2><p>Runtime动态方法交换更多的是应用于系统类库和第三方框架的方法替换。在不可见源码的情况下，我们可以借助Rutime交换方法实现，为原有方法添加额外功能，这在实际开发中具有十分重要的意义。</p><p>下面将展示一个拦截并替换系统方法的示例：为了实现不同机型上的字体都按照比例适配，我们可以拦截系统UIFont的systemFontOfSize方法，具体操作如下：</p><h3 id="步骤1：在当前工程中添加UIFont的分类：UIFont-Adapt-并在其中添用以替换的方法。"><a href="#步骤1：在当前工程中添加UIFont的分类：UIFont-Adapt-并在其中添用以替换的方法。" class="headerlink" title="步骤1：在当前工程中添加UIFont的分类：UIFont +Adapt,并在其中添用以替换的方法。"></a>步骤1：在当前工程中添加UIFont的分类：UIFont +Adapt,并在其中添用以替换的方法。</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIFont</span> *)zs_systemFontOfSize:(<span class="built_in">CGFloat</span>)fontSize&#123;</span><br><span class="line">    <span class="comment">//获取设备屏幕宽度，并计算出比例scale</span></span><br><span class="line">    <span class="built_in">CGFloat</span> width = [[<span class="built_in">UIScreen</span> mainScreen] bounds].size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> scale  = width/<span class="number">375.0</span>;</span><br><span class="line">    <span class="comment">//注意：由于方法交换，系统的方法名已变成了自定义的方法名，所以这里使用了</span></span><br><span class="line">    <span class="comment">//自定义的方法名来获取UIFont</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIFont</span> zs_systemFontOfSize:fontSize * scale];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤2：在UIFont的分类中拦截系统方法，将其替换为我们自定义的方法，代码如下："><a href="#步骤2：在UIFont的分类中拦截系统方法，将其替换为我们自定义的方法，代码如下：" class="headerlink" title="步骤2：在UIFont的分类中拦截系统方法，将其替换为我们自定义的方法，代码如下："></a>步骤2：在UIFont的分类中拦截系统方法，将其替换为我们自定义的方法，代码如下：</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//load方法不需要手动调用，iOS会在应用程序启动的时候自动调起load方法，而且执行时间较早，所以在此方法中执行交换操作比较合适。</span></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    <span class="comment">//获取系统方法地址</span></span><br><span class="line">    <span class="type">Method</span> sytemMethod = class_getClassMethod([<span class="type">UIFont</span> <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">systemFontOfSize</span>:));</span></span><br><span class="line"><span class="class">    //获取自定义方法地址</span></span><br><span class="line"><span class="class">    <span class="title">Method</span> <span class="title">customMethod</span> = <span class="title">class_getClassMethod</span>([<span class="title">UIFont</span> <span class="title">class</span>], @<span class="title">selector</span>(<span class="title">zs_systemFontOfSize</span>:));</span></span><br><span class="line"><span class="class">    //交换两个方法的实现</span></span><br><span class="line"><span class="class">    <span class="title">method_exchangeImplementations</span>(<span class="title">sytemMethod</span>, <span class="title">customMethod</span>);</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>添加一段测试代码，切换不同的模拟器，观察在不同机型上文字的大小：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UILabel</span> *label = [[<span class="type">UILabel</span> alloc] initWithFrame:<span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">50</span>)];</span><br><span class="line">label.text = @<span class="string">&quot;测试Runtime拦截方法&quot;</span>;</span><br><span class="line">label.font = [<span class="type">UIFont</span> systemFontOfSize:<span class="number">20</span>];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:label];</span><br></pre></td></tr></table></figure><h1 id="2-实现分类添加新属性"><a href="#2-实现分类添加新属性" class="headerlink" title="2. 实现分类添加新属性"></a>2. 实现分类添加新属性</h1><p>我们在开发中常常使用类目Category为一些已有的类扩展功能。虽然继承也能够为已有类增加新的方法，而且相比类目更是具有增加属性的优势，但是继承毕竟是一个重量级的操作，添加不必要的继承关系无疑增加了代码的复杂度。</p><p>遗憾的是，OC的类目并不支持直接添加属性，如果我们直接在分类的声明中写入Property属性，那么只能为其生成set与get方法声明，却不能生成成员变量，直接调用这些属性还会造成崩溃。</p><p>所以为了实现给分类添加属性，我们还需借助Runtime的**关联对象(Associated Objects)**特性，它能够帮助我们在运行阶段将任意的属性关联到一个对象上，下面是相关的三个方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1.给对象设置关联属性</span></span><br><span class="line"><span class="comment"> @param object 需要设置关联属性的对象，即给哪个对象关联属性</span></span><br><span class="line"><span class="comment"> @param key 关联属性对应的key，可通过key获取这个属性，</span></span><br><span class="line"><span class="comment"> @param value 给关联属性设置的值</span></span><br><span class="line"><span class="comment"> @param policy 关联属性的存储策略(对应Property属性中的assign,copy，retain等)</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_ASSIGN             @property(assign)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_RETAIN_NONATOMIC   @property(strong, nonatomic)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_COPY_NONATOMIC     @property(copy, nonatomic)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_RETAIN             @property(strong,atomic)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_COPY               @property(copy, atomic)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void objc_setAssociatedObject(id _Nonnull object,</span><br><span class="line">                              const void * _Nonnull key,</span><br><span class="line">                              id _Nullable value,</span><br><span class="line">                              objc_AssociationPolicy policy)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2.通过key获取关联的属性</span></span><br><span class="line"><span class="comment"> @param object 从哪个对象中获取关联属性</span></span><br><span class="line"><span class="comment"> @param key 关联属性对应的key</span></span><br><span class="line"><span class="comment"> @return 返回关联属性的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">id _Nullable objc_getAssociatedObject(id _Nonnull object,</span><br><span class="line">                                      const void * _Nonnull key)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 3.移除对象所关联的属性</span></span><br><span class="line"><span class="comment"> @param object 移除某个对象的所有关联属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void objc_removeAssociatedObjects(id _Nonnull object)</span><br></pre></td></tr></table></figure><p>注意：key与关联属性一一对应，我们必须确保其全局唯一性，常用我们使用@selector(methodName)作为key。</p><p>现在演示一个代码示例：为UIImage增加一个分类：UIImage+Tools，并为其设置关联属性urlString(图片网络链接属性），相关代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UIImage+Tools.h文件中</span></span><br><span class="line"><span class="type">UIImage</span>+<span class="type">Tools</span>.m</span><br><span class="line">@interface <span class="type">UIImage</span> (<span class="type">Tools</span>)</span><br><span class="line"><span class="comment">//添加一个新属性：图片网络链接</span></span><br><span class="line">@property(nonatomic,copy)<span class="type">NSString</span> *urlString;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UIImage+Tools.m文件中</span></span><br><span class="line">#<span class="keyword">import</span> &quot;UIImage+Tools.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line">@implementation <span class="type">UIImage</span> (<span class="type">Tools</span>)</span><br><span class="line"><span class="comment">//set方法</span></span><br><span class="line">- (void)setUrlString:(<span class="type">NSString</span> *)urlString&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>,</span><br><span class="line">                             @selector(urlString),</span><br><span class="line">                             urlString,</span><br><span class="line">                             <span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line">- (<span class="type">NSString</span> *)urlString&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>,</span><br><span class="line">                                    @selector(urlString));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加一个自定义方法，用于清除所有关联属性</span></span><br><span class="line">- (void)clearAssociatedObjcet&#123;</span><br><span class="line">    objc_removeAssociatedObjects(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>测试文件中:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIImage</span> *image = [[<span class="type">UIImage</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">image.urlString = @<span class="string">&quot;http://www.image.png&quot;</span>;</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;获取关联属性：%@&quot;</span>,image.urlString);</span><br><span class="line">    </span><br><span class="line">[image clearAssociatedObjcet];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;获取关联属性：%@&quot;</span>,image.urlString);</span><br><span class="line"><span class="comment">//打印：</span></span><br><span class="line"><span class="comment">//获取关联属性：http://www.image.png</span></span><br><span class="line"><span class="comment">// 获取关联属性：(null)</span></span><br></pre></td></tr></table></figure><h1 id="3-获取类的详细信息"><a href="#3-获取类的详细信息" class="headerlink" title="3. 获取类的详细信息"></a>3. 获取类的详细信息</h1><h2 id="3-1-获取属性列表"><a href="#3-1-获取属性列表" class="headerlink" title="3.1 获取属性列表"></a>3.1 获取属性列表</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unsigned int <span class="built_in">count</span>;</span><br><span class="line">objc_property_t *propertyList = class_copyPropertyList([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], &amp;<span class="title">count</span>);</span></span><br><span class="line"><span class="class"><span class="title">for</span> (<span class="title">unsigned</span> <span class="title">int</span> <span class="title">i</span> = 0; <span class="title">i</span>&lt;<span class="title">count</span>; <span class="title">i</span>++) </span>&#123;</span><br><span class="line">    const char *propertyName = property_getName(propertyList[i]);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;PropertyName(%d): %@&quot;</span>,i,[<span class="type">NSString</span> stringWithUTF8String:propertyName]);</span><br><span class="line">&#125;</span><br><span class="line">free(propertyList);</span><br></pre></td></tr></table></figure><h2 id="3-2-获取所有成员变量"><a href="#3-2-获取所有成员变量" class="headerlink" title="3.2 获取所有成员变量"></a>3.2 获取所有成员变量</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Ivar</span> *ivarList = class_copyIvarList([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], &amp;<span class="title">count</span>);</span></span><br><span class="line"><span class="class"><span class="title">for</span> (<span class="title">int</span> <span class="title">i</span>= 0; <span class="title">i</span>&lt;<span class="title">count</span>; <span class="title">i</span>++) </span>&#123;</span><br><span class="line">    <span class="type">Ivar</span> ivar = ivarList[i];</span><br><span class="line">    const char *ivarName = ivar_getName(ivar);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Ivar(%d): %@&quot;</span>, i, [<span class="type">NSString</span> stringWithUTF8String:ivarName]);</span><br><span class="line">&#125;</span><br><span class="line">free(ivarList);</span><br></pre></td></tr></table></figure><h2 id="3-3-获取所有方法"><a href="#3-3-获取所有方法" class="headerlink" title="3.3 获取所有方法"></a>3.3 获取所有方法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> *methodList = class_copyMethodList([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], &amp;<span class="title">count</span>);</span></span><br><span class="line"><span class="class"><span class="title">for</span> (<span class="title">unsigned</span> <span class="title">int</span> <span class="title">i</span> = 0; <span class="title">i</span>&lt;<span class="title">count</span>; <span class="title">i</span>++) </span>&#123;</span><br><span class="line">    <span class="type">Method</span> method = methodList[i];</span><br><span class="line">    <span class="type">SEL</span> mthodName = method_getName(method);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;MethodName(%d): %@&quot;</span>,i,<span class="type">NSStringFromSelector</span>(mthodName));</span><br><span class="line">&#125;</span><br><span class="line">free(methodList);</span><br></pre></td></tr></table></figure><h2 id="3-4-获取当前遵循的所有协议"><a href="#3-4-获取当前遵循的所有协议" class="headerlink" title="3.4 获取当前遵循的所有协议"></a>3.4 获取当前遵循的所有协议</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__unsafe_unretained <span class="type">Protocol</span> **protocolList = class_copyProtocolList([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], &amp;<span class="title">count</span>);</span></span><br><span class="line"><span class="class"><span class="title">for</span> (<span class="title">int</span> <span class="title">i</span>=0; <span class="title">i</span>&lt;<span class="title">count</span>; <span class="title">i</span>++) </span>&#123;</span><br><span class="line">    <span class="type">Protocol</span> *protocal = protocolList[i];</span><br><span class="line">    const char *protocolName = protocol_getName(protocal);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;protocol(%d): %@&quot;</span>,i, [<span class="type">NSString</span> stringWithUTF8String:protocolName]);</span><br><span class="line">&#125;</span><br><span class="line">free(propertyList);</span><br></pre></td></tr></table></figure><p><strong>注意：C语言中使用Copy操作的方法，要注意释放指针，防止内存泄漏</strong></p><h1 id="4-解决同一方法高频率调用的效率问题"><a href="#4-解决同一方法高频率调用的效率问题" class="headerlink" title="4. 解决同一方法高频率调用的效率问题"></a>4. 解决同一方法高频率调用的效率问题</h1><p>Runtime源码中的IMP作为函数指针，指向方法的实现。通过它，我们可以绕开发送消息的过程来提高函数调用的效率。当我们需要持续大量重复调用某个方法的时候，会十分有用，具体代码示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, <span class="type">SEL</span>, <span class="type">BOOL</span>);</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">setter = (void (*)(id, <span class="type">SEL</span>, <span class="type">BOOL</span>))[target methodForSelector:@selector(setFilled:)];</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), <span class="type">YES</span>);</span><br></pre></td></tr></table></figure><h1 id="5-方法动态解析与消息转发"><a href="#5-方法动态解析与消息转发" class="headerlink" title="5. 方法动态解析与消息转发"></a>5. 方法动态解析与消息转发</h1><p>其实该部分可以参考基础篇中内容，这里不再重复赘述，只是大概做出一些总结。</p><h2 id="5-1-动态方法解析：动态添加方法"><a href="#5-1-动态方法解析：动态添加方法" class="headerlink" title="5.1 动态方法解析：动态添加方法"></a>5.1 动态方法解析：动态添加方法</h2><p>Runtime足够强大，能够让我们在运行时动态添加一个未实现的方法，这个功能主要有两个应用场景：<br> <strong>场景1</strong>：动态添加未实现方法，解决代码中因为方法未找到而报错的问题；<br> <strong>场景2</strong>：利用懒加载思路，若一个类有很多个方法，同时加载到内存中会耗费资源，可以使用动态解析添加方法。方法动态解析主要用到的方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OC方法：</span></span><br><span class="line"><span class="comment">//类方法未找到时调起，可于此添加类方法实现</span></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveClassMethod:(<span class="type">SEL</span>)sel</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例方法未找到时调起，可于此添加实例方法实现</span></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(<span class="type">SEL</span>)sel</span><br><span class="line"></span><br><span class="line"><span class="comment">//Runtime方法：</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 运行时方法：向指定类中添加特定方法实现的操作</span></span><br><span class="line"><span class="comment"> @param cls 被添加方法的类</span></span><br><span class="line"><span class="comment"> @param name selector方法名</span></span><br><span class="line"><span class="comment"> @param imp 指向实现方法的函数指针</span></span><br><span class="line"><span class="comment"> @param types imp函数实现的返回值与参数类型</span></span><br><span class="line"><span class="comment"> @return 添加方法是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">BOOL</span> class_addMethod(<span class="type">Class</span> _Nullable cls,</span><br><span class="line">                     <span class="type">SEL</span> _Nonnull name,</span><br><span class="line">                     <span class="type">IMP</span> _Nonnull imp,</span><br><span class="line">                     const char * _Nullable types)</span><br></pre></td></tr></table></figure><h2 id="5-2-解决方法无响应崩溃问题"><a href="#5-2-解决方法无响应崩溃问题" class="headerlink" title="5.2 解决方法无响应崩溃问题"></a>5.2 解决方法无响应崩溃问题</h2><p>执行OC方法其实就是一个发送消息的过程，若方法未实现，我们可以利用方法动态解析与消息转发来避免程序崩溃，这主要涉及下面一个处理未实现消息的过程：</p><img src="/2021/11/02/Runtime-Part2/lct.png" class="" title="消息转发流程图"><p>除了上述的方法动态解析，还使用到的相关方法如下：<br> 消息接收者重定向</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定向类方法的消息接收者，返回一个类</span></span><br><span class="line">- (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向实例方法的消息接受者，返回一个实例对象</span></span><br><span class="line">- (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector</span><br></pre></td></tr></table></figure><p>消息重定向</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(<span class="type">NSInvocation</span> *)anInvocation；</span><br><span class="line"></span><br><span class="line">- (<span class="type">NSMethodSignature</span>*)methodSignatureForSelector:(<span class="type">SEL</span>)aSelector;</span><br></pre></td></tr></table></figure><h1 id="6-动态操作属性"><a href="#6-动态操作属性" class="headerlink" title="6. 动态操作属性"></a>6. 动态操作属性</h1><h2 id="6-1-动态修改属性变量"><a href="#6-1-动态修改属性变量" class="headerlink" title="6.1 动态修改属性变量"></a>6.1 动态修改属性变量</h2><p>现在假设这样一个情况：我们使用第三方框架里的Person类，在特殊需求下想要更改其私有属性nickName，这样的操作我们就可以使用Runtime可以动态修改对象属性。</p><p>基本思路：首先使用Runtime获取Peson对象的所有属性，找到nickName，然后使用ivar的方法修改其值。具体的代码示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> *ps = [[<span class="type">Person</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;ps-nickName: %@&quot;</span>,[ps valueForKey:@<span class="string">&quot;nickName&quot;</span>]); <span class="comment">//null</span></span><br><span class="line"><span class="comment">//第一步：遍历对象的所有属性</span></span><br><span class="line">unsigned int <span class="built_in">count</span>;</span><br><span class="line"><span class="type">Ivar</span> *ivarList = class_copyIvarList([ps <span class="class"><span class="keyword">class</span>], &amp;<span class="title">count</span>);</span></span><br><span class="line"><span class="class"><span class="title">for</span> (<span class="title">int</span> <span class="title">i</span>= 0; <span class="title">i</span>&lt;<span class="title">count</span>; <span class="title">i</span>++) </span>&#123;</span><br><span class="line">    <span class="comment">//第二步：获取每个属性名</span></span><br><span class="line">    <span class="type">Ivar</span> ivar = ivarList[i];</span><br><span class="line">    const char *ivarName = ivar_getName(ivar);</span><br><span class="line">    <span class="type">NSString</span> *propertyName = [<span class="type">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">    <span class="keyword">if</span> ([propertyName isEqualToString:@<span class="string">&quot;_nickName&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">//第三步：匹配到对应的属性，然后修改；注意属性带有下划线</span></span><br><span class="line">        object_setIvar(ps, ivar, @<span class="string">&quot;梧雨北辰&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;ps-nickName: %@&quot;</span>,[ps valueForKey:@<span class="string">&quot;nickName&quot;</span>]); <span class="comment">//梧雨北辰</span></span><br></pre></td></tr></table></figure><p>总结：此过程类似KVC的取值和赋值</p><h2 id="6-2-实现-NSCoding-的自动归档和解档"><a href="#6-2-实现-NSCoding-的自动归档和解档" class="headerlink" title="6.2 实现 NSCoding 的自动归档和解档"></a>6.2 实现 NSCoding 的自动归档和解档</h2><p>归档是一种常用的轻量型文件存储方式，但是它有个弊端：在归档过程中，若一个Model有多个属性，我们不得不对每个属性进行处理，非常繁琐。<br> 归档操作主要涉及两个方法：encodeObject 和 decodeObjectForKey，现在，我们可以利用Runtime来改进它们，关键的代码示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原理：使用Runtime动态获取所有属性</span></span><br><span class="line"><span class="comment">//解档操作</span></span><br><span class="line">- (instancetype)initWithCoder:(<span class="type">NSCoder</span> *)aDecoder&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        unsigned int <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Ivar</span> *ivarList = class_copyIvarList([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], &amp;<span class="title">count</span>);</span></span><br><span class="line"><span class="class">        <span class="title">for</span> (<span class="title">int</span> <span class="title">i</span> = 0; <span class="title">i</span> &lt; <span class="title">count</span>; <span class="title">i</span>++) </span>&#123;</span><br><span class="line">            <span class="type">Ivar</span> ivar = ivarList[i];</span><br><span class="line">            const char *ivarName = ivar_getName(ivar);</span><br><span class="line">            <span class="type">NSString</span> *key = [<span class="type">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">            id value = [aDecoder decodeObjectForKey:key];</span><br><span class="line">            [<span class="keyword">self</span> setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivarList); <span class="comment">//释放指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归档操作</span></span><br><span class="line">- (void)encodeWithCoder:(<span class="type">NSCoder</span> *)aCoder&#123;</span><br><span class="line">    unsigned int <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Ivar</span> *ivarList = class_copyIvarList([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], &amp;<span class="title">count</span>);</span></span><br><span class="line"><span class="class">    <span class="title">for</span> (<span class="title">NSInteger</span> <span class="title">i</span> = 0; <span class="title">i</span> &lt; <span class="title">count</span>; <span class="title">i</span>++) </span>&#123;</span><br><span class="line">        <span class="type">Ivar</span> ivar = ivarList[i];</span><br><span class="line">        <span class="type">NSString</span> *key = [<span class="type">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        </span><br><span class="line">        id value = [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line">        [aCoder encodeObject:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivarList); <span class="comment">//释放指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是有关归档的测试代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--测试归档</span></span><br><span class="line"><span class="type">Person</span> *ps = [[<span class="type">Person</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">ps.name = @<span class="string">&quot;梧雨北辰&quot;</span>;</span><br><span class="line">ps.age  = <span class="number">18</span>;</span><br><span class="line"><span class="type">NSString</span> *temp = <span class="type">NSTemporaryDirectory</span>();</span><br><span class="line"><span class="type">NSString</span> *fileTemp = [temp stringByAppendingString:@<span class="string">&quot;person.archive&quot;</span>];</span><br><span class="line">[<span class="type">NSKeyedArchiver</span> archiveRootObject:ps toFile:fileTemp];</span><br><span class="line"></span><br><span class="line"><span class="comment">//--测试解档</span></span><br><span class="line"><span class="type">NSString</span> *temp = <span class="type">NSTemporaryDirectory</span>();</span><br><span class="line"><span class="type">NSString</span> *fileTemp = [temp stringByAppendingString:@<span class="string">&quot;person.henry&quot;</span>];</span><br><span class="line"><span class="type">Person</span> *person = [<span class="type">NSKeyedUnarchiver</span> unarchiveObjectWithFile:fileTemp];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;person-name:%@，person-age:%ld&quot;</span>,person.name,person.age); </span><br><span class="line"><span class="comment">//person-name:梧雨北辰，person-age:18</span></span><br></pre></td></tr></table></figure><h2 id="6-3-实现字典与模型的转换"><a href="#6-3-实现字典与模型的转换" class="headerlink" title="6.3 实现字典与模型的转换"></a>6.3 实现字典与模型的转换</h2><p>字典数据转模型的操作在项目开发中很常见，通常我们会选择第三方如YYModel；其实我们也可以自己来实现这一功能，主要的思路有两种：KVC、Runtime，总结字典转化模型过程中需要解决的问题如下：</p><img src="/2021/11/02/Runtime-Part2/zdzmx.png" class="" title="字典转模型"><p>现在，我们使用Runtime来实现字典转模型的操作，大致的思路是这样：<br> <strong><em>借助Runtime可以动态获取成员列表的特性，遍历模型中所有属性，然后以获取到的属性名为key，在JSON字典中寻找对应的值value；再将每一个对应Value赋值给模型，就完成了字典转模型的目的\</em></strong>。</p><p>首先准备下面的JSON数据用于测试：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;2462079046&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;梧雨北辰&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;weight&quot;</span>:<span class="number">140</span>,</span><br><span class="line">    <span class="attr">&quot;address&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;country&quot;</span>:<span class="string">&quot;中国&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;province&quot;</span>: <span class="string">&quot;河南&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">    <span class="attr">&quot;courses&quot;</span>:[&#123;</span><br><span class="line">               <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Chinese&quot;</span>,</span><br><span class="line">               <span class="attr">&quot;desc&quot;</span>:<span class="string">&quot;语文课&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">               <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Math&quot;</span>,</span><br><span class="line">               <span class="attr">&quot;desc&quot;</span>:<span class="string">&quot;数学课&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">               <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;English&quot;</span>,</span><br><span class="line">               <span class="attr">&quot;desc&quot;</span>:<span class="string">&quot;英语课&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的代码实现流程如下：</p><h3 id="步骤1：创建NSObject的类目NSObject-ZSModel，用于实现字典转模型"><a href="#步骤1：创建NSObject的类目NSObject-ZSModel，用于实现字典转模型" class="headerlink" title="步骤1：创建NSObject的类目NSObject+ZSModel，用于实现字典转模型"></a>步骤1：创建NSObject的类目NSObject+ZSModel，用于实现字典转模型</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface <span class="type">NSObject</span> (<span class="type">ZSModel</span>)</span><br><span class="line">+ (instancetype)zs_modelWithDictionary:(<span class="type">NSDictionary</span> *)dictionary;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="comment">//ZSModel协议，协议方法可以返回一个字典，表明特殊字段的处理规则</span></span><br><span class="line">@<span class="class"><span class="keyword">protocol</span> <span class="title">ZSModel</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="class">@<span class="title">optional</span></span></span><br><span class="line"><span class="class">+ (<span class="title">nullable</span> <span class="title">NSDictionary</span>&lt;<span class="title">NSString</span> *, <span class="title">id</span>&gt; *)<span class="title">modelContainerPropertyGenericClass</span>;</span></span><br><span class="line"><span class="class">@<span class="title">end</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &quot;NSObject+ZSModel.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line">@implementation <span class="type">NSObject</span> (<span class="type">ZSModel</span>)</span><br><span class="line">+ (instancetype)zs_modelWithDictionary:(<span class="type">NSDictionary</span> *)dictionary&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建当前模型对象</span></span><br><span class="line">    id object = [[<span class="keyword">self</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="comment">//1.获取当前对象的成员变量列表</span></span><br><span class="line">    unsigned int <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">Ivar</span> *ivarList = class_copyIvarList([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], &amp;<span class="title">count</span>);</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    //2.遍历<span class="title">ivarList</span>中所有成员变量，以其属性名为<span class="title">key</span>，在字典中查找<span class="title">Value</span></span></span><br><span class="line"><span class="class">    <span class="title">for</span> (<span class="title">int</span> <span class="title">i</span>= 0; <span class="title">i</span>&lt;<span class="title">count</span>; <span class="title">i</span>++) </span>&#123;</span><br><span class="line">        <span class="comment">//2.1获取成员属性</span></span><br><span class="line">        <span class="type">Ivar</span> ivar = ivarList[i];</span><br><span class="line">        <span class="type">NSString</span> *ivarName = [<span class="type">NSString</span> stringWithUTF8String:ivar_getName(ivar)] ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.2截取成员变量名：去掉成员变量前面的&quot;_&quot;号</span></span><br><span class="line">        <span class="type">NSString</span> *propertyName = [ivarName substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.3以属性名为key，在字典中查找value</span></span><br><span class="line">        id value = dictionary[propertyName];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取成员变量类型, 因为ivar_getTypeEncoding获取的类型是&quot;@\&quot;NSString\&quot;&quot;的形式</span></span><br><span class="line">        <span class="comment">//所以我们要做以下的替换</span></span><br><span class="line">        <span class="type">NSString</span> *ivarType = [<span class="type">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];<span class="comment">// 替换:</span></span><br><span class="line">        <span class="comment">//3.1去除转义字符：@\&quot;name\&quot; -&gt; @&quot;name&quot;</span></span><br><span class="line">        ivarType = [ivarType stringByReplacingOccurrencesOfString:@<span class="string">&quot;\&quot;&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">        <span class="comment">//3.2去除@符号</span></span><br><span class="line">        ivarType = [ivarType stringByReplacingOccurrencesOfString:@<span class="string">&quot;@&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.对特殊成员变量进行处理：</span></span><br><span class="line">        <span class="comment">//判断当前类是否实现了协议方法，获取协议方法中规定的特殊变量的处理方式</span></span><br><span class="line">        <span class="type">NSDictionary</span> *perpertyTypeDic;</span><br><span class="line">        <span class="keyword">if</span>([<span class="keyword">self</span> respondsToSelector:@selector(modelContainerPropertyGenericClass)])&#123;</span><br><span class="line">            perpertyTypeDic = [<span class="keyword">self</span> performSelector:@selector(modelContainerPropertyGenericClass) withObject:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.1处理：字典的key与模型属性不匹配的问题，如id-&gt;uid</span></span><br><span class="line">        id anotherName = perpertyTypeDic[propertyName];</span><br><span class="line">        <span class="keyword">if</span>(anotherName &amp;&amp; [anotherName isKindOfClass:[<span class="type">NSString</span> <span class="class"><span class="keyword">class</span>]])</span>&#123;</span><br><span class="line">            value =  dictionary[anotherName];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.2.处理：模型嵌套模型</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="type">NSDictionary</span> <span class="class"><span class="keyword">class</span>]] &amp;&amp; ![<span class="title">ivarType</span> <span class="title">hasPrefix</span>:@&quot;<span class="title">NS</span>&quot;]) </span>&#123;</span><br><span class="line">            <span class="type">Class</span> modelClass = <span class="type">NSClassFromString</span>(ivarType);</span><br><span class="line">            <span class="keyword">if</span> (modelClass != <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="comment">//将被嵌套字典数据也转化成Model</span></span><br><span class="line">                value = [modelClass zs_modelWithDictionary:value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.3处理：模型嵌套模型数组</span></span><br><span class="line">        <span class="comment">//判断当前Vaue是一个数组，而且存在协议方法返回了perpertyTypeDic</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="type">NSArray</span> <span class="class"><span class="keyword">class</span>]] &amp;&amp; <span class="title">perpertyTypeDic</span>) </span>&#123;</span><br><span class="line">            <span class="type">Class</span> itemModelClass = perpertyTypeDic[propertyName];</span><br><span class="line">            <span class="comment">//封装数组：将每一个子数据转化为Model</span></span><br><span class="line">            <span class="type">NSMutableArray</span> *itemArray = @[].mutableCopy;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">NSDictionary</span> *itemDic  <span class="keyword">in</span> value) &#123;</span><br><span class="line">                id model = [itemModelClass zs_modelWithDictionary:itemDic];</span><br><span class="line">                [itemArray addObject:model];</span><br><span class="line">            &#125;</span><br><span class="line">            value = itemArray;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.使用KVC方法将Vlue更新到object中</span></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">nil</span>) &#123;</span><br><span class="line">            [object setValue:value forKey:propertyName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivarList); <span class="comment">//释放C指针</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="步骤2：分别创建各个数据模型Student、Address、Course"><a href="#步骤2：分别创建各个数据模型Student、Address、Course" class="headerlink" title="步骤2：分别创建各个数据模型Student、Address、Course"></a>步骤2：分别创建各个数据模型Student、Address、Course</h3><p><strong>Student类</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.h文件</span></span><br><span class="line">#<span class="keyword">import</span> &quot;NSObject+ZSModel.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &quot;AddressModel.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &quot;CourseModel.h&quot;</span><br><span class="line">@interface <span class="type">StudentModel</span> : <span class="type">NSObject</span>&lt;<span class="type">ZSModel</span>&gt; <span class="comment">//遵循协议</span></span><br><span class="line"><span class="comment">//普通属性</span></span><br><span class="line">@property (nonatomic, copy) <span class="type">NSString</span> *uid;</span><br><span class="line">@property(nonatomic,copy)<span class="type">NSString</span> *name;</span><br><span class="line">@property (nonatomic, assign) <span class="type">NSInteger</span> age;</span><br><span class="line"><span class="comment">//嵌套模型</span></span><br><span class="line">@property (nonatomic, strong) <span class="type">AddressModel</span> *address;</span><br><span class="line"><span class="comment">//嵌套模型数组</span></span><br><span class="line">@property (nonatomic, strong) <span class="type">NSArray</span> *courses;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &quot;StudentModel.h&quot;</span><br><span class="line">@implementation <span class="type">StudentModel</span></span><br><span class="line">+ (<span class="type">NSDictionary</span> *)modelContainerPropertyGenericClass &#123;</span><br><span class="line">    <span class="comment">//需要特别处理的属性</span></span><br><span class="line">    <span class="keyword">return</span> @&#123;@<span class="string">&quot;courses&quot;</span> : [<span class="type">CourseModel</span> <span class="class"><span class="keyword">class</span>],@&quot;<span class="title">uid</span>&quot;:@&quot;<span class="title">id</span>&quot;&#125;;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">@<span class="title">end</span></span></span><br></pre></td></tr></table></figure><p><strong>Address类</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AddressModel.h文件</span></span><br><span class="line">@interface <span class="type">AddressModel</span> : <span class="type">NSObject</span></span><br><span class="line">@property (nonatomic, copy) <span class="type">NSString</span> *country;  <span class="comment">//国籍</span></span><br><span class="line">@property (nonatomic, copy) <span class="type">NSString</span> *province; <span class="comment">//省份</span></span><br><span class="line">@property (nonatomic, copy) <span class="type">NSString</span> *city;     <span class="comment">//城市</span></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------优美的分割线------------------------</span></span><br><span class="line"><span class="comment">//AddressModel.m文件</span></span><br><span class="line">#<span class="keyword">import</span> &quot;AddressModel.h&quot;</span><br><span class="line">@implementation <span class="type">AddressModel</span></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>Course类</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface <span class="type">CourseModel</span> : <span class="type">NSObject</span></span><br><span class="line">@property (nonatomic, copy) <span class="type">NSString</span> *name; <span class="comment">//课程名</span></span><br><span class="line">@property (nonatomic, copy) <span class="type">NSString</span> *desc; <span class="comment">//课程介绍</span></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------优美的分割线------------------------</span></span><br><span class="line"> #<span class="keyword">import</span> &quot;CourseModel.h&quot;</span><br><span class="line">@implementation <span class="type">CourseModel</span></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="步骤4：测试字典转模型操作"><a href="#步骤4：测试字典转模型操作" class="headerlink" title="步骤4：测试字典转模型操作"></a>步骤4：测试字典转模型操作</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取JSON数据</span></span><br><span class="line"><span class="type">NSDictionary</span> *jsonData = [<span class="type">FileTools</span> getDictionaryFromJsonFile:@<span class="string">&quot;Student&quot;</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,jsonData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典转模型</span></span><br><span class="line"><span class="type">StudentModel</span> *student = [<span class="type">StudentModel</span> zs_modelWithDictionary:jsonData];</span><br><span class="line"><span class="type">CourseModel</span> *courseModel = student.courses[<span class="number">0</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,courseModel.name);</span><br></pre></td></tr></table></figure><h1 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h1><img src="/2021/11/02/Runtime-Part2/1244124-6037157.png" class="" width="1244124"><p>以上就是我们在实际开发中常用的Runtime的操作了，Runtime的强大作用远不止如此。深入的了解和学习Runtime，不仅仅有助于iOS开发，而且对于理解编程语言的底层原理也十分有用，Keep Learning！~</p><p>参考链接：</p><ol><li><a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html%23//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide</a></li><li><a href="https://links.jianshu.com/go?to=%5Bhttp://nshipster.cn/method-swizzling/%5D(http://nshipster.cn/method-swizzling/)">Method Swizzling</a></li><li><a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/wuqh-iOS/p/4846811.html">iOS数据持久化存储:归档</a></li><li><a href="https://links.jianshu.com/go?to=https://github.com/ibireme/YYModel">YYModel源码</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> iOS进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runtime - 基础篇</title>
      <link href="2021/11/01/Runtime-Part1/"/>
      <url>2021/11/01/Runtime-Part1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是动态语言，什么是Runtime？"><a href="#1-什么是动态语言，什么是Runtime？" class="headerlink" title="1. 什么是动态语言，什么是Runtime？"></a>1. 什么是动态语言，什么是Runtime？</h1><h2 id="静态语言-强类型语言-："><a href="#静态语言-强类型语言-：" class="headerlink" title="静态语言(强类型语言)："></a>静态语言(强类型语言)：</h2><p>静态语言是在编译时就要确定变量的数据类型，也就是变量使用之前必须声明数据类型。如：C、C++、Java、C#等。</p><h2 id="动态语言-弱类型语言"><a href="#动态语言-弱类型语言" class="headerlink" title="动态语言(弱类型语言):"></a>动态语言(弱类型语言):</h2><p>动态语言是在运行时才去做数据类型检查的语言，变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。如：PHP、Ruby、Shell、Python等一些脚本语言。</p><a id="more"></a><h2 id="为什么说OC是一门动态语言"><a href="#为什么说OC是一门动态语言" class="headerlink" title="为什么说OC是一门动态语言:"></a>为什么说OC是一门动态语言:</h2><p>静态、动态是相对的，这里动态语言指的是不需要再编译阶段就确定所有变量方法等，还可以在运行时动态的添加。 Objective-C，在C语言的基础上添加了面向对象的特性，并且通过Runtime这个运行时机制，在运行时可以动态的添加变量，方法，类等，所以说Objective-C是一门动态语言。</p><h2 id="OC的动态性"><a href="#OC的动态性" class="headerlink" title="OC的动态性:"></a>OC的动态性:</h2><h3 id="1-1-动态类型"><a href="#1-1-动态类型" class="headerlink" title="1.1 动态类型:"></a>1.1 动态类型:</h3><p>如id类型。实际上静态类型因为其固定性和可预知性而使用的特别广泛。静态类型是强类型，动态类型是弱类型，运行时决定接收者。</p><h3 id="1-2-动态绑定"><a href="#1-2-动态绑定" class="headerlink" title="1.2 动态绑定:"></a>1.2 动态绑定:</h3><p>让代码在运行时判断需要调用什么方法，而不是在编译时。与其他面向对象语言一样，方法调用和代码并没有在编译时连接在一起，而是在消息发送时才进行连接。运行时决定调用哪个方法。</p><h3 id="1-3-动态载入"><a href="#1-3-动态载入" class="headerlink" title="1.3 动态载入:"></a>1.3 动态载入:</h3><p> 让程序在运行时添加代码模块已经其他资源。用户可以根据需要执行一些可执行代码和资源，而不是在启动时就加载所有资源组件。可执行代码中可以含有和程序运行时整合的新类。</p><h1 id="2-Runtime中的类和对象"><a href="#2-Runtime中的类和对象" class="headerlink" title="2. Runtime中的类和对象"></a>2. Runtime中的类和对象</h1><p>OC代码被编译器转化为C语言，然后再通过运行时执行，最终实现了动态调用。这其中的OC类、对象和方法等都对应了C中的结构体，而且我们都可以在Rutime源码中找到它们的定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line">#import &lt;objc&#x2F;message.h&gt;</span><br></pre></td></tr></table></figure><h2 id="2-1-对象的定义（id—-gt-objc-object）"><a href="#2-1-对象的定义（id—-gt-objc-object）" class="headerlink" title="2.1 对象的定义（id—&gt;objc_object）"></a>2.1 对象的定义（id—&gt;objc_object）</h2><p>在Runtime源码中，我们能很快找到在oc中对象的定义。如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure><p>很明显id是一个指向objc_object结构体的指针，我们点开查看Runtime对objc_object的具体定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们都知道id在OC中是表示一个任意类型的类实例，从这里也可以看出，OC中的对象虽然没有明显的使用指针，但是在OC代码被编译转化为C之后，每个OC对象其实都是拥有一个isa的指针的。</p><h2 id="2-2-类的定义-Class-gt-objc-classs"><a href="#2-2-类的定义-Class-gt-objc-classs" class="headerlink" title="2.2 类的定义 (Class - &gt;objc_classs)"></a>2.2 类的定义 (Class - &gt;objc_classs)</h2><p>我们先来看下Runtime中对于类的定义，显然class是一个指向objc_class结构体的指针，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><p>下面是Runtime中对objc_clas结构体的具体定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;usr&#x2F;include&#x2F;objc&#x2F;runtime.h</span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !OBJC2</span><br><span class="line"></span><br><span class="line">    Class Nullable super_class                              OBJC2UNAVAILABLE;</span><br><span class="line">    const char * Nonnull name                               OBJC2UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * Nullable ivars                  OBJC2UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * Nullable * _Nullable methodLists                    OBJC2UNAVAILABLE;</span><br><span class="line">    struct objc_cache * Nonnull cache                       OBJC2UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * Nullable protocols          OBJC2UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><h3 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h3><p>是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类，而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。同时注意的是：<strong>元类（meteClass）也是类，它也是对象。</strong>元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。</p><img src="/2021/11/01/Runtime-Part1/xht.png" class="" title="xht"><h4 id="super-class指针"><a href="#super-class指针" class="headerlink" title="super_class指针 :"></a>super_class指针 :</h4><p>super_class指针指向objc_class类所继承的父类，但是如果当前类已经是最顶层的类(如NSProxy),则super_class指针为NULL</p><h4 id="cache"><a href="#cache" class="headerlink" title="cache :"></a>cache :</h4><p>为了优化性能，objc_class中的cache结构体用于记录每次使用类或者实例对象调用的方法。这样每次响应消息的时候，Runtime系统会优先在cache中寻找响应方法，相比直接在类的方法列表中遍历查找，效率更高。</p><h4 id="ivars"><a href="#ivars" class="headerlink" title="ivars :"></a>ivars :</h4><p>ivars用于存放所有的成员变量和属性信息，属性的存取方法都存放在methodLists中。</p><h4 id="methodLists"><a href="#methodLists" class="headerlink" title="methodLists :"></a>methodLists :</h4><p>methodLists用于存放对象的所有成员方法。</p><h2 id="2-3-Method"><a href="#2-3-Method" class="headerlink" title="2.3 Method"></a>2.3 Method</h2><p>了解OC中的发送消息机制，我们先来看看Method在Runtime中的定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name;</span><br><span class="line">    char * method_types;</span><br><span class="line">    IMP method_imp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Method 定义为一个objc_method结构体指针，理解objc_method定义中的参数： method_name:方法名类型SEL method_types: 一个char指针，指向存储方法的参数类型和返回值类型 method_imp：本质上是一个指针，指向方法的实现 这里其实就是SEL(method_name)与IMP(method_name)形成了一个映射，通过SEL，我们可以很方便的找到方法实现IMP。</p><h3 id="SEL-："><a href="#SEL-：" class="headerlink" title="SEL ："></a>SEL ：</h3><p>先来看下SEL在Runtime中的定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents a method selector.</span><br><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure><p>SEL是一个指向objc_selector结构体的指针,源码中我们没有找到这个结构体的明确定义。我们通过代码测试发现，SEL其实就是保存了方法名字符串的标识。下面有我们获取SEL的三种方法: 1.OC中，使用@selector(“方法名字符串”) 2.OC中，使用NSSelectorFromString(“方法名字符串”) 3.Runtime方法，使用sel_registerName(“方法名字符串”)</p><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>IMP是一个函数指针，它在Runtime中的定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; A pointer to the function of a method implementation.</span><br><span class="line">typedef void (IMP)(void &#x2F; id, SEL, ... *&#x2F; );</span><br></pre></td></tr></table></figure><p>IMP函数指针指向了方法实现的首地址，当OC发起消息后，最终执行的代码是由IMP指针决定的。利用这个特性，我们可以对代码进行优化：当需要大量重复调用方法的时候，我们可以绕开消息绑定而直接利用IMP指针调起方法，这样的执行将会更加高效。</p><h1 id="3-Runtime消息发送"><a href="#3-Runtime消息发送" class="headerlink" title="3. Runtime消息发送"></a>3. Runtime消息发送</h1><p>Objective-C中的方法调用，不是简单的方法调用，而是发送消息。也就是说，其实[receiver message] 会被编译器转化为: objc_msgSend(receiver,selector)，在Runtime中它的原形为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSend(void &#x2F;* id self, SEL op, ... *&#x2F; )</span><br></pre></td></tr></table></figure><p>上面看到objc_msgSend会默认传入id和SEL。这对赢了两个隐含参数，self和_cmd。这意味着我们可以在方法的实现过程中拿到并使用。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)testCmd:(NSNumber *)num &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%ld&quot;, (long)num.integerValue);</span><br><span class="line">    </span><br><span class="line">    num &#x3D; [NSNumber numberWithInteger:num.integerValue-1];</span><br><span class="line">    </span><br><span class="line">    if (num.integerValue &gt; 0) &#123;</span><br><span class="line">        [self performSelector:_cmd withObject:num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self testCmd:@(5)];</span><br></pre></td></tr></table></figure><p>上面会按顺序输出 <code>5, 4, 3, 2, 1</code> ，然后结束。即我们可以在方法内部用 <code>_cmd</code> 来调用方法自身。</p><p>编译器会根据情况在 objc_msgSend，objc_msgSend_stret，objc_msgSendSuper，objc_msgSendSuper_stret 或 objc_msgSend_fpret 五个方法中选择一个来调用。如果消息是传递给超类，那么会调用 objc_msgSendSuper 方法，如果消息返回值是数据结构，就会调用 objc_msgSendSuper_stret 方法，如果返回值是浮点数，则调用 objc_msgSend_fpret 方法。</p><p>有一道网上常见的面试题来帮助我们加深理解，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这个题目主要是考察关于 Objective-C 中对 self 和 super 的理解。</p><p>我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？</p><p>很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p><p>上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>，接受消息的对象都是当前 <code>Son ＊xxx</code> 这个对象。</p><p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p><p>下面是整个运行时阶段消息发送的详细步骤:</p><ol><li>检测selector 是不是需要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会retain,release 这些函数了。</li><li>检测target 是不是nil 对象。ObjC 的特性是允许对一个 nil对象执行任何一个方法不会 Crash，因为会被忽略掉。</li><li>如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，若可以找得到就跳到对应的函数去执行</li><li>如果在cache里找不到就找一下方法列表methodLists。</li><li>如果methodLists找不到，就到超类的方法列表里寻找，一直找，直到找到NSObject类为止。</li><li>如果还找不到，Runtime就提供了如下三种方法来处理：<strong>动态方法解析</strong>、<strong>消息接受者重定向</strong>、<strong>消息重定向</strong>,这就是下面要说的消息转发机制。</li></ol><h1 id="4-消息转发机制"><a href="#4-消息转发机制" class="headerlink" title="4. 消息转发机制"></a>4. 消息转发机制</h1><p>我们先用一张图来简单了解这三种方法的调用关系:</p><img src="/2021/11/01/Runtime-Part1/lct.png" class="" title="lct"><h2 id="4-1-动态方法解析"><a href="#4-1-动态方法解析" class="headerlink" title="4.1 动态方法解析"></a>4.1 动态方法解析</h2><p>所谓动态解析，我们可以理解为通过cache和方法列表没有找到方法时，Runtime为我们提供一次动态添加方法实现的机会，主要用到的方法入如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;OC方法：</span><br><span class="line">&#x2F;&#x2F;类方法未找到时调起，可于此添加类方法实现</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">&#x2F;&#x2F;实例方法未找到时调起，可于此添加实例方法实现</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Runtime方法：</span><br><span class="line">&#x2F;**</span><br><span class="line"> 运行时方法：向指定类中添加特定方法实现的操作</span><br><span class="line"> @param cls 被添加方法的类</span><br><span class="line"> @param name selector方法名</span><br><span class="line"> @param imp 指向实现方法的函数指针</span><br><span class="line"> @param types imp函数实现的返回值与参数类型</span><br><span class="line"> @return 添加方法是否成功</span><br><span class="line"> *&#x2F;</span><br><span class="line">BOOL class_addMethod(Class _Nullable cls,</span><br><span class="line">                     SEL _Nonnull name,</span><br><span class="line">                     IMP _Nonnull imp,</span><br><span class="line">                     const char * _Nullable types)</span><br></pre></td></tr></table></figure><h2 id="4-2-消息接受者重定向"><a href="#4-2-消息接受者重定向" class="headerlink" title="4.2 消息接受者重定向"></a>4.2 消息接受者重定向</h2><p>我们注意到动态方法解析过程中的两个resolve方法都返回了布尔值，当它们返回YES时方法即可正常执行，但是若它们返回NO，消息发送机制就进入了消息转发(Forwarding)的阶段了，我们可以使用Runtime通过下面的方法替换消息接收者的为其他对象，从而保证程序的继续执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;重定向类方法的消息接收者，返回一个类</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重定向实例方法的消息接受者，返回一个实例对象</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure><h2 id="4-3-消息重定向"><a href="#4-3-消息重定向" class="headerlink" title="4.3 消息重定向"></a>4.3 消息重定向</h2><p>当以上两种方法无法生效，那么这个对象会因为找不到相应的方法实现而无法响应消息，此时Runtime系统会通过forwardInvocation：消息通知该对象，给予此次消息发送最后一次寻找IMP的机会：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation；</span><br></pre></td></tr></table></figure><p>其实每个对象都从NSObject类中继承了forwardInvocation：方法，但是NSObject中的这个方法只是简单的调用了doesNotRecongnizeSelector:方法，提示我们错误。所以我们可以重写这个方法：对不能处理的消息做一些默认处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p><p>我们注意到anInvocation是forwardInvocation唯一参数，它封装了原始的消息和消息参数。正是因为它，我们还不得不重写另一个函数：methodSignatureForSelector。这是因为在forwardInvocation: 消息发送前，Runtime系统会向对象发送methodSignatureForSelector消息，并取到返回的方法签名用于生成NSInvocation对象。</p><h1 id="5-总结："><a href="#5-总结：" class="headerlink" title="5. 总结："></a>5. 总结：</h1><p>以上就是IOS运行时的基础部分，帮助我们理解Runtime的工作原理。在实际开发中，合理的运用Runtime，可以提高我们的开发效率。下一遍，我将总结Runtime在实际开发中的使用。</p><p><strong>其他参考链接</strong><br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">1.Objective-C Runtime Programming Guide</a><br>2.Objctive-C Runtime](<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/</a>)<br><a href="https://blog.csdn.net/zhaochen_009/article/details/54602930">3.iOS Runtime forwardInvocation的一些总结</a><br>4.<a href="https://blog.csdn.net/zhaochen_009/article/details/54602930">https://blog.csdn.net/zhaochen_009/article/details/54602930</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> iOS进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
