<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.cfjia.cc","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="cfjia个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="黑夜里的眸">
<meta property="og:url" content="blog.cfjia.cc/index.html">
<meta property="og:site_name" content="黑夜里的眸">
<meta property="og:description" content="cfjia个人博客">
<meta property="og:locale">
<meta property="article:author" content="cfjia">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="blog.cfjia.cc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>黑夜里的眸</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">黑夜里的眸</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">黑夜降临的时候，黎明也就不远了...</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="blog.cfjia.cc/2022/12/22/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cfjia">
      <meta itemprop="description" content="cfjia个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑夜里的眸">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/22/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-2/" class="post-title-link" itemprop="url">iOS面试题 part 2 - 内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-22 20:00:00" itemprop="dateCreated datePublished" datetime="2022-12-22T20:00:00+08:00">2022-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-03 21:34:47" itemprop="dateModified" datetime="2023-01-03T21:34:47+08:00">2023-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">iOS进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-weak的实现原理？sideTable的结构是什么样的？"><a href="#1-weak的实现原理？sideTable的结构是什么样的？" class="headerlink" title="1. weak的实现原理？sideTable的结构是什么样的？"></a>1. weak的实现原理？sideTable的结构是什么样的？</h3><p>weak：其实是一个hash表结构，其中的key是所指对象的地址，value是weak的指针数组，weak表示的是弱引用，不会对对象引用计数+1，当引用的对象被释放的时候，其值被自动设置为nil，一般用于解决循环引用的。</p>
<p>weak的实现原理<br>1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。<br>2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</p>
<p>SideTable的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">&#x2F;&#x2F; 保证原子操作的自旋锁</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    &#x2F;&#x2F; 引用计数的 hash 表</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    &#x2F;&#x2F; weak 引用全局 hash 表</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-关联对象的应用？系统如何实现关联对象的"><a href="#2-关联对象的应用？系统如何实现关联对象的" class="headerlink" title="2. 关联对象的应用？系统如何实现关联对象的"></a>2. 关联对象的应用？系统如何实现关联对象的</h3><p>应用：可以在不改变类的源码的情况下，为类添加实例变量（注意：这里指的实例变量，并不是真正的属于类的实例变量，而是一个关联值变量）结合category使用，为类扩展存储属性。</p>
<p>关联对象实现原理：关联对象的值实际上是通过AssociationsManager对象负责管理的，这个对象里有个AssociationsHashMap静态表，用来存储对象的关联值的，关于AssociationsHashMap存储的数据结构如下：<br>AssociationsHashMap：<br>——添加属性对象的指针地址（key）：ObjectAssociationMap（value：所有关联值对象）<br>ObjectAssociationMap：<br>——关联值的key：关联值的value</p>
<p>关联对象的应用和系统如何实现关联对象的大概顺序如下:<br><code>AssociationsManager</code>关联对象管理器-&gt;<code>AssociationsHashMap</code>哈希映射表-&gt;<code>ObjectAssociationMap</code>关联对象指针-&gt;<code>ObjcAssociation</code>关联对象</p>
<h3 id="3-关联对象的如何进行内存管理的？关联对象如何实现weak属性"><a href="#3-关联对象的如何进行内存管理的？关联对象如何实现weak属性" class="headerlink" title="3. 关联对象的如何进行内存管理的？关联对象如何实现weak属性?"></a>3. 关联对象的如何进行内存管理的？关联对象如何实现weak属性?</h3><p>内存管理：<br>关联对象的ObjectAssociation中有两个属性(uintptr_t _policy, id value),<br>_policy 包含 retain, assgin copy, 会对应的对对象进行和普通对象一样的内存管理操作.</p>
<p>weak属性:</p>
<ol>
<li>实现weak,用__weak修饰对象,并将其用block包裹,关联时,关联block对象</li>
<li>额外创造一个类WeakObjectContainer，在这个类里实现weak属性 weakObject ，虽然 分类里 retain 了一个 WeakObjectContainer，但是 WeakObjectContainer 最终会随着属性的持有对象一起销毁，不存在泄露。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="blog.cfjia.cc/2022/12/21/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cfjia">
      <meta itemprop="description" content="cfjia个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑夜里的眸">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/21/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-1/" class="post-title-link" itemprop="url">iOS面试题 part 1 - Runtime 内存结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-21 20:00:00" itemprop="dateCreated datePublished" datetime="2022-12-21T20:00:00+08:00">2022-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-03 21:34:44" itemprop="dateModified" datetime="2023-01-03T21:34:44+08:00">2023-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">iOS进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-介绍下runtime的内存模型-isa，对象，类，metaclass，结构体的存储信息等"><a href="#1-介绍下runtime的内存模型-isa，对象，类，metaclass，结构体的存储信息等" class="headerlink" title="1. 介绍下runtime的内存模型(isa，对象，类，metaclass，结构体的存储信息等)"></a>1. 介绍下runtime的内存模型(isa，对象，类，metaclass，结构体的存储信息等)</h3><p>对象：OC中的对象指向的是一个objc_object指针类型，typedef struct objc_object *id；从它的结构体中可以看出，它包含一个isa指针，指向的是这个对象的类对象。一个对象的实例就是通过isa指针找到它自己的class，而这个class中存储的就是这个实例的方法列表，属性列表，成员变量等相关信息。</p>
<p>类：在OC中类也是用class表示的，实际上它指向的是objc_class指针类型,typedef struct objc_class *Class;而objc_class继承于objc_object,这就很好的解释了万物皆对象，oc中的类也是对象。</p>
<h3 id="2-为什么要设计metaclass"><a href="#2-为什么要设计metaclass" class="headerlink" title="2. 为什么要设计metaclass?"></a>2. 为什么要设计metaclass?</h3><p>符合单一职责设计原则，从面向对象的设计理念来说，万物皆对象，类也是对象，当然元类也是对象，存在的目的一方面可以让对象的继承链关系完美闭环，也保证能完美的复用传递消息机制。这样设计也是参考了smalltalk的理念。</p>
<h3 id="3-class-copyIvarList-和class-copyPropertyList-区别"><a href="#3-class-copyIvarList-和class-copyPropertyList-区别" class="headerlink" title="3. class_copyIvarList()和class_copyPropertyList()区别"></a>3. class_copyIvarList()和class_copyPropertyList()区别</h3><p>class_copyIvarList()可以获取到所有的成员变量，包括花括号内的变量(包含.h和.m)</p>
<p>class_copyPropertyList()只能获取到@property关键字声明的属性(.h和.m)</p>
<p>区别：</p>
<p>class_copyIvarList 获取类对象中的所有实例变量信息，从 <code>class_ro_t</code> 中获取：</p>
<p>class_copyPropertyList 获取类对象中的属性信息， class_rw_t 的 properties，先后输出了 category / extension/ baseClass 的属性，而且仅输出当前的类的属性信息，而不会向上去找 superClass 中定义的属性。</p>
<h3 id="4-class-rw-t和class-ro-t区别"><a href="#4-class-rw-t和class-ro-t区别" class="headerlink" title="4. class_rw_t和class_ro_t区别"></a>4. class_rw_t和class_ro_t区别</h3><p>两个结构体都存放着当前类的属性，方法，实例变量，协议等;</p>
<p>class_ro_t存放是编译期就确定的;</p>
<p>class_rw_t存放是在runtime时才确定的，它会先将class_ro_t的内容拷贝过去，然后再将当前类的分类的属性，方法拷贝其中。所以可以说<code>class_rw_t</code>是<code>class_ro_t</code>的超集，当然实际访问类的方法、属性等也都是访问的<code>class_rw_t</code>中的内容；</p>
<h3 id="5-category是如何被加载的，两个category的load方法的加载顺序，两个category同名方法的加载顺序？"><a href="#5-category是如何被加载的，两个category的load方法的加载顺序，两个category同名方法的加载顺序？" class="headerlink" title="5. category是如何被加载的，两个category的load方法的加载顺序，两个category同名方法的加载顺序？"></a>5. category是如何被加载的，两个category的load方法的加载顺序，两个category同名方法的加载顺序？</h3><p>category的加载是发生在运行时，加载的过程是把category的实例方法，属性，协议添加到类对象上，把类方法添加到meteclass上；</p>
<p>加载顺序为：父类&gt;本类&gt;分类，而不同分类的加载顺序按照编译的顺序加载，即：xcode中的Build Phases中的Compile Sources中的文件从上到下的顺序加载的。</p>
<p>同名的普通方法，会优先调用分类的方法，不同分类的同名方法会根据编译顺序，先调用最后一个编译的分类方法。</p>
<p>原因：根据runtime的消息传递机制中的核心函数void objc_msgSend(id self,SEL cmd,…)来发送消息，先从当前类中查找调用的方法，若没有找到则继续从其父类中一层层往上找，那么对于category重写同一个方法，则在消息传递的过程中，会最先找到category中的方法并执行该方法。对于多个分类调用同一个方法，Xcode在运行时是根据buildPhases-&gt;Compile Sources里面的从上至下顺序编译的，编译时通过压栈的方式将多个分类压栈，根据后进先出的原则，后编译的会被先调用，（插入顶部添加，即[methodLists insertObject:category_method atIndex:0]; 所以objc_msgSend遍历方法列表查找SEL 对应的IMP时，会先找到分类重写的那个，调用执行）当objc_msgSend找到方法并调用之后，就不再继续传递消息，所以形成所谓的覆盖。</p>
<h3 id="6-category和extension的区别，能给NSObject添加Extension吗，结果？"><a href="#6-category和extension的区别，能给NSObject添加Extension吗，结果？" class="headerlink" title="6. category和extension的区别，能给NSObject添加Extension吗，结果？"></a>6. category和extension的区别，能给NSObject添加Extension吗，结果？</h3><p>category：分类</p>
<p>给类添加新的方法<br>不能给类添加成员变量<br>通过@property定义的变量，只能生成对应的getter和setter的方法声明，但是不能实现getter和setter方法，同时也不能生成带下划线的成员属性<br>是运行期决定的<br>注意：为什么不能添加属性，原因就是category是运行期决定的，在运行期类的内存布局已经确定，如果添加实例变量会破坏类的内存布局，会产生意想不到的错误。</p>
<p>extension：扩展</p>
<p>可以给类添加成员变量，但是是私有的 可以給类添加方法，但是是私有的 添加的属性和方法是类的一部分，在编译期就决定的。在编译器和头文件的@interface和实现文件里的@implement一起形成了一个完整的类。 伴随着类的产生而产生，也随着类的消失而消失 必须有类的源码才可以给类添加extension，所以对于系统一些类，如nsstring，就无法添加类扩展 不能给NSObject添加Extension，因为在extension中添加的方法或属性必须在源类的文件的.m文件中实现才可以，即：你必须有一个类的源码才能添加一个类的extension。</p>
<h3 id="7-消息转发机制，消息转发机制和其他语言的消息机制优劣对比"><a href="#7-消息转发机制，消息转发机制和其他语言的消息机制优劣对比" class="headerlink" title="7. 消息转发机制，消息转发机制和其他语言的消息机制优劣对比"></a>7. 消息转发机制，消息转发机制和其他语言的消息机制优劣对比</h3><p>消息转发机制是相对于消息传递机制而言的。</p>
<p>消息传递机制：<br>Runtime也就是运行时，就是系统在运行时的一些机制，其中最主要的就是消息机制。<br>对于C语言，函数的调用在编译阶段就会决定调用哪个函数，编译完成后，顺序执行。而OC的函数调用，称为消息发送，在编译阶段并不能真正决定调用哪个函数（也就是说，在编译阶段，OC可以调用任何函数，即使这个函数并未实现，但只要声明过就不会报错。而C语在编译阶段就会报错）。只有在运行时，才会根据函数的名称找到对应函数的地址来进行调用。</p>
<p>[objc makeTest]<br>首先，编译器将代码[obj makeText];转化为objc_msgSend(obj, @selector (makeText));，在objc_msgSend函数中。首先通过obj的isa指针找到obj对应的class。在Class中先去cache中 通过SEL查找对应函数method，若 cache中未找到。再去methodList中查找，若methodlist中未找到，则取superClass中查找。若能找到，则将method加入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。</p>
<p>消息转发机制(可以间接实现多继承)：<br>如通过以上消息发送机制，并未找到对应的函数实现，将会进入到消息转发机制流程；</p>
<ol>
<li><p>动态方法解析</p>
<p>resolveInstanceMethod，可以动态的添加一个方法到类中</p>
</li>
<li><p>替换消息接收者，快速转发</p>
<p>forwardingTargetForSelector，指定其他类对象作为消息的接收者，进行消息快速转发</p>
</li>
<li><p>完全消息转发机制</p>
<p>runtime发送methodSignatureForSelector消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出。</p>
<ul>
<li>把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。</li>
<li>修改消息的target，selector，参数等</li>
<li>多次转发这个消息，转发给多个对象</li>
</ul>
</li>
</ol>
<h3 id="8-在方法调用的时候，方法查询-gt-动态解析-gt-消息转发-之前都做了什么？"><a href="#8-在方法调用的时候，方法查询-gt-动态解析-gt-消息转发-之前都做了什么？" class="headerlink" title="8. 在方法调用的时候，方法查询-&gt;动态解析-&gt;消息转发 之前都做了什么？"></a>8. 在方法调用的时候，方法查询-&gt;动态解析-&gt;消息转发 之前都做了什么？</h3><p>Objective-C 实例对象执行方法步骤</p>
<ol>
<li>获取 receiver 对应的类 Class</li>
<li>在 Class 缓存列表中(就是<code>objc_class</code>里的<code>cache_t</code>到<code>class_ro_t</code>的方法list)根据选择子<code>selector</code>查找<code>IMP</code></li>
<li>若缓存中没有找到，则在方法列表中继续查找.</li>
<li>若方法列表没有，则从父类查找，重复以上步骤.</li>
<li>若最终没有找到，则进行消息转发操作.</li>
</ol>
<ul>
<li>方法查询之前 要知道 receiver和 selector.主要是要明确我们是哪个实例调用了哪个方法.</li>
<li>动态解析解析之前要 在所属的类中先征询接受者,看其是否能动态加方法，来处理当前这个未知选择器.</li>
<li>消息转发 之前 要询问是否把消息转发给另一个对象.</li>
</ul>
<h3 id="9-IMP、SEL、Method的区别和使用场景"><a href="#9-IMP、SEL、Method的区别和使用场景" class="headerlink" title="9. IMP、SEL、Method的区别和使用场景"></a>9. <code>IMP</code>、<code>SEL</code>、<code>Method</code>的区别和使用场景</h3><ul>
<li><p><code>IMP</code> : 是方法的具体实现(指针)</p>
</li>
<li><p><code>SEL</code> :方法名称</p>
</li>
<li><p><code>Method </code>:是objc_method类型指针，它是一个结构体 ,如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    char * _Nullable method_types                            OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用场景</p>
<ul>
<li><p>例如 Button添加Target和Selector的时候.或者 实现类的<code>swizzle</code>的时候会用到，通过<code>class_getInstanceMethod(class, SEL)</code>来获取类的方法<code>Method</code>，其中用到了SEL作为方法名</p>
</li>
<li><p>例如 给类动态添加方法，此时我们需要调用class_addMethod(Class, SEL, IMP, types)，该方法需要我们传递一个方法的实现函数IMP，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void funcName(id receiver, SEL cmd, 方法参数...) &#123;</span><br><span class="line">   &#x2F;&#x2F; 方法具体的实现   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="blog.cfjia.cc/2022/03/22/iOS%E6%9E%B6%E6%9E%84%20-%20%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%20(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cfjia">
      <meta itemprop="description" content="cfjia个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑夜里的眸">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/22/iOS%E6%9E%B6%E6%9E%84%20-%20%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%20(2)/" class="post-title-link" itemprop="url">iOS架构 - 组件化方案 (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-22 14:52:16" itemprop="dateCreated datePublished" datetime="2022-03-22T14:52:16+08:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-03 21:34:04" itemprop="dateModified" datetime="2023-01-03T21:34:04+08:00">2023-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">iOS进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="组件化通讯方案"><a href="#组件化通讯方案" class="headerlink" title="组件化通讯方案"></a>组件化通讯方案</h3><p>目前主流的主要有以下三种方式：</p>
<ul>
<li>1、<code>URL</code>路由</li>
<li>2、<code>target-action</code></li>
<li>3、<code>protocol</code>匹配</li>
</ul>
<h3 id="URL路由"><a href="#URL路由" class="headerlink" title="URL路由"></a>URL路由</h3><p>目前iOS上大部分路由工具都是基于URL匹配的，或者是根据命名约定，用runtime方法进行动态调用</p>
<p>这些动态化的方案的优点是实现简单，缺点是需要维护字符串表，或者依赖于命名约定，无法在编译时暴露出所有问题，需要在运行时才能发现错误。</p>
<p>URL路由方式主要是以蘑菇街为代表的的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/meili/MGJRouter">MGJRouter</a></p>
<p>其实现思路是：</p>
<ul>
<li>App启动时实例化各组件模块，然后这些组件向<code>ModuleManager</code>注册<code>Url</code>，有些时候不需要实例化，使用class注册</li>
<li>当组件A需要调用组件B时，向<code>ModuleManager</code>传递URL，参数跟随URL以GET方式传递，类似openURL。然后由ModuleManager负责调度组件B，最后完成任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、注册某个URL</span><br><span class="line">MGJRouter.registerURLPattern(&quot;app:&#x2F;&#x2F;home&quot;) &#123; (info) in</span><br><span class="line">    print(&quot;info: \(info)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、调用路由</span><br><span class="line">MGJRouter.openURL(&quot;app:&#x2F;&#x2F;home&quot;)</span><br></pre></td></tr></table></figure>



<h4 id="URL-路由的优点"><a href="#URL-路由的优点" class="headerlink" title="URL 路由的优点"></a>URL 路由的优点</h4><ul>
<li>极高的动态性，适合经常开展运营活动的app，例如电商</li>
<li>方便地统一管理多平台的路由规则</li>
<li>易于适配URL Scheme</li>
</ul>
<h4 id="URl-路由的缺点"><a href="#URl-路由的缺点" class="headerlink" title="URl 路由的缺点"></a>URl 路由的缺点</h4><ul>
<li>传参方式有限，并且无法利用编译器进行参数类型检查，因此所有的参数都是通过字符串转换而来</li>
<li>只适用于界面模块，不适用于通用模块</li>
<li>参数的格式不明确，是个灵活的 dictionary，也需要有个地方可以查参数格式。</li>
<li>不支持storyboard</li>
<li>依赖于字符串硬编码，难以管理，蘑菇街做了个后台专门管理。</li>
<li>无法保证所使用的的模块一定存在</li>
<li>解耦能力有限，url 的”注册”、”实现”、”使用”必须用相同的字符规则，一旦任何一方做出修改都会导致其他方的代码失效，并且重构难度大</li>
</ul>
<p>除了<code>CTMediator</code>，还有以下这些三方框架</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/clayallsopp/routable-ios">routable-ios</a></li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/joeldev/JLRoutes">JLRoutes</a></li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/lightory/HHRouter">HHRouter</a></li>
</ul>
<h3 id="target-action"><a href="#target-action" class="headerlink" title="target-action"></a>target-action</h3><p>这个方案是基于OC的runtime、category特性动态获取模块，例如通过<code>NSClassFromString</code>获取类并创建实例，通过<code>performSelector + NSInvocation</code>动态调用方法</p>
<p>其主要的代表框架是<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/casatwy/CTMediator">casatwy的CTMediator</a></p>
<p>其实现思路是：</p>
<ul>
<li>1、利用分类为路由添加新接口，在接口中通过字符串获取对应的类</li>
<li>2、通过runtime创建实例，动态调用实例的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;******* 1、分类定义新接口</span><br><span class="line">extension CTMediator&#123;</span><br><span class="line">    @objc func A_showHome()-&gt;UIViewController?&#123;</span><br><span class="line">        let params &#x3D; [</span><br><span class="line">            kCTMediatorParamsKeySwiftTargetModuleName: &quot;CJLBase_Example&quot;</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        if let vc &#x3D; self.performTarget(&quot;A&quot;, action: &quot;Extension_HomeViewController&quot;, params: params, shouldCacheTarget: false) as? UIViewController&#123;</span><br><span class="line">            return vc</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******* 2、模块提供者提供target-action的调用方式（对外需要加上public关键字）</span><br><span class="line">class Target_A: NSObject &#123;</span><br><span class="line">    </span><br><span class="line">    @objc func Action_Extension_HomeViewController(_ params: [String: Any])-&gt;UIViewController&#123;</span><br><span class="line">         </span><br><span class="line">        let home &#x3D; HomeViewController()</span><br><span class="line">        return home</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******* 3、使用</span><br><span class="line">if let vc &#x3D; CTMediator.sharedInstance().A_showHome() &#123;</span><br><span class="line">            self.navigationController?.pushViewController(vc, animated: true)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>其模块间的引用关系如下图所示</p>
<p>![image.png](iOS架构 - 组件化方案 (2)/d74f03f0de964014923b74a6d4b9c5d3.png)</p>
<p><strong>优点</strong></p>
<p>**<br>**</p>
<ul>
<li>利用 <code>分类</code> 可以明确声明接口，进行编译检查</li>
<li>实现方式<code>轻量</code></li>
</ul>
<p>**<br>**</p>
<p><strong>缺点</strong></p>
<p>**<br>**</p>
<ul>
<li>需要在<code>mediator</code> 和 <code>target</code>中重新添加每一个接口，模块化时代码较为繁琐</li>
<li>在 <code>category</code> 中仍然引入了<code>字符串硬编码</code>，内部使用字典传参，一定程度上也存在和 URL 路由相同的问题</li>
<li>无法保证使用的模块一定存在，target在修改后，使用者只能在运行时才能发现错误</li>
<li>可能会创建过多的 target 类</li>
</ul>
<p>**<br>**</p>
<p><strong>CTMediator源码分析</strong></p>
<p>**<br>**</p>
<ul>
<li>通过分类中调用的<code>performTarget</code>来到<code>CTMediator</code>中的具体实现，即<code>performTarget:action:params:shouldCacheTarget:</code>，主要是通过传入的name，找到对应的<code>target</code> 和 <code>action</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</span><br><span class="line">&#123;</span><br><span class="line">    if (targetName &#x3D;&#x3D; nil || actionName &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在swift中使用时，需要传入对应项目的target名称，否则会找不到视图控制器</span><br><span class="line">    NSString *swiftModuleName &#x3D; params[kCTMediatorParamsKeySwiftTargetModuleName];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; generate target 生成target</span><br><span class="line">    NSString *targetClassString &#x3D; nil;</span><br><span class="line">    if (swiftModuleName.length &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;swift中target文件名拼接</span><br><span class="line">        targetClassString &#x3D; [NSString stringWithFormat:@&quot;%@.Target_%@&quot;, swiftModuleName, targetName];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;OC中target文件名拼接</span><br><span class="line">        targetClassString &#x3D; [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;缓存中查找target</span><br><span class="line">    NSObject *target &#x3D; [self safeFetchCachedTarget:targetClassString];</span><br><span class="line">    &#x2F;&#x2F;缓存中没有target</span><br><span class="line">    if (target &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        &#x2F;&#x2F;通过字符串获取对应的类</span><br><span class="line">        Class targetClass &#x3D; NSClassFromString(targetClassString);</span><br><span class="line">        &#x2F;&#x2F;创建实例</span><br><span class="line">        target &#x3D; [[targetClass alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; generate action 生成action方法名称</span><br><span class="line">    NSString *actionString &#x3D; [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];</span><br><span class="line">    &#x2F;&#x2F;通过方法名字符串获取对应的sel</span><br><span class="line">    SEL action &#x3D; NSSelectorFromString(actionString);</span><br><span class="line">    </span><br><span class="line">    if (target &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的</span><br><span class="line">        [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;是否需要缓存</span><br><span class="line">    if (shouldCacheTarget) &#123;</span><br><span class="line">        [self safeSetCachedTarget:target key:targetClassString];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;是否响应sel</span><br><span class="line">    if ([target respondsToSelector:action]) &#123;</span><br><span class="line">        &#x2F;&#x2F;动态调用方法</span><br><span class="line">        return [self safePerformAction:action target:target params:params];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理</span><br><span class="line">        SEL action &#x3D; NSSelectorFromString(@&quot;notFound:&quot;);</span><br><span class="line">        if ([target respondsToSelector:action]) &#123;</span><br><span class="line">            return [self safePerformAction:action target:target params:params];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。</span><br><span class="line">            [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [self.cachedTarget removeObjectForKey:targetClassString];</span><br><span class="line">            &#125;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>进入<code>safePerformAction:target:params:</code>实现，主要是通过<code>invocation</code>进行<code>参数传递+消息转发</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (id)safePerformAction:(SEL)action target:(NSObject *)target params:(NSDictionary *)params</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取方法签名</span><br><span class="line">    NSMethodSignature* methodSig &#x3D; [target methodSignatureForSelector:action];</span><br><span class="line">    if(methodSig &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取方法签名中的返回类型，然后根据返回值完成参数传递</span><br><span class="line">    const char* retType &#x3D; [methodSig methodReturnType];</span><br><span class="line">    &#x2F;&#x2F;void类型</span><br><span class="line">    if (strcmp(retType, @encode(void)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...省略其他类型的判断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="protocol-class"><a href="#protocol-class" class="headerlink" title="protocol class"></a>protocol class</h3><p>protocol匹配的<code>实现思路</code>是：</p>
<ul>
<li>1、将<code>protocol</code>和对应的<code>类</code>进行<code>字典匹配</code></li>
<li>2、通过用<code>protocol</code>获取<code>class</code>，在<code>动态创建实例</code></li>
</ul>
<p>protocol比较典型的三方框架就是<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/alibaba/BeeHive">阿里的BeeHive</a>。<code>BeeHive</code>借鉴了Spring Service、Apache DSO的架构理念，<code>采用AOP+扩展App生命周期API</code>形式，将<code>业务功能</code>、<code>基础功能</code>模块以模块方式以解决大型应用中的复杂问题，并让<code>模块之间以Service形式调用</code>，将复杂问题切分，以AOP方式模块化服务。</p>
<p>**<br>**</p>
<h4 id="BeeHive-核心思想"><a href="#BeeHive-核心思想" class="headerlink" title="BeeHive 核心思想"></a>BeeHive 核心思想</h4><ul>
<li>1、各个模块间调用从直接调用对应模块，变成调用<code>Service</code>的形式，避免了直接依赖。</li>
<li>2、App生命周期的分发，将耦合在<code>AppDelegate</code>中逻辑拆分，每个模块以微应用的形式独立存在。</li>
</ul>
<p>示例如下（本想用swift写的，但是有点问题，暂时用OC写）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;******** 1、注册</span><br><span class="line">[[BeeHive shareInstance] registerService:@protocol(HomeServiceProtocol) service:[BHViewController class]];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******** 2、使用</span><br><span class="line">#import &quot;BHService.h&quot;</span><br><span class="line"></span><br><span class="line">id&lt; HomeServiceProtocol &gt; homeVc &#x3D; [[BeeHive shareInstance] createService:@protocol(HomeServiceProtocol)];</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<p>**<br>**</p>
<ul>
<li>1、利用接口调用，实现了参数传递时的类型安全</li>
<li>2、直接使用模块的protocol接口，无需再重复封装</li>
</ul>
<p><strong>缺点</strong></p>
<p>**<br>**</p>
<ul>
<li>1、用框架来创建所有对象，创建方式不同，即不支持外部传入参数</li>
<li>2、用<code>OC runtime</code>创建对象，不支持swift</li>
<li>3、只做了<code>protocol</code> 和 <code>class</code> 的匹配，不支持更复杂的创建方式 和依赖注入</li>
<li>4、无法保证所使用的protocol 一定存在对应的模块，也无法直接判断某个protocol是否能用于获取模块</li>
</ul>
<p>除了<code>BeeHive</code>，还有<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/Swinject/Swinject">Swinject</a></p>
<h3 id="BeeHive-模块注册"><a href="#BeeHive-模块注册" class="headerlink" title="BeeHive 模块注册"></a>BeeHive 模块注册</h3><p>在<code>BeeHive</code>主要是通过<code>BHModuleManager</code>来管理各个模块的。<code>BHModuleManager</code>中只会管理已经被注册过的模块。</p>
<p>BeeHive提供了三种不同的调用形式，<code>静态plist</code>，<code>动态注册</code>，<code>annotation</code>。Module、Service之间没有关联，每个业务模块可以单独实现Module或者Service的功能。</p>
<h4 id="1、-Annotation方式注册"><a href="#1、-Annotation方式注册" class="headerlink" title="1、 Annotation方式注册"></a>1、 Annotation方式注册</h4><p>这种方式主要是通过<code>BeeHiveMod</code>宏进行<code>Annotation</code>标记</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;***** 使用</span><br><span class="line">BeeHiveMod(ShopModule)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;***** BeeHiveMod的宏定义</span><br><span class="line">#define BeeHiveMod(name) \</span><br><span class="line">class BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) &#x3D; &quot;&quot;#name&quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;***** BeeHiveDATA的宏定义 </span><br><span class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot; &quot;)))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;*****  全部转换出来后为下面的格式</span><br><span class="line">char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot; &quot;))) &#x3D; &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>

<p>这里针对<code>__attribute</code>需要说明以下几点</p>
<ul>
<li>第一个参数<code>used</code>：用来修饰函数，被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器下会去掉没有被引用的段。</li>
<li>通过使用<code>__attribute__((section(&quot;name&quot;)))</code>来指明哪个段。数据则用<code>__attribute__((used))</code>来标记，防止链接器会优化删除未被使用的段，然后将模块注入到<code>__DATA</code>中</li>
</ul>
<p>此时Module已经被存储到Mach-O文件的特殊段中，那么如何取呢？</p>
<ul>
<li>进入<code>BHReadConfiguration</code>方法，主要是通过<code>Mach-O</code>找到存储的数据段，取出放入数组中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *configs &#x3D; [NSMutableArray array];</span><br><span class="line">    unsigned long size &#x3D; 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">    &#x2F;&#x2F; 找到之前存储的数据段(Module找BeehiveMods段 和 Service找BeehiveServices段)的一片内存</span><br><span class="line">    uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">    const struct mach_header_64 *mhp64 &#x3D; (const struct mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    unsigned long counter &#x3D; size&#x2F;sizeof(void*);</span><br><span class="line">    &#x2F;&#x2F; 把特殊段里面的数据都转换成字符串存入数组中</span><br><span class="line">    for(int idx &#x3D; 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        char *string &#x3D; (char*)memory[idx];</span><br><span class="line">        NSString *str &#x3D; [NSString stringWithUTF8String:string];</span><br><span class="line">        if(!str)continue;</span><br><span class="line">        </span><br><span class="line">        BHLog(@&quot;config &#x3D; %@&quot;, str);</span><br><span class="line">        if(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return configs; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、读取本地Pilst文件"><a href="#2、读取本地Pilst文件" class="headerlink" title="2、读取本地Pilst文件"></a>2、读取本地Pilst文件</h4><ul>
<li>首先，需要设置好路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BHContext shareInstance].moduleConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BeeHive&quot;;&#x2F;&#x2F;可选，默认为BeeHive.bundle&#x2F;BeeHive.plist</span><br></pre></td></tr></table></figure>

<p>创建plist文件，<code>Plist</code>文件的格式也是数组中包含多个字典。字典里面有两个Key，一个是<code>@&quot;moduleLevel&quot;</code>，另一个是<code>@&quot;moduleClass&quot;</code>。注意<code>根</code>的数组的名字叫<code>@“moduleClasses”</code>。</p>
<p>![image.png](iOS架构 - 组件化方案 (2)/00203bd5fb6f4b58ae880570cd684117.png)</p>
<ul>
<li>进入<code>loadLocalModules</code>方法，主要是从<code>Plist</code>里面取出数组，然后把数组加入到<code>BHModuleInfos</code>数组里面。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化context时，加载Modules和Services</span><br><span class="line">-(void)setContext:(BHContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    _context &#x3D; context;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [self loadStaticServices];</span><br><span class="line">        [self loadStaticModules];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">&#x2F;&#x2F;加载modules</span><br><span class="line">- (void)loadStaticModules</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 读取本地plist文件里面的Module，并注册到BHModuleManager的BHModuleInfos数组中</span><br><span class="line">    [[BHModuleManager sharedManager] loadLocalModules];</span><br><span class="line">    &#x2F;&#x2F;注册所有modules，在内部根据优先级进行排序</span><br><span class="line">    [[BHModuleManager sharedManager] registedAllModules];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)loadLocalModules</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;plist文件路径</span><br><span class="line">    NSString *plistPath &#x3D; [[NSBundle mainBundle] pathForResource:[BHContext shareInstance].moduleConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    &#x2F;&#x2F;判断文件是否存在</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;读取整个文件[@&quot;moduleClasses&quot; : 数组]</span><br><span class="line">    NSDictionary *moduleList &#x3D; [[NSDictionary alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    &#x2F;&#x2F;通过moduleClasses key读取 数组 [[@&quot;moduleClass&quot;:&quot;aaa&quot;, @&quot;moduleLevel&quot;: @&quot;bbb&quot;], [...]]</span><br><span class="line">    NSArray&lt;NSDictionary *&gt; *modulesArray &#x3D; [moduleList objectForKey:kModuleArrayKey];</span><br><span class="line">    NSMutableDictionary&lt;NSString *, NSNumber *&gt; *moduleInfoByClass &#x3D; @&#123;&#125;.mutableCopy;</span><br><span class="line">    &#x2F;&#x2F;遍历数组</span><br><span class="line">    [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        [moduleInfoByClass setObject:@1 forKey:[obj objectForKey:kModuleInfoNameKey]];</span><br><span class="line">    &#125;];</span><br><span class="line">    [modulesArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if (!moduleInfoByClass[[obj objectForKey:kModuleInfoNameKey]]) &#123;</span><br><span class="line">            &#x2F;&#x2F;存储到 BHModuleInfos 中</span><br><span class="line">            [self.BHModuleInfos addObject:obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、load方法注册"><a href="#3、load方法注册" class="headerlink" title="3、load方法注册"></a>3、load方法注册</h4><p>该方法<code>注册Module</code>就是在<code>Load</code>方法里面注册Module的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    [BeeHive registerDynamicModule:[self class]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>进入<code>registerDynamicModule</code>实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] registerDynamicModule:moduleClass];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [self registerDynamicModule:moduleClass shouldTriggerInitEvent:NO];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">       shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent</span><br><span class="line">&#123;</span><br><span class="line">    [self addModuleFromObject:moduleClass shouldTriggerInitEvent:shouldTriggerInitEvent];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其底层还是同第一种方式一样，最终会走到<code>addModuleFromObject:shouldTriggerInitEvent:</code>方法中</p>
<ul>
<li>load方法，还可以使用<code>BH_EXPORT_MODULE</code>宏代替</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define BH_EXPORT_MODULE(isAsync) \</span><br><span class="line">+ (void)load &#123; [BeeHive registerDynamicModule:[self class]]; &#125; \</span><br><span class="line">-(BOOL)async &#123; return [[NSString stringWithUTF8String:#isAsync] boolValue];&#125;</span><br></pre></td></tr></table></figure>

<p><code>BH_EXPORT_MODULE</code>宏里面可以传入一个参数，代表<code>是否异步加载Module模块</code>，如果是<code>YES</code>就是<code>异步加载</code>，如果是<code>NO</code>就是<code>同步加载</code>。</p>
<h3 id="2、BeeHive-模块事件"><a href="#2、BeeHive-模块事件" class="headerlink" title="2、BeeHive 模块事件"></a>2、BeeHive 模块事件</h3><p>BeeHive会给每个模块提供生命周期事件，用于与BeeHive宿主环境进行必要信息交互，感知模块生命周期的变化。</p>
<p>BeeHive各个模块会收到一些事件。在<code>BHModuleManager</code>中，所有的事件被定义成了<code>BHModuleEventType</code>枚举。如下所示，其中有2个事件很特殊，一个是<code>BHMInitEvent</code>，一个是<code>BHMTearDownEvent</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, BHModuleEventType)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;设置Module模块</span><br><span class="line">    BHMSetupEvent &#x3D; 0,</span><br><span class="line">    &#x2F;&#x2F;用于初始化Module模块，例如环境判断，根据不同环境进行不同初始化</span><br><span class="line">    BHMInitEvent,</span><br><span class="line">    &#x2F;&#x2F;用于拆除Module模块</span><br><span class="line">    BHMTearDownEvent,</span><br><span class="line">    BHMSplashEvent,</span><br><span class="line">    BHMQuickActionEvent,</span><br><span class="line">    BHMWillResignActiveEvent,</span><br><span class="line">    BHMDidEnterBackgroundEvent,</span><br><span class="line">    BHMWillEnterForegroundEvent,</span><br><span class="line">    BHMDidBecomeActiveEvent,</span><br><span class="line">    BHMWillTerminateEvent,</span><br><span class="line">    BHMUnmountEvent,</span><br><span class="line">    BHMOpenURLEvent,</span><br><span class="line">    BHMDidReceiveMemoryWarningEvent,</span><br><span class="line">    BHMDidFailToRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidReceiveRemoteNotificationEvent,</span><br><span class="line">    BHMDidReceiveLocalNotificationEvent,</span><br><span class="line">    BHMWillPresentNotificationEvent,</span><br><span class="line">    BHMDidReceiveNotificationResponseEvent,</span><br><span class="line">    BHMWillContinueUserActivityEvent,</span><br><span class="line">    BHMContinueUserActivityEvent,</span><br><span class="line">    BHMDidFailToContinueUserActivityEvent,</span><br><span class="line">    BHMDidUpdateUserActivityEvent,</span><br><span class="line">    BHMHandleWatchKitExtensionRequestEvent,</span><br><span class="line">    BHMDidCustomEvent &#x3D; 1000</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要分为三种</p>
<ul>
<li>1、<code>系统事件</code>：主要是指<code>Application生命周期事件</code>!<br>![image.png](iOS架构 - 组件化方案 (2)/457cc2e7bd1345e58e5ee7aa63e94df5.png)</li>
</ul>
<p>一般的做法是<code>AppDelegate</code>改为<code>继承自BHAppDelegate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface TestAppDelegate : BHAppDelegate &lt;UIApplicationDelegate&gt;</span><br></pre></td></tr></table></figure>

<p>2、<code>应用事件</code>：官方给出的流程图，其中<code>modSetup</code>、<code>modInit</code>等，可以用于编码实现各插件模块的设置与初始化。</p>
<p>![image.png](iOS架构 - 组件化方案 (2)/4dff469e37654d99b9c051fd7aafbad4.png)</p>
<ul>
<li>3、<code>自定义事件</code></li>
</ul>
<p>以上所有的事件都可以通过调用<code>BHModuleManager</code>的<code>triggerEvent:</code>来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">&#123;</span><br><span class="line">    [self triggerEvent:eventType withCustomParam:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">     withCustomParam:(NSDictionary *)customParam &#123;</span><br><span class="line">    [self handleModuleEvent:eventType forTarget:nil withCustomParam:customParam];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">#pragma mark - module protocol</span><br><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">          withCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    switch (eventType) &#123;</span><br><span class="line">            &#x2F;&#x2F;初始化事件</span><br><span class="line">        case BHMInitEvent:</span><br><span class="line">            &#x2F;&#x2F;special</span><br><span class="line">            [self handleModulesInitEventForTarget:nil withCustomParam :customParam];</span><br><span class="line">            break;</span><br><span class="line">            &#x2F;&#x2F;析构事件</span><br><span class="line">        case BHMTearDownEvent:</span><br><span class="line">            &#x2F;&#x2F;special</span><br><span class="line">            [self handleModulesTearDownEventForTarget:nil withCustomParam:customParam];</span><br><span class="line">            break;</span><br><span class="line">            &#x2F;&#x2F;其他3类事件</span><br><span class="line">        default: &#123;</span><br><span class="line">            NSString *selectorStr &#x3D; [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">            [self handleModuleEvent:eventType forTarget:nil withSeletorStr:selectorStr andCustomParam:customParam];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以发现，除去<code>BHMInitEvent</code>初始化事件和<code>BHMTearDownEvent</code>拆除Module事件这两个特殊事件以外，所有的事件都是调用的<code>handleModuleEvent:forTarget:withSeletorStr:andCustomParam:</code>方法，其内部实现主要是遍历 <code>moduleInstances</code> 实例数组，调用<code>performSelector:withObject:</code>方法实现对应方法调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">           withSeletorStr:(NSString *)selectorStr</span><br><span class="line">           andCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    BHContext *context &#x3D; [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam &#x3D; customParam;</span><br><span class="line">    context.customEvent &#x3D; eventType;</span><br><span class="line">    if (!selectorStr.length) &#123;</span><br><span class="line">        selectorStr &#x3D; [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    SEL seletor &#x3D; NSSelectorFromString(selectorStr);</span><br><span class="line">    if (!seletor) &#123;</span><br><span class="line">        selectorStr &#x3D; [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">        seletor &#x3D; NSSelectorFromString(selectorStr);</span><br><span class="line">    &#125;</span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances &#x3D; @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances &#x3D; [self.BHModulesByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;遍历 moduleInstances 实例数组，调用performSelector:withObject:方法实现对应方法调用</span><br><span class="line">    [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if ([moduleInstance respondsToSelector:seletor]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">            &#x2F;&#x2F;进行方法调用</span><br><span class="line">            [moduleInstance performSelector:seletor withObject:context];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">            </span><br><span class="line">            [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- %@&quot;, [moduleInstance class], NSStringFromSelector(seletor)]];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:这里所有的<code>Module</code>必须是遵循<code>BHModuleProtocol</code>的，否则无法接收到这些事件的消息。</p>
<h3 id="3、BeeHive模块调用"><a href="#3、BeeHive模块调用" class="headerlink" title="3、BeeHive模块调用"></a>3、BeeHive模块调用</h3><p>在BeeHive中是通过<code>BHServiceManager</code>来管理各个<code>Protocol</code>的。<code>BHServiceManager</code>中只会管理已经<code>被注册过的Protocol</code>。</p>
<p>注册<code>Protocol</code>的方式总共有三种，和注册<code>Module</code>是一样一一对应的</p>
<p>**<br>**</p>
<p><strong>1、Annotation方式注册</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;****** 1、通过BeeHiveService宏进行Annotation标记</span><br><span class="line">BeeHiveService(HomeServiceProtocol,BHViewController)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;****** 2、宏定义</span><br><span class="line">#define BeeHiveService(servicename,impl) \</span><br><span class="line">class BeeHive; char * k##servicename##_service BeeHiveDATA(BeehiveServices) &#x3D; &quot;&#123; \&quot;&quot;#servicename&quot;\&quot; : \&quot;&quot;#impl&quot;\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;****** 3、转换后的格式，也是将其存储到特殊的段</span><br><span class="line">char * kHomeServiceProtocol_service __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot; &quot;))) &#x3D; &quot;&#123; \&quot;&quot;&quot;HomeServiceProtocol&quot;&quot;\&quot; : \&quot;&quot;&quot;BHViewController&quot;&quot;\&quot;&#125;&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>2、读取本地plist文件</strong></p>
<p>**<br>**</p>
<ul>
<li>首先同Module一样，需要先设置好路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BHContext shareInstance].serviceConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BHService&quot;;</span><br></pre></td></tr></table></figure>

<p>设置plist文件</p>
<p>![image.png](iOS架构 - 组件化方案 (2)/4df6cb91860d497cbd80e60c033dae9c.png)</p>
<ul>
<li>同样也是在<code>setContext</code>时注册<code>services</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;加载services</span><br><span class="line">-(void)loadStaticServices</span><br><span class="line">&#123;</span><br><span class="line">    [BHServiceManager sharedManager].enableException &#x3D; self.enableException;</span><br><span class="line">    </span><br><span class="line">    [[BHServiceManager sharedManager] registerLocalServices];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerLocalServices</span><br><span class="line">&#123;</span><br><span class="line">    NSString *serviceConfigName &#x3D; [BHContext shareInstance].serviceConfigName;</span><br><span class="line">    &#x2F;&#x2F;获取plist文件路径</span><br><span class="line">    NSString *plistPath &#x3D; [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    if (!plistPath) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSArray *serviceList &#x3D; [[NSArray alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    [self.lock lock];</span><br><span class="line">    &#x2F;&#x2F;遍历并存储到allServicesDict中</span><br><span class="line">    for (NSDictionary *dict in serviceList) &#123;</span><br><span class="line">        NSString *protocolKey &#x3D; [dict objectForKey:@&quot;service&quot;];</span><br><span class="line">        NSString *protocolImplClass &#x3D; [dict objectForKey:@&quot;impl&quot;];</span><br><span class="line">        if (protocolKey.length &gt; 0 &amp;&amp; protocolImplClass.length &gt; 0) &#123;</span><br><span class="line">            [self.allServicesDict addEntriesFromDictionary:@&#123;protocolKey:protocolImplClass&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、load方法注册</strong></p>
<p>**<br>**</p>
<p>在Load方法里面注册<code>Protocol</code>协议，主要是调用<code>BeeHive</code>里面的<code>registerService:service:</code>完成<code>protocol</code>的注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">   [[BeeHive shareInstance] registerService:@protocol(UserTrackServiceProtocol) service:[BHUserTrackViewController class]];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerService:(Protocol *)proto service:(Class) serviceClass</span><br><span class="line">&#123;</span><br><span class="line">    [[BHServiceManager sharedManager] registerService:proto implClass:serviceClass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，三种方式就创建完成了</p>
<p><strong>Protocol的获取</strong></p>
<p>**<br>**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Protocol&#96;与&#96;Module&#96;的区别在于，&#96;Protocol&#96;比&#96;Module&#96;多了一个方法，可以&#96;返回Protocol实例对象</span><br><span class="line">- (id)createService:(Protocol *)proto;</span><br><span class="line">&#123;</span><br><span class="line">    return [[BHServiceManager sharedManager] createService:proto];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service</span><br><span class="line">&#123;</span><br><span class="line">    return [self createService:service withServiceName:nil];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName &#123;</span><br><span class="line">    return [self createService:service withServiceName:serviceName shouldCache:YES];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName shouldCache:(BOOL)shouldCache &#123;</span><br><span class="line">    if (!serviceName.length) &#123;</span><br><span class="line">        serviceName &#x3D; NSStringFromProtocol(service);</span><br><span class="line">    &#125;</span><br><span class="line">    id implInstance &#x3D; nil;</span><br><span class="line">    &#x2F;&#x2F;判断protocol是否已经注册过</span><br><span class="line">    if (![self checkValidService:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol does not been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *serviceStr &#x3D; serviceName;</span><br><span class="line">    &#x2F;&#x2F;如果有缓存，则直接从缓存中获取</span><br><span class="line">    if (shouldCache) &#123;</span><br><span class="line">        id protocolImpl &#x3D; [[BHContext shareInstance] getServiceInstanceFromServiceName:serviceStr];</span><br><span class="line">        if (protocolImpl) &#123;</span><br><span class="line">            return protocolImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取类后，然后响应下层的方法</span><br><span class="line">    Class implClass &#x3D; [self serviceImplClass:service];</span><br><span class="line">    if ([[implClass class] respondsToSelector:@selector(singleton)]) &#123;</span><br><span class="line">        if ([[implClass class] singleton]) &#123;</span><br><span class="line">            if ([[implClass class] respondsToSelector:@selector(shareInstance)])</span><br><span class="line">                &#x2F;&#x2F;创建单例对象</span><br><span class="line">                implInstance &#x3D; [[implClass class] shareInstance];</span><br><span class="line">            else</span><br><span class="line">                &#x2F;&#x2F;创建实例对象</span><br><span class="line">                implInstance &#x3D; [[implClass alloc] init];</span><br><span class="line">            if (shouldCache) &#123;</span><br><span class="line">                &#x2F;&#x2F;缓存</span><br><span class="line">                [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [[implClass alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createService</code>会先检查Protocol协议是否是注册过的。然后接着取出字典里面对应的Class，如果实现了<code>shareInstance</code>方法，那么就创建一个<code>单例对象</code>，如果没有，那么就创建一个<code>实例对象</code>。如果还实现了singleton，就能进一步的把<code>implInstance</code>和<code>serviceStr</code>对应的加到<code>BHContext</code>的<code>servicesByName</code>字典里面<code>缓存</code>起来。这样就可以随着上下文传递了</p>
<ul>
<li>进入<code>serviceImplClass</code>实现，从这里可以看出 protocol和类是通过<code>字典</code>绑定的，<code>protocol</code>作为<code>key</code>，<code>serviceImp</code>（类的名字）作为<code>value</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (Class)serviceImplClass:(Protocol *)service</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;通过字典将 协议 和 类 绑定，其中协议作为key，serviceImp（类的名字）作为value</span><br><span class="line">    NSString *serviceImpl &#x3D; [[self servicesDict] objectForKey:NSStringFromProtocol(service)];</span><br><span class="line">    if (serviceImpl.length &gt; 0) &#123;</span><br><span class="line">        return NSClassFromString(serviceImpl);</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Module-amp-Protocol"><a href="#Module-amp-Protocol" class="headerlink" title="Module &amp; Protocol"></a>Module &amp; Protocol</h3><p>这里简单总结下：</p>
<ul>
<li>对于<code>Module</code>：数组存储</li>
<li>对于<code>Protocol</code>：通过字典将<code>protocol</code>与类进行绑定，<code>key</code>为<code>protocol</code>，<code>value</code>为 <code>serviceImp</code>即类名</li>
</ul>
<h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><ul>
<li><code>BHConfig</code>类：是一个单例，其内部有一个<code>NSMutableDictionary</code>类型的<code>config</code>属性，该属性维护了一些动态的环境变量，作为<code>BHContext</code>的补充存在</li>
<li><code>BHContext</code>类：是一个单例，其内部有两个<code>NSMutableDictionary</code>的属性，分别是<code>modulesByName</code> 和 <code>servicesByName</code>。这个类主要用来保存上下文信息的。例如在<code>application:didFinishLaunchingWithOptions:</code>的时候，就可以初始化大量的上下文信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;保存信息</span><br><span class="line">[BHContext shareInstance].application &#x3D; application;</span><br><span class="line">[BHContext shareInstance].launchOptions &#x3D; launchOptions;</span><br><span class="line">[BHContext shareInstance].moduleConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BeeHive&quot;;&#x2F;&#x2F;可选，默认为BeeHive.bundle&#x2F;BeeHive.plist</span><br><span class="line">[BHContext shareInstance].serviceConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BHService&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>BHTimeProfiler</code>类：用来进行计算时间性能方面的Profiler</li>
<li><code>BHWatchDog</code>类：用来开一个线程，监听主线程是否堵塞</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="blog.cfjia.cc/2022/03/22/iOS%E6%9E%B6%E6%9E%84%20-%20%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%20(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cfjia">
      <meta itemprop="description" content="cfjia个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑夜里的眸">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/22/iOS%E6%9E%B6%E6%9E%84%20-%20%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%20(1)/" class="post-title-link" itemprop="url">iOS架构 - 组件化方案 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-22 13:52:16" itemprop="dateCreated datePublished" datetime="2022-03-22T13:52:16+08:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-03 21:33:50" itemprop="dateModified" datetime="2023-01-03T21:33:50+08:00">2023-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">iOS进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>组件化其实就是<code>将模块单独抽离、分层</code>，并指定模块间的<code>通讯</code>方式，从而实现<code>解耦</code>的一种方式，主要运用与团队开发</p>
<h4 id="为什么需要组件化？"><a href="#为什么需要组件化？" class="headerlink" title="为什么需要组件化？"></a>为什么需要组件化？</h4><p>主要有以下四个原因</p>
<ul>
<li>1、模块间解耦</li>
<li>2、模块重用</li>
<li>3、提高团队协作开发效率</li>
<li>4、单元测试</li>
</ul>
<p>当项目因为各种需求，越来越来时，如果此时的各个模块之间是互相调用，即<code>你中有我，我中有你</code>这种情况时，会造成<code>高耦合</code>的情况。一旦我们需要对某一块代码进行<code>修改</code>时，就会<code>牵一发而动全身</code>，导致项目难以维护</p>
<p>其问题主要体现在以下几个方面：</p>
<ul>
<li>1、修改某个功能时，同时需要修改其他模块的代码，因为在其他模块中有该模块的引用。可以理解为<code>高耦合导致代码修改困难</code></li>
<li>2、模块对外接口不明确，甚至暴露了本不该暴露的私有接口，修改时费时费力。可以理解为<code>接口不固定导致的接口混乱</code></li>
<li>3、高耦合代码产生的后果就是会影响团队其他成员的开发，产生<code>代码冲突</code></li>
<li>4、当模块需要重用到其他项目时，<code>难以单独抽离</code></li>
<li>5、模块间耦合的忌口导致接口和依赖关系混乱，<code>无法进行单元测试</code></li>
</ul>
<p>所以为了解决以上问题，我们需要采用更规范的方式来<code>降低模块</code>间的<code>耦合度</code>，这就是<code>组件化</code>，也可以理解为<code>模块化</code></p>
<p>但是，这里还需要说明一点，因为组件化也是需要一定成本的，需要花费时间设计接口、分离代码等，所以并不是所有的项目都需要组件化。如果你的项目有以下这些特征就<code>不需要组件化</code>：</p>
<ul>
<li>1、项目较小，模块间交互简单，耦合少</li>
<li>2、项目没有被多个外部模块引用，只是一个单独的小模块</li>
<li>3、模块不需要重用，代码也很少被修改</li>
<li>4、团队规模很小</li>
<li>5、不需要编写单元测试</li>
</ul>
<p>如果你的有以下特性，说明你就必须要<code>考虑进行组件化</code>了：</p>
<ul>
<li>1、模块逻辑复杂，多个模块之间频繁互相引用</li>
<li>2、项目规模逐渐变大，修改代码变的越来越困难（这里可以理解为：修改一处代码，需要同时修改其他多个地方）</li>
<li>3、团队人数变多，提交的代码经常和其他成员冲突</li>
<li>4、项目编译耗时较大</li>
<li>5、模块的单元测试经常由于其他模块的修改而失败</li>
</ul>
<h3 id="组件化方案"><a href="#组件化方案" class="headerlink" title="组件化方案"></a>组件化方案</h3><h4 id="组件化方案的8条指标"><a href="#组件化方案的8条指标" class="headerlink" title="组件化方案的8条指标"></a>组件化方案的8条指标</h4><p>一个项目经过组件化后如何来评判，主要有以下几个<code>标准</code>：</p>
<ul>
<li>1、模块之间没有耦合，模块内部的修改不会应该其他模块</li>
<li>2、模块可以单独编译</li>
<li>3、模块间数据传递明确</li>
<li>4、模块可以随时被另一个提供了相同功能的模块替换</li>
<li>5、模块对外接口清晰且易维护</li>
<li>6、当模块接口改变时，此模块的外部代码能够被高效重构</li>
<li>7、尽量用最少的修改和代码，让现有的项目实现模块化</li>
<li>8、支持OC和Swift，以及混编</li>
</ul>
<p>前4条主要用于<code>衡量一个模块是否真正解耦</code>，后4条主要用于衡量在项目中<code>实践中的易用程度</code></p>
<h4 id="组件化原则"><a href="#组件化原则" class="headerlink" title="组件化原则"></a>组件化原则</h4><p>一个项目主要分为3层：<code>业务层</code>、<code>通用层</code>以及<code>基础层</code>，在进行组件化时，有以下几点说明</p>
<p>![image.png](iOS架构 - 组件化方案 (1)/d45435499bcd48d69596779b778e2b39.png)</p>
<ul>
<li>只能上层对依赖，不能下层对上层的依赖，因为下层是对上层的抽象</li>
<li>项目公共代码资源下沉</li>
<li>横向的依赖尽量少有，最好下层至通用模块，或者基础模块</li>
</ul>
<p>**<br>**</p>
<h4 id="组件化方案-1"><a href="#组件化方案-1" class="headerlink" title="组件化方案"></a>组件化方案</h4><p>常用的组件化方案主要有两种：</p>
<ul>
<li><code>本地组件化</code>：主要是通过在<code>工程中创建library</code>，利用<code>cocoapods</code>的<code>workspec</code>进行本地管理，不需要将项目上传git，而是直接在本项目中以framework的方法进行调用</li>
<li><code>cocoapods组件化</code>：主要是利用cocoapods来进行模块的远程管理，需要将项目上传git（需要注意：这里的组件化模块分为<code>公有库</code>和<code>私有库</code>，对公司而言，一般是私有库）</li>
</ul>
<h3 id="本地组件化"><a href="#本地组件化" class="headerlink" title="本地组件化"></a>本地组件化</h3><h4 id="1、创建主工程"><a href="#1、创建主工程" class="headerlink" title="1、创建主工程"></a>1、创建主工程</h4><ul>
<li>首先创建一个工程</li>
</ul>
<p>![image.png](iOS架构 - 组件化方案 (1)/d411eb30e54b48faa116bde3c19dd158.png)</p>
<ul>
<li>集成cocopods，进行本地管理：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd 项目目录</span><br><span class="line">$ pod init</span><br><span class="line">$ pod init</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑podfile，并执行<code>pod install</code></li>
</ul>
<h4 id="2、创建组件"><a href="#2、创建组件" class="headerlink" title="2、创建组件"></a>2、创建组件</h4><p>假设有以下几个模块：</p>
<ul>
<li><code>主工程</code>：承载主要的表层业务代码</li>
<li><code>Core</code>：独立存在，应用加密、接口请求等敏感代码</li>
<li><code>Base</code>：基类封装，拓展，基本的数据处理</li>
<li><code>Service</code>：服务层，封装业务工具类，例如网络层服务、持久化服务等</li>
<li><code>Pods</code>：三方依赖</li>
</ul>
<p>其中，各个模块间的关系如下所示</p>
<p>![image.png](iOS架构 - 组件化方案 (1)/abbca02925474c55ac37f24181eb711b.png)</p>
<p>下面，我们来进行模块的创建，以<code>Core</code>模块为例：</p>
<ul>
<li>选择<code>new -&gt; project -&gt; iOS -&gt; Framework</code>，新建一个模块<br>![image.png](iOS架构 - 组件化方案 (1)/6e8b46b343d14fc4966346a3eb3734b1.png)选择正确的<code>Group</code> 和 <code>WorkSpace</code>（这里需要注意一点：创建的<code>library</code>最好放在<code>主工程根目录</code>下，否则后续<code>podfile</code>执行<code>pod install</code>时会报错）</li>
</ul>
<p>![image.png](iOS架构 - 组件化方案 (1)/57123daa0cf14b7d9c4878ed22645786.png)</p>
<p>将创建的<code>library</code>的<code>Build Settings -&gt; Mach-O Type</code>修改为静态库 <code>Static Library</code></p>
<p>![image.png](iOS架构 - 组件化方案 (1)/cd442535e97c43e880a4a8e743df2f92.png)</p>
<h4 id="3、主工程调用library"><a href="#3、主工程调用library" class="headerlink" title="3、主工程调用library"></a>3、主工程调用library</h4><ul>
<li>在CJLCore中新建一个文件，并添加如下代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类需要声明为public</span><br><span class="line">public class CJLCoreSetting: NSObject &#123;</span><br><span class="line">    &#x2F;&#x2F;属性需要声明为public</span><br><span class="line">    public static let SCRET_KEY &#x3D; &quot;SCRET_KEY&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Build Phases -&gt; Headers -&gt; Public</code>中将新建的文件添加为public，这样主工程才能访问该文件</p>
<p>![image.png](iOS架构 - 组件化方案 (1)/dc187aeebe7e457bbd5440e924d005b4.png)</p>
<p>在主工程中，选择<code>target -&gt; Linked Frameworks Library</code>中添加<code>CJLCore</code>，只需要build主工程，library能够自动联编</p>
<p>![image.png](iOS架构 - 组件化方案 (1)/36ce602f6cd04273831cd6ddafae8874.png)</p>
<h4 id="4、使用"><a href="#4、使用" class="headerlink" title="4、使用"></a>4、使用</h4><p>首先<code>import CJLCore</code>，然后使用</p>
<p>![image.png](iOS架构 - 组件化方案 (1)/ddb88b2f9adb401abe5f6e259cf8bf0d.png)</p>
<p>这里需要注意的是，子library之间的互相调用，与主工程调用library类似，主需要添加依赖、暴露header即可</p>
<h4 id="5、使用cocoapods管理三方依赖"><a href="#5、使用cocoapods管理三方依赖" class="headerlink" title="5、使用cocoapods管理三方依赖"></a>5、使用cocoapods管理三方依赖</h4><p>假设我们需要在<code>CJLCore</code>中封装网络层代码，需要用到三方库<code>Alamofire</code>，在podfile中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;9.0&#39;</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">#配置workspace路径</span><br><span class="line">workspace &#39;Modularization.xcworkspace&#39;</span><br><span class="line"></span><br><span class="line">################# 三方依赖</span><br><span class="line"># 公有</span><br><span class="line">def workspace_pods</span><br><span class="line">  pod &#39;SwiftyJSON&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># 主工程</span><br><span class="line">def project_only_pods</span><br><span class="line">  pod &#39;SnapKit&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#网络</span><br><span class="line">def network_layer_pods</span><br><span class="line">  pod &#39;Alamofire&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">################# 模块</span><br><span class="line">target &#39;CJLCore&#39; do</span><br><span class="line">  #配置libray路径</span><br><span class="line">  project &#39;CJLCore&#x2F;CJLCore.xcodeproj&#39;</span><br><span class="line">  </span><br><span class="line">  workspace_pods</span><br><span class="line">  network_layer_pods</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">################# 主工程</span><br><span class="line">target &#39;Modularization&#39; do</span><br><span class="line">  </span><br><span class="line">  workspace_pods</span><br><span class="line">  project_only_pods</span><br><span class="line">  network_layer_pods</span><br><span class="line"></span><br><span class="line">  target &#39;ModularizationTests&#39; do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  target &#39;ModularizationUITests&#39; do</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>到此，一个本地组件化的模块就配置完成了</p>
<h3 id="cocoapods组件化"><a href="#cocoapods组件化" class="headerlink" title="cocoapods组件化"></a>cocoapods组件化</h3><p>除了本地组件化，还可以使用<code>cocoapods</code>，其原理如下图所示</p>
<p>![image.png](iOS架构 - 组件化方案 (1)/a9afd9886f6b49919a262e3f893e6fc8.png)这里还是以本地组件化中的结构为例</p>
<h4 id="1、创建私有仓库"><a href="#1、创建私有仓库" class="headerlink" title="1、创建私有仓库"></a>1、创建私有仓库</h4><ul>
<li>在github上创建一个MySpecs仓库<br>具体步骤：登录github–&gt;点击右上角“+”–&gt;选择 new repository–&gt;输入Repository name为MySpecs，选择仓库类型为 private，点击Create repository。</li>
<li>将私有仓库添加至本地<code>~/.cocoapods/repos</code>目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add mySpecs https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;MySpecs.git</span><br></pre></td></tr></table></figure>



<h4 id="2、创建pods-工程，即组件化工程"><a href="#2、创建pods-工程，即组件化工程" class="headerlink" title="2、创建pods 工程，即组件化工程"></a>2、创建pods 工程，即组件化工程</h4><ul>
<li>使用终端创建<code>CJLServices</code>模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create CJLServices</span><br></pre></td></tr></table></figure>

<p>根据提示依次输入：ios、swift、yes、none、no、CJL</p>
<p>![image.png](iOS架构 - 组件化方案 (1)/5565cf790f424ae58611554ee82710a0.png)</p>
<p>进入模块的目录，将文件拷贝至<code>CJLServices -&gt; Classes</code>中</p>
<p>![image.png](iOS架构 - 组件化方案 (1)/444cac4f432a471d87197d9ff4be77a5.png)</p>
<p>执行<code>pod install</code>,会将Classes更新至pods中</p>
<p>![image.png](iOS架构 - 组件化方案 (1)/c66728c4363547cf87afd5817637a90b.png)</p>
<p>执行结果</p>
<h4 id="3、配置pods工程"><a href="#3、配置pods工程" class="headerlink" title="3、配置pods工程"></a>3、配置pods工程</h4><p>修改模块的配置文件，即<code>CJLServices.podspec</code></p>
<ul>
<li>如果需要依赖三方库，需要配置<code>s.dependency</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.dependency &#39;AFNetworking&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果模块间需要相互引用，同样需要配置<code>s.dependency</code>，以<code>CJLBase</code>为例，需要引用<code>CJLService</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;********1、修改 podspec 文件</span><br><span class="line">s.dependency &#39;CJLServices&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;********2、修改 podfile 文件</span><br><span class="line">pod &#39;CJLServices&#39;, :path &#x3D;&gt; &#39;..&#x2F;..&#x2F;CJLServices&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果需要加载资源，例如图片、json、bundle文件等</li>
</ul>
<ul>
<li><ul>
<li>1、在模块的<code>Assets</code>文件夹 中添加资源文件</li>
<li>2、在<code>specs</code>里配置资源路径（必须配置！！否则无法读取资源）</li>
<li>3、访问时需要指定资源文件路径</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;*****1、修改 podspec 文件</span><br><span class="line">s.resource_bundles &#x3D; &#123;</span><br><span class="line">     &#39;CJLBase&#39; &#x3D;&gt; [&#39;CJLBase&#x2F;Assets&#x2F;*&#39;]</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#x2F;&#x2F;*****2、使用</span><br><span class="line">let bundlePath: String &#x3D; Bundle.init(for: dynamicClass.self).resourcePath! + &quot;&#x2F;CJLBase.bundle&quot;</span><br><span class="line">let bundle &#x3D; Bundle(path: bundlePath)</span><br><span class="line">if let path &#x3D; bundle?.path(forResource: &quot;mouse&quot;, ofType: &quot;jpg&quot;)&#123;</span><br><span class="line">    self.imgView.image &#x3D; UIImage(contentsOfFile: path)</span><br><span class="line">&#125;           </span><br></pre></td></tr></table></figure>

<p>同理，模块中的xib，json文件的获取方式也是一样的</p>
<h4 id="4、提交至git"><a href="#4、提交至git" class="headerlink" title="4、提交至git"></a>4、提交至git</h4><p>这里提交至git的模块是pods工程才可以，以<code>CJLBase</code>为例</p>
<ul>
<li>需要在github上创建一个私有repository，命名为<code>CJLBase</code></li>
<li>执行以下终端命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$git init</span><br><span class="line">$git add .</span><br><span class="line">$ git commit -am &quot;第一次提交&quot; </span><br><span class="line">&#x2F;&#x2F;即第一个步骤中创建的仓库地址</span><br><span class="line">$ git remote add origin https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;CJLBase.git</span><br><span class="line"> </span><br><span class="line">$ git push origin master </span><br><span class="line">&#x2F;&#x2F;一定要有标签，不然会有下面的警告</span><br><span class="line">&#x2F;&#x2F;podspec文件中获取Git版本控制的项目需要tag号，</span><br><span class="line">$ git tag -m &quot;first release&quot; &quot;0.1.0&quot; </span><br><span class="line">$ git push --tags </span><br></pre></td></tr></table></figure>



<h4 id="5、验证podspec文件"><a href="#5、验证podspec文件" class="headerlink" title="5、验证podspec文件"></a>5、验证podspec文件</h4><p>执行终端命令 <code>pod spec lint</code></p>
<blockquote>
<p>注意：<code>pod spec</code>相对于<code>pod lib</code>会更为精确，</p>
<ul>
<li><code>pod lib</code>相当于只验证一个本地仓库，</li>
<li><code>pod spec</code>会同时验证本地仓库和远程仓库。</li>
</ul>
</blockquote>
<p>**<br>**</p>
<h4 id="6、提交到私有仓库"><a href="#6、提交到私有仓库" class="headerlink" title="6、提交到私有仓库"></a>6、提交到私有仓库</h4><p>执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pod repo push [本地Spec Repo名称][podspec文件路径]</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;******举例</span><br><span class="line">$ pod repo push MySpecs CJLBase.podspec</span><br></pre></td></tr></table></figure>

<p>提交成功后，可在本地仓库中看到提交路径<code>MySpecs -&gt; CJLBase</code></p>
<h4 id="7、使用"><a href="#7、使用" class="headerlink" title="7、使用"></a>7、使用</h4><ul>
<li>新建一个工程，在项目的podfile里添加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#私有spec仓库的地址，而不是某个pod仓库的地址</span><br><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;MySpecs&#39;</span><br><span class="line">pod &#39;CJLBase&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行<code>pod install</code>即可</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="blog.cfjia.cc/2021/12/02/RunLoop-Part2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cfjia">
      <meta itemprop="description" content="cfjia个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑夜里的眸">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/02/RunLoop-Part2/" class="post-title-link" itemprop="url">RunLoop的应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-02 10:10:44" itemprop="dateCreated datePublished" datetime="2021-12-02T10:10:44+08:00">2021-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-14 22:02:26" itemprop="dateModified" datetime="2022-04-14T22:02:26+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">iOS进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、RunLoop与线程"><a href="#一、RunLoop与线程" class="headerlink" title="一、RunLoop与线程"></a>一、RunLoop与线程</h1><h2 id="1-RunLoop与线程的关系"><a href="#1-RunLoop与线程的关系" class="headerlink" title="1. RunLoop与线程的关系"></a>1. RunLoop与线程的关系</h2><p>苹果官方文档中，<code>RunLoop</code>的相关介绍写在线程编程指南中，可见<code>RunLoop</code>和线程的关系不一般。<a href="https://link.juejin.cn/?target=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html%23//apple_ref/doc/uid/10000057i-CH16-SW23">Threading Programming Guide（苹果官方文档）</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 访问 loopsDic 时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;&#x2F; 获取一个 pthread 对应的 RunLoop。</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        &#x2F;&#x2F; 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span><br><span class="line">        loopsDic &#x3D; CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop &#x3D; _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 直接从 Dictionary 里获取。</span><br><span class="line">    CFRunLoopRef loop &#x3D; CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 取不到时，创建一个</span><br><span class="line">        loop &#x3D; _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/02/RunLoop-Part2/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="blog.cfjia.cc/2021/11/22/RunLoop-Part1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cfjia">
      <meta itemprop="description" content="cfjia个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑夜里的眸">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/22/RunLoop-Part1/" class="post-title-link" itemprop="url">RunLoop的原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-22 13:52:16" itemprop="dateCreated datePublished" datetime="2021-11-22T13:52:16+08:00">2021-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-14 22:02:33" itemprop="dateModified" datetime="2022-04-14T22:02:33+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">iOS进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、RunLoop概念"><a href="#一、RunLoop概念" class="headerlink" title="一、RunLoop概念"></a>一、RunLoop概念</h1><p>RunLoop，顾名思义其实就是一个循环，而通过这个循环能帮助我们理解以及解决什么问题就是我们值得思考的事情了。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><ul>
<li>没有消息需要处理时，休眠线程以避免资源占用。从用户态切换到内核态，等待消息；</li>
<li>有消息需要处理时，立刻唤醒线程，回到用户态处理消息；</li>
<li>通过调用mach_msg()函数来转移当前线程的控制权给内核态/用户态</li>
</ul>
<h3 id="RunLoop作用"><a href="#RunLoop作用" class="headerlink" title="RunLoop作用"></a>RunLoop作用</h3><ul>
<li><p>保持程序的持续运行：</p>
<p>如果没有RunLoop，main()函数一执行完，程序就会立刻退出。而我们的iOS程序能保持持续运行的原因就是在main()函数中调用了UIApplicationMain函数，这个函数内部会启动主线程的RunLoop;</p>
</li>
<li><p>处理App中的各种事件（比如触摸事件、定时器事件等）；</p>
</li>
<li><p>节省CPU资源，提高程序性能; </p>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/11/22/RunLoop-Part1/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="blog.cfjia.cc/2021/11/02/Runtime-Part2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cfjia">
      <meta itemprop="description" content="cfjia个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑夜里的眸">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/02/Runtime-Part2/" class="post-title-link" itemprop="url">Runtime - 进阶篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-02 10:21:58" itemprop="dateCreated datePublished" datetime="2021-11-02T10:21:58+08:00">2021-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-05 10:26:12" itemprop="dateModified" datetime="2021-11-05T10:26:12+08:00">2021-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">iOS进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、动态方法交换：Method-Swizzling"><a href="#一、动态方法交换：Method-Swizzling" class="headerlink" title="一、动态方法交换：Method Swizzling"></a>一、动态方法交换：Method Swizzling</h1><p>实现动态方法交换(Method Swizzling )是Runtime中最具盛名的应用场景，其原理是：通过Runtime获取到方法实现的地址，进而动态交换两个方法的功能。使用到关键方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取类方法的Mthod</span></span><br><span class="line"><span class="type">Method</span> _Nullable class_getClassMethod(<span class="type">Class</span> _Nullable cls, <span class="type">SEL</span> _Nonnull name)</span><br><span class="line"><span class="comment">//获取实例对象方法的Mthod</span></span><br><span class="line"><span class="type">Method</span> _Nullable class_getInstanceMethod(<span class="type">Class</span> _Nullable cls, <span class="type">SEL</span> _Nonnull name)</span><br><span class="line"><span class="comment">//交换两个方法的实现</span></span><br><span class="line">void method_exchangeImplementations(<span class="type">Method</span> _Nonnull m1, <span class="type">Method</span> _Nonnull m2)</span><br></pre></td></tr></table></figure>

<h2 id="1-动态方法交换示例"><a href="#1-动态方法交换示例" class="headerlink" title="1. 动态方法交换示例"></a>1. 动态方法交换示例</h2><p>现在演示一个代码示例：在视图控制中，定义两个实例方法printA与printB，然后执行交换</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)printA&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印A......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printB&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印B......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换方法的实现，并测试打印</span></span><br><span class="line"><span class="type">Method</span> methodA = class_getInstanceMethod([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">printA</span>));</span></span><br><span class="line"><span class="class"><span class="title">Method</span> <span class="title">methodB</span> = <span class="title">class_getInstanceMethod</span>([<span class="title">self</span> <span class="title">class</span>], @<span class="title">selector</span>(<span class="title">printB</span>));</span></span><br><span class="line"><span class="class"><span class="title">method_exchangeImplementations</span>(<span class="title">methodA</span>, <span class="title">methodB</span>);</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">[<span class="title">self</span> <span class="title">printA</span>];  //打印<span class="title">B</span>......</span></span><br><span class="line"><span class="class">[<span class="title">self</span> <span class="title">printB</span>];  //打印<span class="title">A</span>......</span></span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/11/02/Runtime-Part2/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="blog.cfjia.cc/2021/11/01/Runtime-Part1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="cfjia">
      <meta itemprop="description" content="cfjia个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑夜里的眸">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/01/Runtime-Part1/" class="post-title-link" itemprop="url">Runtime - 基础篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-01 10:21:58" itemprop="dateCreated datePublished" datetime="2021-11-01T10:21:58+08:00">2021-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-05 10:55:00" itemprop="dateModified" datetime="2021-11-05T10:55:00+08:00">2021-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">iOS进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、什么是动态语言，什么是Runtime？"><a href="#一、什么是动态语言，什么是Runtime？" class="headerlink" title="一、什么是动态语言，什么是Runtime？"></a>一、什么是动态语言，什么是Runtime？</h1><h2 id="静态语言-强类型语言-："><a href="#静态语言-强类型语言-：" class="headerlink" title="静态语言(强类型语言)："></a>静态语言(强类型语言)：</h2><p>静态语言是在编译时就要确定变量的数据类型，也就是变量使用之前必须声明数据类型。如：C、C++、Java、C#等。</p>
<h2 id="动态语言-弱类型语言"><a href="#动态语言-弱类型语言" class="headerlink" title="动态语言(弱类型语言):"></a>动态语言(弱类型语言):</h2><p>动态语言是在运行时才去做数据类型检查的语言，变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。如：PHP、Ruby、Shell、Python等一些脚本语言。</p>
<h2 id="为什么说OC是一门动态语言"><a href="#为什么说OC是一门动态语言" class="headerlink" title="为什么说OC是一门动态语言:"></a>为什么说OC是一门动态语言:</h2><p>静态、动态是相对的，这里动态语言指的是不需要再编译阶段就确定所有变量方法等，还可以在运行时动态的添加。 Objective-C，在C语言的基础上添加了面向对象的特性，并且通过Runtime这个运行时机制，在运行时可以动态的添加变量，方法，类等，所以说Objective-C是一门动态语言。</p>
<h2 id="OC的动态性"><a href="#OC的动态性" class="headerlink" title="OC的动态性:"></a>OC的动态性:</h2><h3 id="1-动态类型"><a href="#1-动态类型" class="headerlink" title="1.动态类型:"></a>1.动态类型:</h3><p>如id类型。实际上静态类型因为其固定性和可预知性而使用的特别广泛。静态类型是强类型，动态类型是弱类型，运行时决定接收者。</p>
<h3 id="2-动态绑定"><a href="#2-动态绑定" class="headerlink" title="2.动态绑定:"></a>2.动态绑定:</h3><p>让代码在运行时判断需要调用什么方法，而不是在编译时。与其他面向对象语言一样，方法调用和代码并没有在编译时连接在一起，而是在消息发送时才进行连接。运行时决定调用哪个方法。</p>
<h3 id="3-动态载入"><a href="#3-动态载入" class="headerlink" title="3.动态载入:"></a>3.动态载入:</h3><p> 让程序在运行时添加代码模块已经其他资源。用户可以根据需要执行一些可执行代码和资源，而不是在启动时就加载所有资源组件。可执行代码中可以含有和程序运行时整合的新类。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/11/01/Runtime-Part1/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="cfjia"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">cfjia</p>
  <div class="site-description" itemprop="description">cfjia个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cfjia</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
