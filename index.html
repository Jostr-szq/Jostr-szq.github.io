<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <meta name="keywords" content="iOS">
  
  
  <meta name="description" content="cfjia个人博客">
  
  <title>
    
    黑夜里的眸
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.0.2"></head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">黑夜里的眸</a></h1>
      <p>黑夜降临的时候，黎明也就不远了...</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="黑夜里的眸"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-Runloop" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/11/04/Runloop/">Runloop详解</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/11/04/Runloop/" class="article-date">
  <time datetime="2021-11-04T14:26:24.000Z" itemprop="datePublished">2021-11-04</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/">iOS进阶</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <p>原理：</p>
<ol>
<li><p>什么是Runloop?</p>
<p>Runloop是一个调度任务和处理任务的事件循环。Runloop的目的是为了在有工作的时候让线程忙起来，而在没工作的时候让线程进入休眠状态。简单的说RunLoop是一种高级的循环机制，让程序持续运行，并处理程序中的各种事件，让线程在需要做事的时候忙起来，不需要的话就让线程休眠。</p>
</li>
<li><p>Runloop和线程？</p>
<p>RunLoop<code>和线程是绑定在一起的，每条线程都有唯一一个与之对应的</code>RunLoop对象<code>。不能自己创建</code>RunLoop对象<code>，但是可以获取系统提供的</code>RunLoop对象<code>。主线程的</code>RunLoop对象<code>是由系统自动创建好的，在应用程序启动的时候会自动完成启动，而子线程中的</code>RunLoop对象`需要我们手动获取并启动。</p>
<p>线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
</li>
<li><p>Runloop对外接口</p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p>苹果文档中提到的 Mode 有五个，分别是：</p>
<ul>
<li>NSDefaultRunLoopMode</li>
<li>NSConnectionReplyMode</li>
<li>NSModalPanelRunLoopMode</li>
<li>NSEventTrackingRunLoopMode</li>
<li>NSRunLoopCommonModes</li>
</ul>
<p>iOS 中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。 NSRunLoopCommonModes 实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode。</p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
</li>
</ol>
<p>实践</p>
<ol>
<li><p>AutoReleasePool</p>
<p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
</li>
<li><p>事件响应</p>
<p>mack port -&gt; source1回调 -&gt;source0回调 将IOHIDEvent对象封装成UIEvent对象，并放入UIApplication的事件队列中，单例的 UIApplication 会从事件队列中取出触摸事件并传递给单例的 UIWindow 来处理，UIWindow 对象首先会使用 <code>hitTest:withEvent:</code>方法寻找此次 Touch 操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为 hit-test view。</p>
<p><code>hitTest:withEvent:</code>方法的处理流程如下:</p>
<ul>
<li>首先调用当前视图的 <code>pointInside:withEvent:</code> 方法判断触摸点是否在当前视图内；</li>
<li>若返回 NO, 则 <code>hitTest:withEvent:</code> 返回 nil，若返回 YES, 则向当前视图的所有子视图 (subviews) 发送 <code>hitTest:withEvent:</code> 消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从 subviews 数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；</li>
<li>若第一次有子视图返回非空对象，则 <code>hitTest:withEvent:</code> 方法返回此对象，处理结束；</li>
<li>如所有子视图都返回空，则 hitTest:withEvent: 方法返回自身 (self)。</li>
</ul>
</li>
<li><p>NSTimer</p>
<p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
</li>
<li><p>performSelecter</p>
<p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
</li>
<li><p>线程保活</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="blog.cfjia.cc/2021/11/04/Runloop/" data-id="ckvlronxe00010d3q9hj2hvc5" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RunLoop/" rel="tag">RunLoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Runtime-Part2" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/11/02/Runtime-Part2/">Runtime - 进阶篇</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/11/02/Runtime-Part2/" class="article-date">
  <time datetime="2021-11-02T02:21:58.000Z" itemprop="datePublished">2021-11-02</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/">iOS进阶</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="一、动态方法交换：Method-Swizzling"><a href="#一、动态方法交换：Method-Swizzling" class="headerlink" title="一、动态方法交换：Method Swizzling"></a>一、动态方法交换：Method Swizzling</h1><p>实现动态方法交换(Method Swizzling )是Runtime中最具盛名的应用场景，其原理是：通过Runtime获取到方法实现的地址，进而动态交换两个方法的功能。使用到关键方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取类方法的Mthod</span></span><br><span class="line"><span class="type">Method</span> _Nullable class_getClassMethod(<span class="type">Class</span> _Nullable cls, <span class="type">SEL</span> _Nonnull name)</span><br><span class="line"><span class="comment">//获取实例对象方法的Mthod</span></span><br><span class="line"><span class="type">Method</span> _Nullable class_getInstanceMethod(<span class="type">Class</span> _Nullable cls, <span class="type">SEL</span> _Nonnull name)</span><br><span class="line"><span class="comment">//交换两个方法的实现</span></span><br><span class="line">void method_exchangeImplementations(<span class="type">Method</span> _Nonnull m1, <span class="type">Method</span> _Nonnull m2)</span><br></pre></td></tr></table></figure>

<h2 id="1-动态方法交换示例"><a href="#1-动态方法交换示例" class="headerlink" title="1. 动态方法交换示例"></a>1. 动态方法交换示例</h2><p>现在演示一个代码示例：在视图控制中，定义两个实例方法printA与printB，然后执行交换</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)printA&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印A......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printB&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印B......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换方法的实现，并测试打印</span></span><br><span class="line"><span class="type">Method</span> methodA = class_getInstanceMethod([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">printA</span>));</span></span><br><span class="line"><span class="class"><span class="title">Method</span> <span class="title">methodB</span> = <span class="title">class_getInstanceMethod</span>([<span class="title">self</span> <span class="title">class</span>], @<span class="title">selector</span>(<span class="title">printB</span>));</span></span><br><span class="line"><span class="class"><span class="title">method_exchangeImplementations</span>(<span class="title">methodA</span>, <span class="title">methodB</span>);</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">[<span class="title">self</span> <span class="title">printA</span>];  //打印<span class="title">B</span>......</span></span><br><span class="line"><span class="class">[<span class="title">self</span> <span class="title">printB</span>];  //打印<span class="title">A</span>......</span></span><br></pre></td></tr></table></figure>
        
          <p>
            <a class="article-more-link" href="/2021/11/02/Runtime-Part2/">
              Read More...
            </a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="blog.cfjia.cc/2021/11/02/Runtime-Part2/" data-id="ckvlronxp000n0d3qbtbybrx5" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/" rel="tag">Runtime</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Runtime-Part1" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2021/11/01/Runtime-Part1/" class="article-date">
  <time datetime="2021-11-01T02:21:58.000Z" itemprop="datePublished">2021-11-01</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/">iOS进阶</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="一、什么是动态语言，什么是Runtime？"><a href="#一、什么是动态语言，什么是Runtime？" class="headerlink" title="一、什么是动态语言，什么是Runtime？"></a>一、什么是动态语言，什么是Runtime？</h1><h2 id="静态语言-强类型语言-："><a href="#静态语言-强类型语言-：" class="headerlink" title="静态语言(强类型语言)："></a>静态语言(强类型语言)：</h2><p>静态语言是在编译时就要确定变量的数据类型，也就是变量使用之前必须声明数据类型。如：C、C++、Java、C#等。</p>
<h2 id="动态语言-弱类型语言"><a href="#动态语言-弱类型语言" class="headerlink" title="动态语言(弱类型语言):"></a>动态语言(弱类型语言):</h2><p>动态语言是在运行时才去做数据类型检查的语言，变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。如：PHP、Ruby、Shell、Python等一些脚本语言。</p>
<h2 id="为什么说OC是一门动态语言"><a href="#为什么说OC是一门动态语言" class="headerlink" title="为什么说OC是一门动态语言:"></a>为什么说OC是一门动态语言:</h2><p>静态、动态是相对的，这里动态语言指的是不需要再编译阶段就确定所有变量方法等，还可以在运行时动态的添加。 Objective-C，在C语言的基础上添加了面向对象的特性，并且通过Runtime这个运行时机制，在运行时可以动态的添加变量，方法，类等，所以说Objective-C是一门动态语言。</p>
<h2 id="OC的动态性"><a href="#OC的动态性" class="headerlink" title="OC的动态性:"></a>OC的动态性:</h2><h3 id="1-动态类型"><a href="#1-动态类型" class="headerlink" title="1.动态类型:"></a>1.动态类型:</h3><p>如id类型。实际上静态类型因为其固定性和可预知性而使用的特别广泛。静态类型是强类型，动态类型是弱类型，运行时决定接收者。</p>
<h3 id="2-动态绑定"><a href="#2-动态绑定" class="headerlink" title="2.动态绑定:"></a>2.动态绑定:</h3><p>让代码在运行时判断需要调用什么方法，而不是在编译时。与其他面向对象语言一样，方法调用和代码并没有在编译时连接在一起，而是在消息发送时才进行连接。运行时决定调用哪个方法。</p>
<h3 id="3-动态载入"><a href="#3-动态载入" class="headerlink" title="3.动态载入:"></a>3.动态载入:</h3><p> 让程序在运行时添加代码模块已经其他资源。用户可以根据需要执行一些可执行代码和资源，而不是在启动时就加载所有资源组件。可执行代码中可以含有和程序运行时整合的新类。</p>
        
          <p>
            <a class="article-more-link" href="/2021/11/01/Runtime-Part1/">
              Read More...
            </a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="blog.cfjia.cc/2021/11/01/Runtime-Part1/" data-id="ckvlronxg00030d3qcxpv6vkw" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/" rel="tag">Runtime</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>黑夜里的眸 &copy; 2021</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="黑夜里的眸"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>