<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <meta name="keywords" content="iOS">
  
  
  <meta name="description" content="cfjia个人博客">
  
  <title>
    iOS架构 - 组件化方案 (2) |
    
    黑夜里的眸
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.0.2"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-iOS架构 - 组件化方案 (2)" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  iOS架构 - 组件化方案 (2)
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2022/03/22/iOS%E6%9E%B6%E6%9E%84%20-%20%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%20(2)/" class="article-date">
  <time datetime="2022-03-22T06:52:16.000Z" itemprop="datePublished">2022-03-22</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/iOS%E8%BF%9B%E9%98%B6/">iOS进阶</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h3 id="组件化通讯方案"><a href="#组件化通讯方案" class="headerlink" title="组件化通讯方案"></a>组件化通讯方案</h3><p>目前主流的主要有以下三种方式：</p>
<ul>
<li>1、<code>URL</code>路由</li>
<li>2、<code>target-action</code></li>
<li>3、<code>protocol</code>匹配</li>
</ul>
<h3 id="URL路由"><a href="#URL路由" class="headerlink" title="URL路由"></a>URL路由</h3><p>目前iOS上大部分路由工具都是基于URL匹配的，或者是根据命名约定，用runtime方法进行动态调用</p>
<p>这些动态化的方案的优点是实现简单，缺点是需要维护字符串表，或者依赖于命名约定，无法在编译时暴露出所有问题，需要在运行时才能发现错误。</p>
<p>URL路由方式主要是以蘑菇街为代表的的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/meili/MGJRouter">MGJRouter</a></p>
<p>其实现思路是：</p>
<ul>
<li>App启动时实例化各组件模块，然后这些组件向<code>ModuleManager</code>注册<code>Url</code>，有些时候不需要实例化，使用class注册</li>
<li>当组件A需要调用组件B时，向<code>ModuleManager</code>传递URL，参数跟随URL以GET方式传递，类似openURL。然后由ModuleManager负责调度组件B，最后完成任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、注册某个URL</span><br><span class="line">MGJRouter.registerURLPattern(&quot;app:&#x2F;&#x2F;home&quot;) &#123; (info) in</span><br><span class="line">    print(&quot;info: \(info)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、调用路由</span><br><span class="line">MGJRouter.openURL(&quot;app:&#x2F;&#x2F;home&quot;)</span><br></pre></td></tr></table></figure>



<h4 id="URL-路由的优点"><a href="#URL-路由的优点" class="headerlink" title="URL 路由的优点"></a>URL 路由的优点</h4><ul>
<li>极高的动态性，适合经常开展运营活动的app，例如电商</li>
<li>方便地统一管理多平台的路由规则</li>
<li>易于适配URL Scheme</li>
</ul>
<h4 id="URl-路由的缺点"><a href="#URl-路由的缺点" class="headerlink" title="URl 路由的缺点"></a>URl 路由的缺点</h4><ul>
<li>传参方式有限，并且无法利用编译器进行参数类型检查，因此所有的参数都是通过字符串转换而来</li>
<li>只适用于界面模块，不适用于通用模块</li>
<li>参数的格式不明确，是个灵活的 dictionary，也需要有个地方可以查参数格式。</li>
<li>不支持storyboard</li>
<li>依赖于字符串硬编码，难以管理，蘑菇街做了个后台专门管理。</li>
<li>无法保证所使用的的模块一定存在</li>
<li>解耦能力有限，url 的”注册”、”实现”、”使用”必须用相同的字符规则，一旦任何一方做出修改都会导致其他方的代码失效，并且重构难度大</li>
</ul>
<p>除了<code>CTMediator</code>，还有以下这些三方框架</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/clayallsopp/routable-ios">routable-ios</a></li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/joeldev/JLRoutes">JLRoutes</a></li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/lightory/HHRouter">HHRouter</a></li>
</ul>
<h3 id="target-action"><a href="#target-action" class="headerlink" title="target-action"></a>target-action</h3><p>这个方案是基于OC的runtime、category特性动态获取模块，例如通过<code>NSClassFromString</code>获取类并创建实例，通过<code>performSelector + NSInvocation</code>动态调用方法</p>
<p>其主要的代表框架是<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/casatwy/CTMediator">casatwy的CTMediator</a></p>
<p>其实现思路是：</p>
<ul>
<li>1、利用分类为路由添加新接口，在接口中通过字符串获取对应的类</li>
<li>2、通过runtime创建实例，动态调用实例的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;******* 1、分类定义新接口</span><br><span class="line">extension CTMediator&#123;</span><br><span class="line">    @objc func A_showHome()-&gt;UIViewController?&#123;</span><br><span class="line">        let params &#x3D; [</span><br><span class="line">            kCTMediatorParamsKeySwiftTargetModuleName: &quot;CJLBase_Example&quot;</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        if let vc &#x3D; self.performTarget(&quot;A&quot;, action: &quot;Extension_HomeViewController&quot;, params: params, shouldCacheTarget: false) as? UIViewController&#123;</span><br><span class="line">            return vc</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******* 2、模块提供者提供target-action的调用方式（对外需要加上public关键字）</span><br><span class="line">class Target_A: NSObject &#123;</span><br><span class="line">    </span><br><span class="line">    @objc func Action_Extension_HomeViewController(_ params: [String: Any])-&gt;UIViewController&#123;</span><br><span class="line">         </span><br><span class="line">        let home &#x3D; HomeViewController()</span><br><span class="line">        return home</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******* 3、使用</span><br><span class="line">if let vc &#x3D; CTMediator.sharedInstance().A_showHome() &#123;</span><br><span class="line">            self.navigationController?.pushViewController(vc, animated: true)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>其模块间的引用关系如下图所示</p>
<p>![image.png](iOS架构 - 组件化方案 (2)/d74f03f0de964014923b74a6d4b9c5d3.png)</p>
<p><strong>优点</strong></p>
<p>**<br>**</p>
<ul>
<li>利用 <code>分类</code> 可以明确声明接口，进行编译检查</li>
<li>实现方式<code>轻量</code></li>
</ul>
<p>**<br>**</p>
<p><strong>缺点</strong></p>
<p>**<br>**</p>
<ul>
<li>需要在<code>mediator</code> 和 <code>target</code>中重新添加每一个接口，模块化时代码较为繁琐</li>
<li>在 <code>category</code> 中仍然引入了<code>字符串硬编码</code>，内部使用字典传参，一定程度上也存在和 URL 路由相同的问题</li>
<li>无法保证使用的模块一定存在，target在修改后，使用者只能在运行时才能发现错误</li>
<li>可能会创建过多的 target 类</li>
</ul>
<p>**<br>**</p>
<p><strong>CTMediator源码分析</strong></p>
<p>**<br>**</p>
<ul>
<li>通过分类中调用的<code>performTarget</code>来到<code>CTMediator</code>中的具体实现，即<code>performTarget:action:params:shouldCacheTarget:</code>，主要是通过传入的name，找到对应的<code>target</code> 和 <code>action</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</span><br><span class="line">&#123;</span><br><span class="line">    if (targetName &#x3D;&#x3D; nil || actionName &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在swift中使用时，需要传入对应项目的target名称，否则会找不到视图控制器</span><br><span class="line">    NSString *swiftModuleName &#x3D; params[kCTMediatorParamsKeySwiftTargetModuleName];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; generate target 生成target</span><br><span class="line">    NSString *targetClassString &#x3D; nil;</span><br><span class="line">    if (swiftModuleName.length &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;swift中target文件名拼接</span><br><span class="line">        targetClassString &#x3D; [NSString stringWithFormat:@&quot;%@.Target_%@&quot;, swiftModuleName, targetName];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;OC中target文件名拼接</span><br><span class="line">        targetClassString &#x3D; [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;缓存中查找target</span><br><span class="line">    NSObject *target &#x3D; [self safeFetchCachedTarget:targetClassString];</span><br><span class="line">    &#x2F;&#x2F;缓存中没有target</span><br><span class="line">    if (target &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        &#x2F;&#x2F;通过字符串获取对应的类</span><br><span class="line">        Class targetClass &#x3D; NSClassFromString(targetClassString);</span><br><span class="line">        &#x2F;&#x2F;创建实例</span><br><span class="line">        target &#x3D; [[targetClass alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; generate action 生成action方法名称</span><br><span class="line">    NSString *actionString &#x3D; [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];</span><br><span class="line">    &#x2F;&#x2F;通过方法名字符串获取对应的sel</span><br><span class="line">    SEL action &#x3D; NSSelectorFromString(actionString);</span><br><span class="line">    </span><br><span class="line">    if (target &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的</span><br><span class="line">        [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;是否需要缓存</span><br><span class="line">    if (shouldCacheTarget) &#123;</span><br><span class="line">        [self safeSetCachedTarget:target key:targetClassString];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;是否响应sel</span><br><span class="line">    if ([target respondsToSelector:action]) &#123;</span><br><span class="line">        &#x2F;&#x2F;动态调用方法</span><br><span class="line">        return [self safePerformAction:action target:target params:params];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理</span><br><span class="line">        SEL action &#x3D; NSSelectorFromString(@&quot;notFound:&quot;);</span><br><span class="line">        if ([target respondsToSelector:action]) &#123;</span><br><span class="line">            return [self safePerformAction:action target:target params:params];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。</span><br><span class="line">            [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [self.cachedTarget removeObjectForKey:targetClassString];</span><br><span class="line">            &#125;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>进入<code>safePerformAction:target:params:</code>实现，主要是通过<code>invocation</code>进行<code>参数传递+消息转发</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (id)safePerformAction:(SEL)action target:(NSObject *)target params:(NSDictionary *)params</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取方法签名</span><br><span class="line">    NSMethodSignature* methodSig &#x3D; [target methodSignatureForSelector:action];</span><br><span class="line">    if(methodSig &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取方法签名中的返回类型，然后根据返回值完成参数传递</span><br><span class="line">    const char* retType &#x3D; [methodSig methodReturnType];</span><br><span class="line">    &#x2F;&#x2F;void类型</span><br><span class="line">    if (strcmp(retType, @encode(void)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;...省略其他类型的判断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="protocol-class"><a href="#protocol-class" class="headerlink" title="protocol class"></a>protocol class</h3><p>protocol匹配的<code>实现思路</code>是：</p>
<ul>
<li>1、将<code>protocol</code>和对应的<code>类</code>进行<code>字典匹配</code></li>
<li>2、通过用<code>protocol</code>获取<code>class</code>，在<code>动态创建实例</code></li>
</ul>
<p>protocol比较典型的三方框架就是<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/alibaba/BeeHive">阿里的BeeHive</a>。<code>BeeHive</code>借鉴了Spring Service、Apache DSO的架构理念，<code>采用AOP+扩展App生命周期API</code>形式，将<code>业务功能</code>、<code>基础功能</code>模块以模块方式以解决大型应用中的复杂问题，并让<code>模块之间以Service形式调用</code>，将复杂问题切分，以AOP方式模块化服务。</p>
<p>**<br>**</p>
<h4 id="BeeHive-核心思想"><a href="#BeeHive-核心思想" class="headerlink" title="BeeHive 核心思想"></a>BeeHive 核心思想</h4><ul>
<li>1、各个模块间调用从直接调用对应模块，变成调用<code>Service</code>的形式，避免了直接依赖。</li>
<li>2、App生命周期的分发，将耦合在<code>AppDelegate</code>中逻辑拆分，每个模块以微应用的形式独立存在。</li>
</ul>
<p>示例如下（本想用swift写的，但是有点问题，暂时用OC写）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;******** 1、注册</span><br><span class="line">[[BeeHive shareInstance] registerService:@protocol(HomeServiceProtocol) service:[BHViewController class]];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******** 2、使用</span><br><span class="line">#import &quot;BHService.h&quot;</span><br><span class="line"></span><br><span class="line">id&lt; HomeServiceProtocol &gt; homeVc &#x3D; [[BeeHive shareInstance] createService:@protocol(HomeServiceProtocol)];</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<p>**<br>**</p>
<ul>
<li>1、利用接口调用，实现了参数传递时的类型安全</li>
<li>2、直接使用模块的protocol接口，无需再重复封装</li>
</ul>
<p><strong>缺点</strong></p>
<p>**<br>**</p>
<ul>
<li>1、用框架来创建所有对象，创建方式不同，即不支持外部传入参数</li>
<li>2、用<code>OC runtime</code>创建对象，不支持swift</li>
<li>3、只做了<code>protocol</code> 和 <code>class</code> 的匹配，不支持更复杂的创建方式 和依赖注入</li>
<li>4、无法保证所使用的protocol 一定存在对应的模块，也无法直接判断某个protocol是否能用于获取模块</li>
</ul>
<p>除了<code>BeeHive</code>，还有<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/Swinject/Swinject">Swinject</a></p>
<h3 id="BeeHive-模块注册"><a href="#BeeHive-模块注册" class="headerlink" title="BeeHive 模块注册"></a>BeeHive 模块注册</h3><p>在<code>BeeHive</code>主要是通过<code>BHModuleManager</code>来管理各个模块的。<code>BHModuleManager</code>中只会管理已经被注册过的模块。</p>
<p>BeeHive提供了三种不同的调用形式，<code>静态plist</code>，<code>动态注册</code>，<code>annotation</code>。Module、Service之间没有关联，每个业务模块可以单独实现Module或者Service的功能。</p>
<h4 id="1、-Annotation方式注册"><a href="#1、-Annotation方式注册" class="headerlink" title="1、 Annotation方式注册"></a>1、 Annotation方式注册</h4><p>这种方式主要是通过<code>BeeHiveMod</code>宏进行<code>Annotation</code>标记</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;***** 使用</span><br><span class="line">BeeHiveMod(ShopModule)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;***** BeeHiveMod的宏定义</span><br><span class="line">#define BeeHiveMod(name) \</span><br><span class="line">class BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) &#x3D; &quot;&quot;#name&quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;***** BeeHiveDATA的宏定义 </span><br><span class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot; &quot;)))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;*****  全部转换出来后为下面的格式</span><br><span class="line">char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot; &quot;))) &#x3D; &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>

<p>这里针对<code>__attribute</code>需要说明以下几点</p>
<ul>
<li>第一个参数<code>used</code>：用来修饰函数，被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器下会去掉没有被引用的段。</li>
<li>通过使用<code>__attribute__((section(&quot;name&quot;)))</code>来指明哪个段。数据则用<code>__attribute__((used))</code>来标记，防止链接器会优化删除未被使用的段，然后将模块注入到<code>__DATA</code>中</li>
</ul>
<p>此时Module已经被存储到Mach-O文件的特殊段中，那么如何取呢？</p>
<ul>
<li>进入<code>BHReadConfiguration</code>方法，主要是通过<code>Mach-O</code>找到存储的数据段，取出放入数组中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *configs &#x3D; [NSMutableArray array];</span><br><span class="line">    unsigned long size &#x3D; 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">    &#x2F;&#x2F; 找到之前存储的数据段(Module找BeehiveMods段 和 Service找BeehiveServices段)的一片内存</span><br><span class="line">    uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">    const struct mach_header_64 *mhp64 &#x3D; (const struct mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    unsigned long counter &#x3D; size&#x2F;sizeof(void*);</span><br><span class="line">    &#x2F;&#x2F; 把特殊段里面的数据都转换成字符串存入数组中</span><br><span class="line">    for(int idx &#x3D; 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        char *string &#x3D; (char*)memory[idx];</span><br><span class="line">        NSString *str &#x3D; [NSString stringWithUTF8String:string];</span><br><span class="line">        if(!str)continue;</span><br><span class="line">        </span><br><span class="line">        BHLog(@&quot;config &#x3D; %@&quot;, str);</span><br><span class="line">        if(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return configs; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、读取本地Pilst文件"><a href="#2、读取本地Pilst文件" class="headerlink" title="2、读取本地Pilst文件"></a>2、读取本地Pilst文件</h4><ul>
<li>首先，需要设置好路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BHContext shareInstance].moduleConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BeeHive&quot;;&#x2F;&#x2F;可选，默认为BeeHive.bundle&#x2F;BeeHive.plist</span><br></pre></td></tr></table></figure>

<p>创建plist文件，<code>Plist</code>文件的格式也是数组中包含多个字典。字典里面有两个Key，一个是<code>@&quot;moduleLevel&quot;</code>，另一个是<code>@&quot;moduleClass&quot;</code>。注意<code>根</code>的数组的名字叫<code>@“moduleClasses”</code>。</p>
<p>![image.png](iOS架构 - 组件化方案 (2)/00203bd5fb6f4b58ae880570cd684117.png)</p>
<ul>
<li>进入<code>loadLocalModules</code>方法，主要是从<code>Plist</code>里面取出数组，然后把数组加入到<code>BHModuleInfos</code>数组里面。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化context时，加载Modules和Services</span><br><span class="line">-(void)setContext:(BHContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    _context &#x3D; context;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [self loadStaticServices];</span><br><span class="line">        [self loadStaticModules];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">&#x2F;&#x2F;加载modules</span><br><span class="line">- (void)loadStaticModules</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 读取本地plist文件里面的Module，并注册到BHModuleManager的BHModuleInfos数组中</span><br><span class="line">    [[BHModuleManager sharedManager] loadLocalModules];</span><br><span class="line">    &#x2F;&#x2F;注册所有modules，在内部根据优先级进行排序</span><br><span class="line">    [[BHModuleManager sharedManager] registedAllModules];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)loadLocalModules</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;plist文件路径</span><br><span class="line">    NSString *plistPath &#x3D; [[NSBundle mainBundle] pathForResource:[BHContext shareInstance].moduleConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    &#x2F;&#x2F;判断文件是否存在</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;读取整个文件[@&quot;moduleClasses&quot; : 数组]</span><br><span class="line">    NSDictionary *moduleList &#x3D; [[NSDictionary alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    &#x2F;&#x2F;通过moduleClasses key读取 数组 [[@&quot;moduleClass&quot;:&quot;aaa&quot;, @&quot;moduleLevel&quot;: @&quot;bbb&quot;], [...]]</span><br><span class="line">    NSArray&lt;NSDictionary *&gt; *modulesArray &#x3D; [moduleList objectForKey:kModuleArrayKey];</span><br><span class="line">    NSMutableDictionary&lt;NSString *, NSNumber *&gt; *moduleInfoByClass &#x3D; @&#123;&#125;.mutableCopy;</span><br><span class="line">    &#x2F;&#x2F;遍历数组</span><br><span class="line">    [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        [moduleInfoByClass setObject:@1 forKey:[obj objectForKey:kModuleInfoNameKey]];</span><br><span class="line">    &#125;];</span><br><span class="line">    [modulesArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if (!moduleInfoByClass[[obj objectForKey:kModuleInfoNameKey]]) &#123;</span><br><span class="line">            &#x2F;&#x2F;存储到 BHModuleInfos 中</span><br><span class="line">            [self.BHModuleInfos addObject:obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、load方法注册"><a href="#3、load方法注册" class="headerlink" title="3、load方法注册"></a>3、load方法注册</h4><p>该方法<code>注册Module</code>就是在<code>Load</code>方法里面注册Module的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    [BeeHive registerDynamicModule:[self class]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>进入<code>registerDynamicModule</code>实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] registerDynamicModule:moduleClass];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [self registerDynamicModule:moduleClass shouldTriggerInitEvent:NO];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">       shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent</span><br><span class="line">&#123;</span><br><span class="line">    [self addModuleFromObject:moduleClass shouldTriggerInitEvent:shouldTriggerInitEvent];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其底层还是同第一种方式一样，最终会走到<code>addModuleFromObject:shouldTriggerInitEvent:</code>方法中</p>
<ul>
<li>load方法，还可以使用<code>BH_EXPORT_MODULE</code>宏代替</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define BH_EXPORT_MODULE(isAsync) \</span><br><span class="line">+ (void)load &#123; [BeeHive registerDynamicModule:[self class]]; &#125; \</span><br><span class="line">-(BOOL)async &#123; return [[NSString stringWithUTF8String:#isAsync] boolValue];&#125;</span><br></pre></td></tr></table></figure>

<p><code>BH_EXPORT_MODULE</code>宏里面可以传入一个参数，代表<code>是否异步加载Module模块</code>，如果是<code>YES</code>就是<code>异步加载</code>，如果是<code>NO</code>就是<code>同步加载</code>。</p>
<h3 id="2、BeeHive-模块事件"><a href="#2、BeeHive-模块事件" class="headerlink" title="2、BeeHive 模块事件"></a>2、BeeHive 模块事件</h3><p>BeeHive会给每个模块提供生命周期事件，用于与BeeHive宿主环境进行必要信息交互，感知模块生命周期的变化。</p>
<p>BeeHive各个模块会收到一些事件。在<code>BHModuleManager</code>中，所有的事件被定义成了<code>BHModuleEventType</code>枚举。如下所示，其中有2个事件很特殊，一个是<code>BHMInitEvent</code>，一个是<code>BHMTearDownEvent</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, BHModuleEventType)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;设置Module模块</span><br><span class="line">    BHMSetupEvent &#x3D; 0,</span><br><span class="line">    &#x2F;&#x2F;用于初始化Module模块，例如环境判断，根据不同环境进行不同初始化</span><br><span class="line">    BHMInitEvent,</span><br><span class="line">    &#x2F;&#x2F;用于拆除Module模块</span><br><span class="line">    BHMTearDownEvent,</span><br><span class="line">    BHMSplashEvent,</span><br><span class="line">    BHMQuickActionEvent,</span><br><span class="line">    BHMWillResignActiveEvent,</span><br><span class="line">    BHMDidEnterBackgroundEvent,</span><br><span class="line">    BHMWillEnterForegroundEvent,</span><br><span class="line">    BHMDidBecomeActiveEvent,</span><br><span class="line">    BHMWillTerminateEvent,</span><br><span class="line">    BHMUnmountEvent,</span><br><span class="line">    BHMOpenURLEvent,</span><br><span class="line">    BHMDidReceiveMemoryWarningEvent,</span><br><span class="line">    BHMDidFailToRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidReceiveRemoteNotificationEvent,</span><br><span class="line">    BHMDidReceiveLocalNotificationEvent,</span><br><span class="line">    BHMWillPresentNotificationEvent,</span><br><span class="line">    BHMDidReceiveNotificationResponseEvent,</span><br><span class="line">    BHMWillContinueUserActivityEvent,</span><br><span class="line">    BHMContinueUserActivityEvent,</span><br><span class="line">    BHMDidFailToContinueUserActivityEvent,</span><br><span class="line">    BHMDidUpdateUserActivityEvent,</span><br><span class="line">    BHMHandleWatchKitExtensionRequestEvent,</span><br><span class="line">    BHMDidCustomEvent &#x3D; 1000</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要分为三种</p>
<ul>
<li>1、<code>系统事件</code>：主要是指<code>Application生命周期事件</code>!<br>![image.png](iOS架构 - 组件化方案 (2)/457cc2e7bd1345e58e5ee7aa63e94df5.png)</li>
</ul>
<p>一般的做法是<code>AppDelegate</code>改为<code>继承自BHAppDelegate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface TestAppDelegate : BHAppDelegate &lt;UIApplicationDelegate&gt;</span><br></pre></td></tr></table></figure>

<p>2、<code>应用事件</code>：官方给出的流程图，其中<code>modSetup</code>、<code>modInit</code>等，可以用于编码实现各插件模块的设置与初始化。</p>
<p>![image.png](iOS架构 - 组件化方案 (2)/4dff469e37654d99b9c051fd7aafbad4.png)</p>
<ul>
<li>3、<code>自定义事件</code></li>
</ul>
<p>以上所有的事件都可以通过调用<code>BHModuleManager</code>的<code>triggerEvent:</code>来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">&#123;</span><br><span class="line">    [self triggerEvent:eventType withCustomParam:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">     withCustomParam:(NSDictionary *)customParam &#123;</span><br><span class="line">    [self handleModuleEvent:eventType forTarget:nil withCustomParam:customParam];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">#pragma mark - module protocol</span><br><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">          withCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    switch (eventType) &#123;</span><br><span class="line">            &#x2F;&#x2F;初始化事件</span><br><span class="line">        case BHMInitEvent:</span><br><span class="line">            &#x2F;&#x2F;special</span><br><span class="line">            [self handleModulesInitEventForTarget:nil withCustomParam :customParam];</span><br><span class="line">            break;</span><br><span class="line">            &#x2F;&#x2F;析构事件</span><br><span class="line">        case BHMTearDownEvent:</span><br><span class="line">            &#x2F;&#x2F;special</span><br><span class="line">            [self handleModulesTearDownEventForTarget:nil withCustomParam:customParam];</span><br><span class="line">            break;</span><br><span class="line">            &#x2F;&#x2F;其他3类事件</span><br><span class="line">        default: &#123;</span><br><span class="line">            NSString *selectorStr &#x3D; [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">            [self handleModuleEvent:eventType forTarget:nil withSeletorStr:selectorStr andCustomParam:customParam];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以发现，除去<code>BHMInitEvent</code>初始化事件和<code>BHMTearDownEvent</code>拆除Module事件这两个特殊事件以外，所有的事件都是调用的<code>handleModuleEvent:forTarget:withSeletorStr:andCustomParam:</code>方法，其内部实现主要是遍历 <code>moduleInstances</code> 实例数组，调用<code>performSelector:withObject:</code>方法实现对应方法调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">           withSeletorStr:(NSString *)selectorStr</span><br><span class="line">           andCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    BHContext *context &#x3D; [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam &#x3D; customParam;</span><br><span class="line">    context.customEvent &#x3D; eventType;</span><br><span class="line">    if (!selectorStr.length) &#123;</span><br><span class="line">        selectorStr &#x3D; [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    SEL seletor &#x3D; NSSelectorFromString(selectorStr);</span><br><span class="line">    if (!seletor) &#123;</span><br><span class="line">        selectorStr &#x3D; [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">        seletor &#x3D; NSSelectorFromString(selectorStr);</span><br><span class="line">    &#125;</span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances &#x3D; @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances &#x3D; [self.BHModulesByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;遍历 moduleInstances 实例数组，调用performSelector:withObject:方法实现对应方法调用</span><br><span class="line">    [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if ([moduleInstance respondsToSelector:seletor]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">            &#x2F;&#x2F;进行方法调用</span><br><span class="line">            [moduleInstance performSelector:seletor withObject:context];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">            </span><br><span class="line">            [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- %@&quot;, [moduleInstance class], NSStringFromSelector(seletor)]];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:这里所有的<code>Module</code>必须是遵循<code>BHModuleProtocol</code>的，否则无法接收到这些事件的消息。</p>
<h3 id="3、BeeHive模块调用"><a href="#3、BeeHive模块调用" class="headerlink" title="3、BeeHive模块调用"></a>3、BeeHive模块调用</h3><p>在BeeHive中是通过<code>BHServiceManager</code>来管理各个<code>Protocol</code>的。<code>BHServiceManager</code>中只会管理已经<code>被注册过的Protocol</code>。</p>
<p>注册<code>Protocol</code>的方式总共有三种，和注册<code>Module</code>是一样一一对应的</p>
<p>**<br>**</p>
<p><strong>1、Annotation方式注册</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;****** 1、通过BeeHiveService宏进行Annotation标记</span><br><span class="line">BeeHiveService(HomeServiceProtocol,BHViewController)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;****** 2、宏定义</span><br><span class="line">#define BeeHiveService(servicename,impl) \</span><br><span class="line">class BeeHive; char * k##servicename##_service BeeHiveDATA(BeehiveServices) &#x3D; &quot;&#123; \&quot;&quot;#servicename&quot;\&quot; : \&quot;&quot;#impl&quot;\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;****** 3、转换后的格式，也是将其存储到特殊的段</span><br><span class="line">char * kHomeServiceProtocol_service __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot; &quot;))) &#x3D; &quot;&#123; \&quot;&quot;&quot;HomeServiceProtocol&quot;&quot;\&quot; : \&quot;&quot;&quot;BHViewController&quot;&quot;\&quot;&#125;&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>2、读取本地plist文件</strong></p>
<p>**<br>**</p>
<ul>
<li>首先同Module一样，需要先设置好路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BHContext shareInstance].serviceConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BHService&quot;;</span><br></pre></td></tr></table></figure>

<p>设置plist文件</p>
<p>![image.png](iOS架构 - 组件化方案 (2)/4df6cb91860d497cbd80e60c033dae9c.png)</p>
<ul>
<li>同样也是在<code>setContext</code>时注册<code>services</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;加载services</span><br><span class="line">-(void)loadStaticServices</span><br><span class="line">&#123;</span><br><span class="line">    [BHServiceManager sharedManager].enableException &#x3D; self.enableException;</span><br><span class="line">    </span><br><span class="line">    [[BHServiceManager sharedManager] registerLocalServices];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerLocalServices</span><br><span class="line">&#123;</span><br><span class="line">    NSString *serviceConfigName &#x3D; [BHContext shareInstance].serviceConfigName;</span><br><span class="line">    &#x2F;&#x2F;获取plist文件路径</span><br><span class="line">    NSString *plistPath &#x3D; [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    if (!plistPath) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSArray *serviceList &#x3D; [[NSArray alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    [self.lock lock];</span><br><span class="line">    &#x2F;&#x2F;遍历并存储到allServicesDict中</span><br><span class="line">    for (NSDictionary *dict in serviceList) &#123;</span><br><span class="line">        NSString *protocolKey &#x3D; [dict objectForKey:@&quot;service&quot;];</span><br><span class="line">        NSString *protocolImplClass &#x3D; [dict objectForKey:@&quot;impl&quot;];</span><br><span class="line">        if (protocolKey.length &gt; 0 &amp;&amp; protocolImplClass.length &gt; 0) &#123;</span><br><span class="line">            [self.allServicesDict addEntriesFromDictionary:@&#123;protocolKey:protocolImplClass&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、load方法注册</strong></p>
<p>**<br>**</p>
<p>在Load方法里面注册<code>Protocol</code>协议，主要是调用<code>BeeHive</code>里面的<code>registerService:service:</code>完成<code>protocol</code>的注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">   [[BeeHive shareInstance] registerService:@protocol(UserTrackServiceProtocol) service:[BHUserTrackViewController class]];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerService:(Protocol *)proto service:(Class) serviceClass</span><br><span class="line">&#123;</span><br><span class="line">    [[BHServiceManager sharedManager] registerService:proto implClass:serviceClass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，三种方式就创建完成了</p>
<p><strong>Protocol的获取</strong></p>
<p>**<br>**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Protocol&#96;与&#96;Module&#96;的区别在于，&#96;Protocol&#96;比&#96;Module&#96;多了一个方法，可以&#96;返回Protocol实例对象</span><br><span class="line">- (id)createService:(Protocol *)proto;</span><br><span class="line">&#123;</span><br><span class="line">    return [[BHServiceManager sharedManager] createService:proto];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service</span><br><span class="line">&#123;</span><br><span class="line">    return [self createService:service withServiceName:nil];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName &#123;</span><br><span class="line">    return [self createService:service withServiceName:serviceName shouldCache:YES];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName shouldCache:(BOOL)shouldCache &#123;</span><br><span class="line">    if (!serviceName.length) &#123;</span><br><span class="line">        serviceName &#x3D; NSStringFromProtocol(service);</span><br><span class="line">    &#125;</span><br><span class="line">    id implInstance &#x3D; nil;</span><br><span class="line">    &#x2F;&#x2F;判断protocol是否已经注册过</span><br><span class="line">    if (![self checkValidService:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol does not been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *serviceStr &#x3D; serviceName;</span><br><span class="line">    &#x2F;&#x2F;如果有缓存，则直接从缓存中获取</span><br><span class="line">    if (shouldCache) &#123;</span><br><span class="line">        id protocolImpl &#x3D; [[BHContext shareInstance] getServiceInstanceFromServiceName:serviceStr];</span><br><span class="line">        if (protocolImpl) &#123;</span><br><span class="line">            return protocolImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取类后，然后响应下层的方法</span><br><span class="line">    Class implClass &#x3D; [self serviceImplClass:service];</span><br><span class="line">    if ([[implClass class] respondsToSelector:@selector(singleton)]) &#123;</span><br><span class="line">        if ([[implClass class] singleton]) &#123;</span><br><span class="line">            if ([[implClass class] respondsToSelector:@selector(shareInstance)])</span><br><span class="line">                &#x2F;&#x2F;创建单例对象</span><br><span class="line">                implInstance &#x3D; [[implClass class] shareInstance];</span><br><span class="line">            else</span><br><span class="line">                &#x2F;&#x2F;创建实例对象</span><br><span class="line">                implInstance &#x3D; [[implClass alloc] init];</span><br><span class="line">            if (shouldCache) &#123;</span><br><span class="line">                &#x2F;&#x2F;缓存</span><br><span class="line">                [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [[implClass alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createService</code>会先检查Protocol协议是否是注册过的。然后接着取出字典里面对应的Class，如果实现了<code>shareInstance</code>方法，那么就创建一个<code>单例对象</code>，如果没有，那么就创建一个<code>实例对象</code>。如果还实现了singleton，就能进一步的把<code>implInstance</code>和<code>serviceStr</code>对应的加到<code>BHContext</code>的<code>servicesByName</code>字典里面<code>缓存</code>起来。这样就可以随着上下文传递了</p>
<ul>
<li>进入<code>serviceImplClass</code>实现，从这里可以看出 protocol和类是通过<code>字典</code>绑定的，<code>protocol</code>作为<code>key</code>，<code>serviceImp</code>（类的名字）作为<code>value</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (Class)serviceImplClass:(Protocol *)service</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;通过字典将 协议 和 类 绑定，其中协议作为key，serviceImp（类的名字）作为value</span><br><span class="line">    NSString *serviceImpl &#x3D; [[self servicesDict] objectForKey:NSStringFromProtocol(service)];</span><br><span class="line">    if (serviceImpl.length &gt; 0) &#123;</span><br><span class="line">        return NSClassFromString(serviceImpl);</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Module-amp-Protocol"><a href="#Module-amp-Protocol" class="headerlink" title="Module &amp; Protocol"></a>Module &amp; Protocol</h3><p>这里简单总结下：</p>
<ul>
<li>对于<code>Module</code>：数组存储</li>
<li>对于<code>Protocol</code>：通过字典将<code>protocol</code>与类进行绑定，<code>key</code>为<code>protocol</code>，<code>value</code>为 <code>serviceImp</code>即类名</li>
</ul>
<h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><ul>
<li><code>BHConfig</code>类：是一个单例，其内部有一个<code>NSMutableDictionary</code>类型的<code>config</code>属性，该属性维护了一些动态的环境变量，作为<code>BHContext</code>的补充存在</li>
<li><code>BHContext</code>类：是一个单例，其内部有两个<code>NSMutableDictionary</code>的属性，分别是<code>modulesByName</code> 和 <code>servicesByName</code>。这个类主要用来保存上下文信息的。例如在<code>application:didFinishLaunchingWithOptions:</code>的时候，就可以初始化大量的上下文信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;保存信息</span><br><span class="line">[BHContext shareInstance].application &#x3D; application;</span><br><span class="line">[BHContext shareInstance].launchOptions &#x3D; launchOptions;</span><br><span class="line">[BHContext shareInstance].moduleConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BeeHive&quot;;&#x2F;&#x2F;可选，默认为BeeHive.bundle&#x2F;BeeHive.plist</span><br><span class="line">[BHContext shareInstance].serviceConfigName &#x3D; @&quot;BeeHive.bundle&#x2F;BHService&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>BHTimeProfiler</code>类：用来进行计算时间性能方面的Profiler</li>
<li><code>BHWatchDog</code>类：用来开一个线程，监听主线程是否堵塞</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="blog.cfjia.cc/2022/03/22/iOS%E6%9E%B6%E6%9E%84%20-%20%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%20(2)/" data-id="clcpq1v1w000i1vjigvug5gv8" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Runtime/" rel="tag">Runtime</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2022/12/21/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-1/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      iOS面试题 part 1 - Runtime 内存结构
      
    </div>
  </a>
  
  
  <a href="/2022/03/22/iOS%E6%9E%B6%E6%9E%84%20-%20%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%20(1)/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">iOS架构 - 组件化方案 (1)</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>黑夜里的眸 &copy; 2023</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="黑夜里的眸"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/favorites">Favorites</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>